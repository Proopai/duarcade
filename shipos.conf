---
name: Ship OS Conf
slots:
  databank:
    class: DatabankUnit
  atmofueltank:
    class: AtmoFuelContainer
    select: all
  spacefueltank:
    class: SpaceFuelContainer
    select: all
  rocketfueltank:
    class: RocketFuelContainer
    select: all
  gyro:
    class: GyroUnit
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  core:
    class: CoreUnit
handlers:
  system:
    actionStart:
      lua: press("ANTIGRAVITY")
      args: [antigravity]
    actionStop:
      lua: release("ANTIGRAVITY")
      args: [antigravity]
    actionStart:
      lua: press("BACKWARD")
      args: [backward]
    actionStop:
      lua: release("BACKWARD")
      args: [backward]
    actionStart:
      lua: press("BOOSTER")
      args: [booster]
    actionStop:
      lua: release("BOOSTER")
      args: [booster]
    actionLoop:
      lua: loopKey("BRAKE")
      args: [brake]
    actionStart:
      lua: press("BRAKE")
      args: [brake]
    actionStop:
      lua: release("BRAKE")
      args: [brake]
    actionStart:
      lua: press("DOWN")
      args: [down]
    actionStop:
      lua: release("DOWN")
      args: [down]
    flush:
      lua: onFlush(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("FORWARD")
      args: [forward]
    actionStop:
      lua: release("FORWARD")
      args: [forward]
    actionStart:
      lua: press("GEAR")
      args: [gear]
    actionStop:
      lua: release("GEAR")
      args: [gear]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStart:
      lua: press("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStop:
      lua: release("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStop:
      lua: release("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("LALT")
      args: [lalt]
    actionStop:
      lua: release("LALT")
      args: [lalt]
    actionStart:
      lua: press("LEFT")
      args: [left]
    actionStop:
      lua: release("LEFT")
      args: [left]
    actionStart:
      lua: press("LIGHT")
      args: [light]
    actionStop:
      lua: release("LIGHT")
      args: [light]
    actionStart:
      lua: press("LSHIFT")
      args: [lshift]
    actionStop:
      lua: release("LSHIFT")
      args: [lshift]
    actionStart:
      lua: press("RIGHT")
      args: [right]
    actionStop:
      lua: release("RIGHT")
      args: [right]
    actionLoop:
      lua: loopKey("SPEEDDOWN")
      args: [speeddown]
    actionStart:
      lua: press("SPEEDDOWN")
      args: [speeddown]
    actionStop:
      lua: release("SPEEDDOWN")
      args: [speeddown]
    actionLoop:
      lua: loopKey("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("SPEEDUP")
      args: [speedup]
    actionStop:
      lua: release("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("STOPENGINES")
      args: [stopengines]
    actionStop:
      lua: release("STOPENGINES")
      args: [stopengines]
    actionStart:
      lua: press("STRAFELEFT")
      args: [strafeleft]
    actionStop:
      lua: release("STRAFELEFT")
      args: [strafeleft]
    actionStart:
      lua: press("STRAFERIGHT")
      args: [straferight]
    actionStop:
      lua: release("STRAFERIGHT")
      args: [straferight]
    actionStart:
      lua: press("UP")
      args: [up]
    actionStop:
      lua: release("UP")
      args: [up]
    update:
      lua: onUpdate(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("WARP")
      args: [warp]
    actionStop:
      lua: release("WARP")
      args: [warp]
    actionStart:
      lua: press("YAWLEFT")
      args: [yawleft]
    actionStop:
      lua: release("YAWLEFT")
      args: [yawleft]
    actionStart:
      lua: press("YAWRIGHT")
      args: [yawright]
    actionStop:
      lua: release("YAWRIGHT")
      args: [yawright]
    start:
      lua: "local SCREEN_X = 1920\nlocal SCREEN_Y = 1080\nfunction ischild(tbl)\nif
        type(tbl) == \"string\" then\nreturn true\nend\n-- Or if it has array-style
        indexes.\nfor i, _ in ipairs(tbl) do\nreturn true\nend\nreturn false\nend\nfunction
        el(name, params, children)\nlocal attrvals = \"\"\nif ischild(params) then\nchildren
        = params\nelseif params then\nfor k, v in pairs(params) do\nk =\nk:gsub(\n\"%u\",\nfunction(c)\nreturn
        \"-\" .. c:lower()\nend\n)\nattrvals = attrvals .. \" \" .. k .. '=\"' ..
        v .. '\"'\nend\nend\nif type(children) == \"string\" then\nreturn string.format(\"<%s%s>%s</%s>\",
        name, attrvals, children, name)\nelseif type(children) == \"table\" then\nreturn
        string.format(\"<%s%s>%s</%s>\", name, attrvals, table.concat(children, \"\\n\"),
        name)\nelse\nreturn string.format(\"<%s%s />\", name, attrvals)\nend\nend\nlastarg
        = \"\"\nfunction eldebug(arg)\nif arg ~= lastarg then\nsystem.print(string.gsub(string.gsub(arg,
        \"<\", \"(\"), \">\", \")\"))\nlastarg = arg\nend\nreturn arg\nend\nlocal
        Render = {}\nRender.distance = function(meters)\nmeters = math.floor(meters)\nif
        meters < 10000 then\nreturn string.format(\"%dm\", meters)\nelseif meters
        < 250000 then\nreturn string.format(\"%dkm\", math.floor(meters / 1000))\nelse\nreturn
        string.format(\"%dsu\", math.floor(meters / 200000))\nend\nend\nRender.time
        = function(secs)\nlocal sign = ''\nif secs < 0 then\nsign = '-'\nend\nsecs
        = math.abs(secs)\nlocal days = math.floor(secs / 86400)\nsecs = secs % 86400\nlocal
        hours = math.floor(secs / 3600)\nsecs = secs % 3600\nlocal minutes = math.floor(secs
        / 60)\nsecs = math.floor(secs % 60)\nif days > 0 then\nreturn string.format(\"%s%dd
        %.2dh\", sign, days, hours)\nelseif hours > 0 then\nreturn string.format(\"%s%dh
        %.2dm\", sign, hours, minutes)\nelseif minutes > 0 then\nreturn string.format(\"%s%dm
        %.2ds\", sign, minutes, secs)\nelse\nreturn string.format(\"%s%ds\", sign,
        secs)\nend\nend\nfunction Kinematics() --\n--[[ \nDualUniverse kinematic equations\nAuthor:
        JayleBreak\nUsage (unit.start):\nKinematics = require('autoconf.custom.kinematics')\nMethods:\ncomputeAccelerationTime
        - \"relativistic\" version of t = (vf - vi)/a\ncomputeDistanceAndTime - Return
        distance & time needed to reach final speed.\ncomputeTravelTime - \"relativistic\"
        version of t=(sqrt(2ad+v^2)-v)/a\nDescription\nDualUniverse increases the
        effective mass of constructs as their absolute\nspeed increases by using the
        \"lorentz\" factor (from relativity) as the scale\nfactor.  This results in
        an upper bound on the absolute speed of constructs\n(excluding \"warp\" drive)
        that is set to 30 000 KPH (8 333 MPS). This module\nprovides utilities for
        computing some physical quantities taking this\nscaling into account.\n]]\nlocal
        Kinematic = {} -- just a namespace\nlocal C = 30000000 / 3600\nlocal C2 =
        C * C\nlocal ITERATIONS = 100 -- iterations over engine \"warm-up\" period\nlocal
        function lorentz(v)\nreturn 1 / math.sqrt(1 - v * v / C2)\nend\n--\n-- computeAccelerationTime
        - \"relativistic\" version of t = (vf - vi)/a\n-- initial      [in]: initial
        (positive) speed in meters per second.\n-- acceleration [in]: constant acceleration
        until 'finalSpeed' is reached.\n-- final        [in]: the speed at the end
        of the time interval.\n-- return: the time in seconds spent in traversing
        the distance\n--\nfunction Kinematic.computeAccelerationTime(initial, acceleration,
        final)\n-- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)\nlocal
        k1 = C * math.asin(initial / C)\nreturn (C * math.asin(final / C) - k1) /
        acceleration\nend\n--\n-- computeDistanceAndTime - Return distance & time
        needed to reach final speed.\n-- initial[in]:     Initial speed in meters
        per second.\n-- final[in]:       Final speed in meters per second.\n-- restMass[in]:
        \   Mass of the construct at rest in Kg.\n-- thrust[in]:      Engine's maximum
        thrust in Newtons.\n-- t50[in]:         (default: 0) Time interval to reach
        50% thrust in seconds.\n-- brakeThrust[in]: (default: 0) Constant thrust term
        when braking.\n-- return: Distance (in meters), time (in seconds) required
        for change.\n--\nfunction Kinematic.computeDistanceAndTime(initial, final,
        restMass, thrust, t50, brakeThrust)\n-- This function assumes that the applied
        thrust is colinear with the\n-- velocity. Furthermore, it does not take into
        account the influence\n-- of gravity, not just in terms of its impact on velocity,
        but also\n-- its impact on the orientation of thrust relative to velocity.\n--
        These factors will introduce (usually) small errors which grow as\n-- the
        length of the trip increases.\nt50 = t50 or 0\nbrakeThrust = brakeThrust or
        0 -- usually zero when accelerating\nlocal tau0 = lorentz(initial)\nlocal
        speedUp = initial <= final\nlocal a0 = thrust * (speedUp and 1 or -1) / restMass\nlocal
        b0 = -brakeThrust / restMass\nlocal totA = a0 + b0\nif speedUp and totA <=
        0 or not speedUp and totA >= 0 then\nreturn -1, -1 -- no solution\nend\nlocal
        distanceToMax, timeToMax = 0, 0\n-- If, the T50 time is set, then assume engine
        is at zero thrust and will\n-- reach full thrust in 2*T50 seconds. Thrust
        curve is given by:\n-- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2 where z=pi*(t/t50
        - 1)/2\n-- Acceleration is given by F(z)/m(z) where m(z) = m/sqrt(1-v^2/c^2)\n--
        or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2\nif a0 ~= 0 and t50 >
        0 then\n-- Closed form solution for velocity exists:\n-- v(t) = -c*tan(w)/sqrt(tan(w)^2+1)
        => w = -asin(v/c)\n-- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c\n--
        @ t=0, v(0) = vi\n-- pi*c*k1/pi/c = -asin(vi/c)\n-- k1 = asin(vi/c)\nlocal
        k1 = math.asin(initial / C)\nlocal c1 = math.pi * (a0 / 2 + b0)\nlocal c2
        = a0 * t50\nlocal c3 = C * math.pi\nlocal v = function(t)\nlocal w = (c1 *
        t - c2 * math.sin(math.pi * t / 2 / t50) + c3 * k1) / c3\nlocal tan = math.tan(w)\nreturn
        C * tan / math.sqrt(tan * tan + 1)\nend\nlocal speedchk = speedUp and function(s)\nreturn
        s >= final\nend or function(s)\nreturn s <= final\nend\ntimeToMax = 2 * t50\nif
        speedchk(v(timeToMax)) then\nlocal lasttime = 0\nwhile math.abs(timeToMax
        - lasttime) > 0.5 do\nlocal t = (timeToMax + lasttime) / 2\nif speedchk(v(t))
        then\ntimeToMax = t\nelse\nlasttime = t\nend\nend\nend\n-- There is no closed
        form solution for distance in this case.\n-- Numerically integrate for time
        t=0 to t=2*T50 (or less)\nlocal lastv = initial\nlocal tinc = timeToMax /
        ITERATIONS\nfor step = 1, ITERATIONS do\nlocal speed = v(step * tinc)\ndistanceToMax
        = distanceToMax + (speed + lastv) * tinc / 2\nlastv = speed\nend\nif timeToMax
        < 2 * t50 then\nreturn distanceToMax, timeToMax\nend\ninitial = lastv\nend\n--
        At full thrust, acceleration only depends on the Lorentz factor:\n-- v(t)'
        = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0\n-- -> v = c*sin((at+k1)/c)\n--
        @ t=0, v=vi: k1 = c*asin(vi/c)\n-- -> t = (c*asin(v/c) - k1)/a\n-- x(t)' =
        c*sin((at+k1)/c)\n-- x = k2 - c^2 cos((at+k1)/c)/a\n-- @ t=0, x=0: k2 = c^2
        * cos(k1/c)/a\nlocal k1 = C * math.asin(initial / C)\nlocal time = (C * math.asin(final
        / C) - k1) / totA\nlocal k2 = C2 * math.cos(k1 / C) / totA\nlocal distance
        = k2 - C2 * math.cos((totA * time + k1) / C) / totA\nreturn distance + distanceToMax,
        time + timeToMax\nend\n--\n-- computeTravelTime - \"relativistic\" version
        of t=(sqrt(2ad+v^2)-v)/a\n-- initialSpeed [in]: initial (positive) speed in
        meters per second\n-- acceleration [in]: constant acceleration until 'distance'
        is traversed\n-- distance [in]: the distance traveled in meters\n-- return:
        the time in seconds spent in traversing the distance\n--\nfunction Kinematic.computeTravelTime(initial,
        acceleration, distance)\n-- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a\n--
        (from: d=vt+at^2/2)\nif distance == 0 then\nreturn 0\nend\nif acceleration
        > 0 then\nlocal k1 = C * math.asin(initial / C)\nlocal k2 = C2 * math.cos(k1
        / C) / acceleration\nreturn (C * math.acos(acceleration * (k2 - distance)
        / C2) - k1) / acceleration\nend\nassert(initial > 0, \"Acceleration and initial
        speed are both zero.\")\nreturn distance / initial\nend\nfunction Kinematic.lorentz(v)\nreturn
        lorentz(v)\nend\nreturn Kinematic\nend\nKinematic = Kinematics()\n-- Physics
        stuff used by most of the scripted engines.\n-- Axis\nlocal PHYSICS = {\nPRESSED
        = {},\nnullvec = vec3(0.0, 0.0, 0.0)\n}\nfunction PHYSICS.keyState(key)\nreturn
        PHYSICS.PRESSED[key] and 1 or 0\nend\nfunction d2r(v)\nreturn v * constants.deg2rad\nend\nfunction
        PHYSICS.update()\n-- Information about the ship\nlocal unit_data = json.decode(unit.getData())\nPHYSICS.maxBrakeForce
        = unit_data[\"maxBrake\"] or 100000000\nPHYSICS.currentSpeed = unit_data[\"speed\"]\nPHYSICS.currentBrake
        = unit_data[\"currentBrake\"]\nPHYSICS.currentAccel = unit_data[\"acceleration\"]\n--
        Gravity and which way is 'up'\nPHYSICS.worldGravity = vec3(core.getWorldGravity())\nPHYSICS.worldVertical
        = vec3(core.getWorldVertical())\nPHYSICS.altitude = core.getAltitude()\nPHYSICS.position
        = vec3(core.getConstructWorldPos())\n-- Construct orientation\nPHYSICS.constructUp
        = vec3(core.getConstructWorldOrientationUp())\nPHYSICS.constructForward =
        vec3(core.getConstructWorldOrientationForward())\nPHYSICS.constructRight =
        vec3(core.getConstructWorldOrientationRight())\nPHYSICS.constructLocalUp =
        vec3(core.getConstructOrientationUp())\nPHYSICS.constructLocalForward = vec3(core.getConstructOrientationForward())\nPHYSICS.constructLocalRight
        = vec3(core.getConstructOrientationRight())\nPHYSICS.constructMass = core.getConstructMass()\n--
        Ship velocity relative to the world\nPHYSICS.constructVelocity = vec3(core.getWorldVelocity())\nPHYSICS.constructVelocityDir
        = vec3(core.getWorldVelocity()):normalize()\nPHYSICS.constructVelocitySpeed
        = vec3(core.getWorldVelocity()):len()\n-- Angular velocity\nPHYSICS.constructAngularVelocity
        = vec3(core.getWorldAngularVelocity())\nPHYSICS.airAngularFriction = vec3(core.getWorldAirFrictionAngularAcceleration())\n--
        Pitch and Roll relative to the planet\n-- I want pitch of 0 to be ship = flat,
        but game thinks flat = -90\nPHYSICS.currentPitchDeg = (getRoll(PHYSICS.worldVertical,
        PHYSICS.constructRight, PHYSICS.constructUp) + 90) % 360\nPHYSICS.currentRollDeg
        = getRoll(PHYSICS.worldVertical, PHYSICS.constructForward, PHYSICS.constructRight)\nPHYSICS.currentYawDeg
        = getRoll(PHYSICS.worldVertical, PHYSICS.constructUp, PHYSICS.constructForward)\nPHYSICS.atmosphereDensity
        = unit.getAtmosphereDensity()\nPHYSICS.inAtmo = PHYSICS.worldVertical:len()
        > 0.01 and PHYSICS.atmosphereDensity > 0.0\nPHYSICS.brakeDistance, PHYSICS.brakeTime
        = Kinematic.computeDistanceAndTime(\nPHYSICS.constructVelocitySpeed, -- current
        speed\n0, -- end speed\nPHYSICS.constructMass,\n0, -- Forward force for turn
        and  burn, we don't bother\n0, -- Warmup time for turn and burn\nPHYSICS.maxBrakeForce)
        -- TODO: Include gravity?\nend\nfunction PHYSICS.getRotationDiff(targetRotation,
        currentRotation)\n-- if targetrotation = 0 and currentRotation = 270, then
        diff should be -90,\n-- not 270.\n-- target: 90. current: 120. Should return
        \ -30\n-- target: 0. current: 270 . Should return 90\nlocal targetDiff = (targetRotation
        - currentRotation) % 360\nif targetDiff > 180.0 then\ntargetDiff = -(360 -
        targetDiff)\nelseif targetDiff < -180.0 then\ntargetDiff = -(360 + targetDiff)\nend\nreturn
        targetDiff\nend\nfunction PHYSICS.getRotationCorrection(targetRotation, currentRotation)\nlocal
        targetDiff = PHYSICS.getRotationDiff(targetRotation, currentRotation)\n--
        targetDiff is >= -180 <= 180\n-- If abs() < 10, then return 0.5, otherwise
        1.0\nlocal mul = targetDiff > 0 and 1.0 or -1.0\nif math.abs(targetDiff) <
        0.1 then\nreturn 0.0\nelseif math.abs(targetDiff) < 10 then\nreturn mul *
        0.1\nelseif math.abs(targetDiff) < 45 then\nreturn mul * 0.5\nelse\nreturn
        mul\nend\nend\n-- Rotation\nfunction PHYSICS.setRotationVelocity(angularVelocity,
        torqueFactor)\nlocal angularAcceleration = torqueFactor * (angularVelocity
        - PHYSICS.constructAngularVelocity)\nangularAcceleration = angularAcceleration
        - PHYSICS.airAngularFriction -- Try to compensate air friction\nunit.setEngineCommand(\"torque\",
        {vec3(0.0, 0.0, 0.0):unpack()}, {angularAcceleration:unpack()}, 1, 0, \"\",
        \"\", \"\", 0)\nend\nfunction PHYSICS.setShipRotation(pitch, roll, yaw)\nlocal
        target = -pitch * PHYSICS.constructRight + roll * PHYSICS.constructForward
        + yaw * PHYSICS.constructUp\nPHYSICS.setRotationVelocity(target, 2.0)\nend\nlocal
        SHIP = {}\nSHIP.plan = {\nthrottle = 0.0,\nthrottleLateral = 0.0,\nthrottleVertical
        = 0.0,\npitch = 0.0,\nroll = 0.0,\nyaw = 0.0,\nbrake = 0.0,\nbooster = false,\nhoverAt
        = 4.0\n}\nSHIP.pids = {}\nSHIP.LONGITUDINAL = 0\nSHIP.LATERAL = 1\nSHIP.VERTICAL
        = 2\nSHIP.TORQUE = 2.0\nSHIP.setVectorThrust = function(throttle, tags, kinematicdirection,
        thrustdirection)\nlocal thrust = PHYSICS.nullvec\nif math.abs(throttle) >
        0.01 then\nlocal maxThrust = core.getMaxKinematicsParametersAlongAxis(tags,
        {kinematicdirection:unpack()})\nlocal speedF, speedB, spaceF, spaceB = table.unpack(maxThrust)\nif
        not PHYSICS.inAtmo then\nspeedF, speedB = spaceF, spaceB\nend\nlocal speed
        = speedF\nif throttle < 0 then\nspeed = speedB\nend\nthrust = thrustdirection
        * speed * math.abs(throttle)\nend\nunit.setEngineCommand(tags, {thrust:unpack()},
        {PHYSICS.nullvec:unpack()}, true, false, \"\", \"\", \"\", 0)\nend\nSHIP.update
        = function()\nunit.setAxisCommandValue(SHIP.LONGITUDINAL, SHIP.plan.throttle)\nunit.setAxisCommandValue(SHIP.LATERAL,
        SHIP.plan.throttleLateral)\nunit.setAxisCommandValue(SHIP.VERTICAL, SHIP.plan.throttleVertical)\nend\nSHIP.flush
        = function()\nSHIP.setVectorThrust(\nSHIP.plan.throttle,\n\"thrust analog
        longitudinal\",\nPHYSICS.constructLocalForward,\nPHYSICS.constructForward\n)\nSHIP.setVectorThrust(\nSHIP.plan.throttleLateral,\n\"thrust
        analog lateral\",\nPHYSICS.constructLocalRight,\nPHYSICS.constructRight\n)\nSHIP.setVectorThrust(\nSHIP.plan.throttleVertical,\n\"thrust
        analog vertical\",\nPHYSICS.constructLocalUp,\nPHYSICS.constructUp\n)\nlocal
        desiredAngularVelocity =\nSHIP.plan.pitch * PHYSICS.constructRight + SHIP.plan.roll
        * PHYSICS.constructForward +\nSHIP.plan.yaw * PHYSICS.constructUp\nPHYSICS.setRotationVelocity(desiredAngularVelocity,
        SHIP.TORQUE)\nunit.setEngineThrust(\"brake\", SHIP.plan.brake * PHYSICS.maxBrakeForce)\nif
        SHIP.plan.booster then\n-- Any non-zero value, really.\nunit.setEngineThrust(\"booster\",
        100.0)\nelse\nunit.setEngineThrust(\"booster\", 0.0)\nend\nif SHIP.plan.hoverAt
        > 0.0 then\nunit.activateGroundEngineAltitudeStabilization(SHIP.plan.hoverAt)\nelse\nunit.deactivateGroundEngineAltitudeStabilization()\nend\nend\nSHIP.unhover
        = function()\nSHIP.plan.hoverAt = -1.0\nend\nSHIP.hover = function(amt)\namt
        = amt or 10.0\nSHIP.plan.hoverAt = amt\nend\nSHIP.reset = function()\nunit.setupAxisCommandProperties(0,
        0)\nSHIP.plan = {\nthrottle = 0.0,\nthrottleLateral = 0.0,\nthrottleVertical
        = 0.0,\npitch = 0.0,\nroll = 0.0,\nyaw = 0.0,\nbrake = 0.0,\nbooster = false,\nhoverAt
        = 20.0\n}\nSHIP.pids = {}\nend\nSHIP.killEngines = function()\nSHIP.plan.throttle
        = 0.0\nSHIP.plan.throttleLateral = 0.0\nSHIP.plan.throttleVertical = 0.0\nSHIP.plan.pitch
        = 0.0\nSHIP.plan.roll = 0.0\nSHIP.plan.yaw = 0.0\nSHIP.plan.booster = false\nend\nSHIP.spin
        = function(pitch, roll, yaw)\nSHIP.plan.pitch = pitch\nSHIP.plan.roll = roll\nSHIP.plan.yaw
        = yaw\nend\nSHIP.rotateTo = function(pitch, roll)\n-- rotateTo is atmo-only.
        Yaw has no meaning in atmo.\nif pitch == nil then\npitch = PHYSICS.currentPitchDeg\nend\nif
        roll == nil then\nroll = PHYSICS.currentRollDeg\nend\npitch = SHIP.pidRotate('pitch',
        pitch, PHYSICS.currentPitchDeg)\nroll = SHIP.pidRotate('roll', roll, PHYSICS.currentRollDeg)\nSHIP.spin(pitch,
        roll, 0.0)\nend\nSHIP.throttleTo = function(amt)\nSHIP.plan.throttle = utils.clamp(amt,
        -1.0, 1.0)\nend\nSHIP.extendLandingGears = function()\nunit.extendLandingGears()\nend\nSHIP.retractLandingGears
        = function()\nunit.retractLandingGears()\nend\nSHIP.pid = function(name, val)\nif
        not SHIP.pids[name] then\nSHIP.pids[name] = pid.new(0.01, 0, 0.2)\nend\nSHIP.pids[name]:inject(val)\nlocal
        ret = SHIP.pids[name]:get()\nreturn ret\nend\nSHIP.pidRotate = function(name,
        val, target)\nlocal diff = PHYSICS.getRotationDiff(val, target)\nreturn SHIP.pid(name,
        diff)\nend\nSHIP.turnToSpaceVector = function(vec)\nlocal phead = PHYSICS.getRotationDiff(getRoll(vec,
        PHYSICS.constructRight, PHYSICS.constructUp), 180)\nlocal yhead = getRoll(vec,
        PHYSICS.constructUp, PHYSICS.constructRight)\n-- phead and yhead are the difference
        between vec and current construct facing\n-- So we need to invert them for
        the pid()\nlocal pvec = SHIP.pid('spacepitch', -phead)\nlocal yvec = SHIP.pid('spaceyaw',
        -yhead)\n-- Roll doesn't matter\nSHIP.spin(pvec, 0.0, yvec)\nend\nSHIP.turnToHeadingAtmo
        = function(pitch, heading)\nlocal targetYaw = nil\nlocal roll = 0\nif math.abs(heading)
        > 90 then\ntargetYaw = 0.5\nroll = 20\nelseif math.abs(heading) > 15 then\ntargetYaw
        = 0.2\nroll = 10\nelseif math.abs(heading) > 5 then\ntargetYaw = math.abs(heading)
        / 100\nroll = 5\nelseif math.abs(heading) > 0.01 then\ntargetYaw = math.abs(heading)
        / 100\nroll = 0\nelse\ntargetYaw = 0.0\nroll = 0.0\nend\nif heading > 0 then\ntargetYaw
        = -targetYaw\nelse\nroll = -roll\nend\nlocal pvel = SHIP.pidRotate('headingpitch',
        pitch, PHYSICS.currentPitchDeg)\nlocal rvel = SHIP.pidRotate('headingroll',
        roll, PHYSICS.currentRollDeg)\nlocal yvel = targetYaw\nSHIP.spin(pvel, rvel,
        yvel)\nend\nSHIP.stabilize = function()\nSHIP.rotateTo(0.0, 0.0, nil)\nend\nSHIP.brake
        = function(amt)\nSHIP.plan.brake = amt or 1.0\nend\n-- Dealing with Dual Universe's
        planetary and moon bodies,\n-- Gravity, Locations, Bookmark styles, etc\nlocal
        DU = {}\nfunction DU.getNearestBody(loc)\n-- Far planet for \"default\"\nlocal
        nearest = DU.BODIES[4]\nlocal ndist = (loc - nearest.center):len()\nfor id,
        body in pairs(DU.BODIES) do\nlocal bdist = (loc - body.center):len()\nif bdist
        < ndist then\nndist = bdist\nnearest = body\nend\nend\nreturn nearest\nend\nfunction
        DU.distanceFromSurface(loc, body)\nreturn (loc - body.center):len() - body.radius\nend\n--
        Taken from: https://github.com/Dimencia/DU-Orbital-Hud/blob/master/ButtonHUD.conf\n--
        Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom
        with minor modifications\nDU.BODIES = {\n[1] = {\nGM = 6930729684,\nbodyId
        = 1,\ncenter = vec3({x = 17465536.000, y = 22665536.000, z = -34464.000}),\nname
        = \"Madis\",\nplanetarySystemId = 0,\nradius = 44300\n},\n[2] = {\nGM = 157470826617,\nbodyId
        = 2,\ncenter = vec3({x = -8.000, y = -8.000, z = -126303.000}),\nname = \"Alioth\",\nplanetarySystemId
        = 0,\nradius = 126068\n},\n[3] = {\nGM = 11776905000,\nbodyId = 3,\ncenter
        = vec3({x = 29165536.000, y = 10865536.000, z = 65536.000}),\nname = \"Thades\",\nplanetarySystemId
        = 0,\nradius = 49000\n},\n[4] = {\nGM = 14893847582,\nbodyId = 4,\ncenter
        = vec3({x = -13234464.000, y = 55765536.000, z = 465536.000}),\nname = \"Talemai\",\nplanetarySystemId
        = 0,\nradius = 57450\n},\n[5] = {\nGM = 16951680000,\nbodyId = 5,\ncenter
        = vec3({x = -43534464.000, y = 22565536.000, z = -48934464.000}),\nname =
        \"Feli\",\nplanetarySystemId = 0,\nradius = 60000\n},\n[6] = {\nGM = 10502547741,\nbodyId
        = 6,\ncenter = vec3({x = 52765536.000, y = 27165538.000, z = 52065535.000}),\nname
        = \"Sicari\",\nplanetarySystemId = 0,\nradius = 51100\n},\n[7] = {\nGM = 13033380591,\nbodyId
        = 7,\ncenter = vec3({x = 58665538.000, y = 29665535.000, z = 58165535.000}),\nname
        = \"Sinnen\",\nplanetarySystemId = 0,\nradius = 54950\n},\n[8] = {\nGM = 18477723600,\nbodyId
        = 8,\ncenter = vec3({x = 80865538.000, y = 54665536.000, z = -934463.940}),\nname
        = \"Teoma\",\nplanetarySystemId = 0,\nradius = 62000\n},\n[9] = {\nGM = 18606274330,\nbodyId
        = 9,\ncenter = vec3({x = -94134462.000, y = 12765534.000, z = -3634464.000}),\nname
        = \"Jago\",\nplanetarySystemId = 0,\nradius = 61590\n},\n[10] = {\nGM = 78480000,\nbodyId
        = 10,\ncenter = vec3({x = 17448118.224, y = 22966846.286, z = 143078.820}),\nname
        = \"Madis Moon 1\",\nplanetarySystemId = 0,\nradius = 10000\n},\n[11] = {\nGM
        = 237402000,\nbodyId = 11,\ncenter = vec3({x = 17194626.000, y = 22243633.880,
        z = -214962.810}),\nname = \"Madis Moon 2\",\nplanetarySystemId = 0,\nradius
        = 11000\n},\n[12] = {\nGM = 265046609,\nbodyId = 12,\ncenter = vec3({x = 17520614.000,
        y = 22184730.000, z = -309989.990}),\nname = \"Madis Moon 3\",\nplanetarySystemId
        = 0,\nradius = 15005\n},\n[21] = {\nGM = 2118960000,\nbodyId = 21,\ncenter
        = vec3({x = 457933.000, y = -1509011.000, z = 115524.000}),\nname = \"Alioth
        Moon 1\",\nplanetarySystemId = 0,\nradius = 30000\n},\n[22] = {\nGM = 2165833514,\nbodyId
        = 22,\ncenter = vec3({x = -1692694.000, y = 729681.000, z = -411464.000}),\nname
        = \"Alioth Moon 4\",\nplanetarySystemId = 0,\nradius = 30330\n},\n[26] = {\nGM
        = 68234043600,\nbodyId = 26,\ncenter = vec3({x = -1404835.000, y = 562655.000,
        z = -285074.000}),\nname = \"Sanctuary\",\nplanetarySystemId = 0,\nradius
        = 83400\n},\n[30] = {\nGM = 211564034,\nbodyId = 30,\ncenter = vec3({x = 29214402.000,
        y = 10907080.695, z = 433858.200}),\nname = \"Thades Moon 1\",\nplanetarySystemId
        = 0,\nradius = 14002\n},\n[31] = {\nGM = 264870000,\nbodyId = 31,\ncenter
        = vec3({x = 29404193.000, y = 10432768.000, z = 19554.131}),\nname = \"Thades
        Moon 2\",\nplanetarySystemId = 0,\nradius = 15000\n},\n[40] = {\nGM = 141264000,\nbodyId
        = 40,\ncenter = vec3({x = -13503090.000, y = 55594325.000, z = 769838.640}),\nname
        = \"Talemai Moon 2\",\nplanetarySystemId = 0,\nradius = 12000\n},\n[41] =
        {\nGM = 106830900,\nbodyId = 41,\ncenter = vec3({x = -12800515.000, y = 55700259.000,
        z = 325207.840}),\nname = \"Talemai Moon 3\",\nplanetarySystemId = 0,\nradius
        = 11000\n},\n[42] = {\nGM = 264870000,\nbodyId = 42,\ncenter = vec3({x = -13058408.000,
        y = 55781856.000, z = 740177.760}),\nname = \"Talemai Moon 1\",\nplanetarySystemId
        = 0,\nradius = 15000\n},\n[50] = {\nGM = 499917600,\nbodyId = 50,\ncenter
        = vec3({x = -43902841.780, y = 22261034.700, z = -48862386.000}),\nname =
        \"Feli Moon 1\",\nplanetarySystemId = 0,\nradius = 14000\n},\n[70] = {\nGM
        = 396912600,\nbodyId = 70,\ncenter = vec3({x = 58969616.000, y = 29797945.000,
        z = 57969449.000}),\nname = \"Sinnen Moon 1\",\nplanetarySystemId = 0,\nradius
        = 17000\n},\n[100] = {\nGM = 13975172474,\nbodyId = 100,\ncenter = vec3({x
        = 98865536.000, y = -13534464.000, z = -934461.990}),\nname = \"Lacobus\",\nplanetarySystemId
        = 0,\nradius = 55650\n},\n[101] = {\nGM = 264870000,\nbodyId = 101,\ncenter
        = vec3({x = 98905288.170, y = -13950921.100, z = -647589.530}),\nname = \"Lacobus
        Moon 3\",\nplanetarySystemId = 0,\nradius = 15000\n},\n[102] = {\nGM = 444981600,\nbodyId
        = 102,\ncenter = vec3({x = 99180968.000, y = -13783862.000, z = -926156.400}),\nname
        = \"Lacobus Moon 1\",\nplanetarySystemId = 0,\nradius = 18000\n},\n[103] =
        {\nGM = 211503600,\nbodyId = 103,\ncenter = vec3({x = 99250052.000, y = -13629215.000,
        z = -1059341.400}),\nname = \"Lacobus Moon 2\",\nplanetarySystemId = 0,\nradius
        = 14000\n},\n[110] = {\nGM = 9204742375,\nbodyId = 110,\ncenter = vec3({x
        = 14165536.000, y = -85634465.000, z = -934464.300}),\nname = \"Symeon\",\nplanetarySystemId
        = 0,\nradius = 49050\n},\n[120] = {\nGM = 7135606629,\nbodyId = 120,\ncenter
        = vec3({x = 2865536.700, y = -99034464.000, z = -934462.020}),\nname = \"Ion\",\nplanetarySystemId
        = 0,\nradius = 44950\n},\n[121] = {\nGM = 106830900,\nbodyId = 121,\ncenter
        = vec3({x = 2472916.800, y = -99133747.000, z = -1133582.800}),\nname = \"Ion
        Moon 1\",\nplanetarySystemId = 0,\nradius = 11000\n},\n[122] = {\nGM = 176580000,\nbodyId
        = 122,\ncenter = vec3({x = 2995424.500, y = -99275010.000, z = -1378480.700}),\nname
        = \"Ion Moon 2\",\nplanetarySystemId = 0,\nradius = 15000\n}\n}\n-- Flying
        Engine Selection screen. The first tab of main screen.\n-- This is loaded
        fairly early on, so ShipEngine instances can\n-- register themselves with
        CommandSelection.\nlocal CommandSelect = {\nname = \"Engine\",\nENGINES =
        {},\nENGINES_NAME = {},\nChoice = 1\n}\nCommandSelect.add = function(cmd,
        hide)\nif not hide then\ntable.insert(CommandSelect.ENGINES, cmd)\nend\nCommandSelect.ENGINES_NAME[cmd.name]
        = cmd\nend\nCommandSelect.Style =\nel(\n\"style\",\n[[\n.enginetabs { position:
        fixed; display: block; left: 20vw; top: 35vh; }\n.estab { display: block;
        width: 15vw; height: 4vh; margin: 0; padding: 5px; background-color: grey;
        font-size: 1.5vh; color: white; }\n.essel { background-color: yellow; color:
        black; }\n.esdesc { position: fixed; display: block; left: 35vw; top: 35vh;
        background-color: #666666cc; padding: 1em; width: 30vw; height: 30vh; font-size:
        2vh; }\n]]\n)\nCommandSelect.onFORWARD = function()\nCommandSelect.Choice
        = CommandSelect.Choice - 1\nif CommandSelect.Choice < 1 then\nCommandSelect.Choice
        = #CommandSelect.ENGINES\nend\nend\nCommandSelect.onBACKWARD = function()\nCommandSelect.Choice
        = CommandSelect.Choice + 1\nif CommandSelect.Choice > #CommandSelect.ENGINES
        then\nCommandSelect.Choice = 1\nend\nend\nCommandSelect.onUP = function()\nlocal
        choice = CommandSelect.ENGINES[CommandSelect.Choice]\nsystem.print(\"selecting
        engine\")\nif choice.isEngine then\nsetEngineControl(choice)\nelse\nsetEngineCommand(choice)\nend\nMainScreen.setControl()\nend\nCommandSelect.render
        = function()\nlocal tabs = {}\nlocal chosen = nil\nfor i, engine in ipairs(CommandSelect.ENGINES)
        do\nlocal cls = \"estab\"\nif i == CommandSelect.Choice then\ncls = \"estab
        essel\"\nchosen = engine\nend\ntable.insert(tabs, el(\"div\", {class = cls},
        engine.name))\nend\nreturn CommandSelect.Style .. el(\"div\", {class = \"enginetabs\"},
        tabs) .. el(\"div\", {class = \"esdesc\"}, chosen.desc)\nend\nlocal EC_LAND
        = {\nname = \"Land Ship\",\ndesc = [[\n1) Shut off all thrust engines. Turn
        on all brakes.<br>\n2) Stabilize pitch and Roll to 0.<br>\n3) Extend landing
        gears.<br>\n4) Lower Altitude Stabilization to zero.<br>\n5) Shut down altitude
        stabilizers.\n]],\noverride = false\n}\nEC_LAND.start = function()\n-- BRAKE
        ALL THE THINGS, but only if speed is low. If we are going fast, we\n-- may
        be coasting.\nEC_LAND.stage = \"stabilize\"\nSHIP.killEngines()\nend\nEC_LAND.resume
        = function()\nEC_LAND.stage = \"done\"\nSHIP.unhover()\nend\nEC_LAND.stop
        = function()\nend\nEC_LAND.flush = function(secs)\nif EC_LAND.stage ~= \"done\"
        then\nSHIP.stabilize()\nelse\nSHIP.killEngines()\nSHIP.unhover()\nend\nif
        math.abs(PHYSICS.constructVelocitySpeed) > 0.2 then\nSHIP.brake()\nend\nif
        EC_LAND.stage == \"stabilize\" then\nif\nmath.abs(PHYSICS.getRotationDiff(PHYSICS.currentPitchDeg,
        0)) < 2.0 and\nmath.abs(PHYSICS.getRotationDiff(PHYSICS.currentRollDeg, 0))
        < 2.0\nthen\nSHIP.extendLandingGears()\nEC_LAND.stage = \"extend\"\nEC_LAND.timer
        = 0.0\nend\nend\nif EC_LAND.stage == \"extend\" then\nEC_LAND.timer = EC_LAND.timer
        + secs\nif EC_LAND.timer > 3.0 then\nsystem.print(\"extended\")\nEC_LAND.stage
        = \"lower\"\nEC_LAND.timer = 0\nSHIP.hover(1.0)\nend\nend\nif EC_LAND.stage
        == \"lower\" then\nif math.abs(PHYSICS.constructVelocitySpeed) < 0.4 then\nsystem.print(\"lowered,
        finished\")\nEC_LAND.stage = \"done\"\nSHIP.killEngines()\nSHIP.unhover()\nclearEngineCommand()\nend\nend\nend\nCommandSelect.add(EC_LAND)\nlocal
        EC_HOVER = {\nname = \"Hover\",\ndesc = [[\n1) Engage all brakes\n2) Set hover
        to 30 meters\n3) Rotate to be as flat as possible\n]],\noverride = false,\nruntime
        = 0.0\n}\nEC_HOVER.start = function()\n-- BRAKE ALL THE THINGS, but only if
        speed is low. If we are going fast, we\n-- may be coasting.\nSHIP.retractLandingGears()\nEC_HOVER.runtime
        = 0.0\nend\nEC_HOVER.resume = EC_HOVER.start\nEC_HOVER.stop = function()\nend\nEC_HOVER.flush
        = function(secs)\nEC_HOVER.runtime = EC_HOVER.runtime + secs\nSHIP.stabilize()\nSHIP.brake()\nSHIP.hover(30)\nif
        EC_HOVER.runtime > 3.0 and math.abs(PHYSICS.constructVelocitySpeed) < 0.2
        then\nclearEngineCommand()\nend\nend\nCommandSelect.add(EC_HOVER)\nlocal AP_DESCENT_THROTTLE
        = 0.2 --export: Throttle % to use on descent / approach\nlocal AP_DESCENT_DISTANCE
        = 2200 --export: How far away from destination to start descending\nlocal
        AP_CRUISE_ALTITUDE = 800 --export: How high above target altitude to cruise?\nlocal
        AP_CLIMB_PITCH = 15 --export: In degrees, how high to aim the ship during
        initial, full power climb.\nlocal AP_CRUISE_PITCH = 6.0 --export: Pitch to
        cruise at. If you're bouncing up and down, adjust this.\nlocal AP_ESCAPE_PITCH
        = 15.0 --export: Pitch to climb out of atmosphere with.\nlocal EC_AUTOPILOT
        = {\nname = 'Autopilot',\ndesc = [[\nEngage autopilot. Destination: (Select
        destination from autopilot menu)\n]],\ndesctemplate = [[\nEngage autopilot.
        Destination: %s.\n]],\noverride = false,\ncallbacks = {},\nlast_announcement
        = nil,\ntime = 0.0,\narrived = false,\n}\nEC_AUTOPILOT.start = function()\nEC_AUTOPILOT.time
        = 0.0\nEC_AUTOPILOT.arrived = false\nEC_AUTOPILOT.announcements = {}\nEC_AUTOPILOT.recalculate()\nEC_AUTOPILOT.log
        = {}\nend\nEC_AUTOPILOT.announce = function(msg)\nif EC_AUTOPILOT.last_announcement
        == msg then return end\nEC_AUTOPILOT.last_announcement = msg\nsystem.print(\"ANNOUNCEMENT:
        \" .. msg)\nend\nEC_AUTOPILOT.resume = EC_AUTOPILOT.start\nEC_AUTOPILOT.stop
        = function()\nEC_AUTOPILOT.log = {}\nend\n-- This is called twice a second\nEC_AUTOPILOT.recalculate
        = function()\nif not databank.hasKey('destination') then return end\nEC_AUTOPILOT.callbacks
        = {}\n-- This is the meat of autopilot.\n-- To start: discover our position
        relative to destination, our status\n--    (in atmo safe, in space safe, in
        space approaching, in atmo approaching)\n-- Then, determine which do we want
        to do:\n--     - Brake and stop if we are close enough\n--     - Determine
        if we are in-atmosphere or not\n--     - Near, in atmo: Cross-planetary plotting\n--
        \    - Destination extraplanetary, in atmo: Take off.\n--     - Approaching
        planet from space? YIKES.\n--         - Be very conservative when approaching
        a space destination.\n--     - In space: Determine: speed up or slow down,
        and in which angle\nlocal destination = MainScreen.destination\nif not (destination
        and destination.name) then\nclearEngineCommand()\nreturn\nend\nlocal dpos
        = vec3(destination.position)\nlocal mypos = vec3(core.getConstructWorldPos())\nlocal
        vdiff = dpos - mypos\nlocal vdirection = vdiff:normalize()\nlocal dist = vdiff:len()\nlocal
        inatmo = PHYSICS.inAtmo\nlocal cbs = EC_AUTOPILOT.callbacks\n-- vdiff also
        defines what vector we want to aim at.\n-- If we're in atmo, though, we only
        want the yaw heading.\nlocal yaw_heading = getRoll(vdiff, PHYSICS.constructUp,
        PHYSICS.constructRight)\nlocal altDiff = PHYSICS.altitude - destination.altitude\nlocal
        mybody = DU.getNearestBody(PHYSICS.position)\nlocal dbody = DU.getNearestBody(vec3(destination.position))\nlocal
        samebody = mybody.id == dbody.id\nlocal saltitude = DU.distanceFromSurface(PHYSICS.position,
        dbody)\nlocal daltitude = DU.distanceFromSurface(vec3(destination.position),
        dbody)\nSHIP.retractLandingGears()\n-- I think there's no planets more than
        1.5 SU wide, and there's no\nif saltitude < 10000 and daltitude < 10000 and
        samebody then\nlocal flatdist = math.sqrt(dist*dist - altDiff*altDiff)\nlocal
        desiredAltitude = 0.0\n-- Still experimenting between speed and throttle\nlocal
        desiredSpeed = 0.0\nlocal desiredThrottle = 0.0\nif EC_AUTOPILOT.arrived and
        PHYSICS.currentSpeed < 1.0 then\nif altDiff < 15.0 then\ntable.insert(cbs,
        {clearEngineCommand})\ntable.insert(cbs, {clearDestination})\ntable.insert(cbs,
        {setEngineCommand, EC_LAND})\nelse\n-- Unbrake so we fall down. \ntable.insert(cbs,
        {SHIP.stabilize})\ntable.insert(cbs, {SHIP.brake, 0.0})\ntable.insert(cbs,
        {SHIP.hover, 10})\nend\nelseif EC_AUTOPILOT.arrived or flatdist < 30.0 then\nEC_AUTOPILOT.arrived
        = true\ntable.insert(cbs, {SHIP.stabilize})\ntable.insert(cbs, {SHIP.throttleTo,
        0.0})\ntable.insert(cbs, {SHIP.killEngines})\ntable.insert(cbs, {SHIP.brake,
        1.0})\ntable.insert(cbs, {SHIP.hover, 10})\nreturn\nelseif flatdist < AP_DESCENT_DISTANCE
        then\ndesiredThrottle = AP_DESCENT_THROTTLE\ndesiredSpeed = 20.0\nlocal fact
        = flatdist / AP_DESCENT_DISTANCE\ndesiredAltitude = destination.altitude +
        AP_CRUISE_ALTITUDE * (fact * fact)\nelse\ndesiredThrottle = 1.0\ndesiredAltitude
        = destination.altitude + AP_CRUISE_ALTITUDE\ndesiredSpeed = 1000.0\nend\nlocal
        vertdiff = desiredAltitude - PHYSICS.altitude\nlocal pitch = 0.0\nlocal brakeTo
        = 0.0\nif PHYSICS.currentSpeed - desiredSpeed > 60 then\nbrakeTo = 1.0\nelseif
        PHYSICS.currentSpeed - desiredSpeed > 10 then\nbrakeTo = 0.2\nelse\nbrakeTo
        = 0.0\nend\nif vertdiff > 50 then\npitch = AP_CLIMB_PITCH\nelseif vertdiff
        > -20 then\npitch = AP_CRUISE_PITCH\nelseif vertdiff > -60 then\npitch = -5.0\nelse\npitch
        = -15.0\nend\ndesiredThrottle = utils.clamp(desiredThrottle, 0.0, 1.0)\n--
        At a very high distance (on other side of planet), yaw heading gets confused
        easily.\nif dist > 30000 and math.abs(yaw_heading) < 5 then\nyaw_heading =
        0\nend\n-- Cross-planetary travel\ntable.insert(cbs, {SHIP.turnToHeadingAtmo,
        pitch, yaw_heading})\ntable.insert(cbs, {SHIP.hover, 30})\ntable.insert(cbs,
        {SHIP.throttleTo, desiredThrottle})\ntable.insert(cbs, {SHIP.brake, brakeTo})\nelseif
        inatmo then\n-- If we are here, we have to take off. Destination is either
        in space, or\n-- on another body.\ntable.insert(cbs, {SHIP.throttleTo, 1.0})\ntable.insert(cbs,
        {SHIP.brake, 0.0})\nif EC_AUTOPILOT.time < 40 then\ntable.insert(cbs, {SHIP.turnToHeadingAtmo,
        AP_CLIMB_PITCH, yaw_heading})\nEC_AUTOPILOT.announce(\"Begin takeoff\")\nelseif
        PHYSICS.altitude < 3000 then\n-- TODO: Depend on body gravity+density+etc?\nSHIP.rotateTo(AP_CLIMB_PITCH,
        0.0, nil)\nEC_AUTOPILOT.announce(\"Climb to escape\")\nelse\nSHIP.rotateTo(AP_ESCAPE_PITCH,
        0.0, nil)\nEC_AUTOPILOT.announce(\"Attempting to escape atmo\")\nend\nelseif
        PHYSICS.altitude < 30000 and not samebody then\nEC_AUTOPILOT.announce(\"Out
        of atmosphere, attempting to escape\")\n-- Continue to try escaping our planet.\nif
        inatmo then\ntable.insert(cbs, {SHIP.turnToHeadingAtmo, AP_CLIMB_PITCH, yaw_heading})\nelse\ntable.insert(cbs,
        {SHIP.turnToSpaceVector, vdirection})\nend\ntable.insert(cbs, {SHIP.throttleTo,
        1.0})\ntable.insert(cbs, {SHIP.brake, 0.0})\nelse\n-- TODO: Raycast and determine
        if any of the bodies are in the way\nlocal stopIn = dist\nlocal desiredBrake
        = 0.0\nif saltitude < stopIn then stopIn = saltitude end\nstopIn = stopIn
        - 10000 -- Atmosphere\nEC_AUTOPILOT.announce(\"Performing space approach\")\nlocal
        brakedist = PHYSICS.brakeDistance * 1.5 -- Padding for Gravity until I can
        account for it\nif (PHYSICS.currentSpeed > 270.0 and stopIn <= brakedist)
        or\n(SHIP.plan.brake == 1.0 and stopIn < (brakedist * 1.2)) then\n-- 277 m/s
        is just under 1000 km/h, which is the damage point for\n-- entering atmosphere.\ndesiredBrake
        = 1.0\ntable.insert(cbs, {SHIP.brake, 1.0})\ntable.insert(cbs, {SHIP.throttleTo,
        0.0})\nelseif brakedist < (stopIn * 0.75) then\ntable.insert(cbs, {SHIP.brake,
        0.0})\ntable.insert(cbs, {SHIP.throttleTo, 1.0})\nelse\ntable.insert(cbs,
        {SHIP.throttleTo, 0.0})\nend\n-- Attempt to correct for drift\nlocal vfix
        = vdirection - PHYSICS.constructVelocityDir\nlocal vgo = (vdirection + vfix):normalize()\nlocal
        vfl = vfix:len()\nif PHYSICS.constructVelocitySpeed > 100 then\nif vfix:len()
        > 1.0 then\n-- Massive course correction required\ndesiredBrake = 1.0\nelseif
        vfix:len() > 0.25 then\nvgo = vfix\nelseif vfix:len() > 0.05 then\nvgo = (vdirection
        * 2.0 + vfix):normalize()\nend\nend\ntable.insert(cbs, {SHIP.turnToSpaceVector,
        vgo})\ntable.insert(cbs, {SHIP.brake, desiredBrake})\nend\nend\nEC_AUTOPILOT.update
        = function(secs)\nlocal now = EC_AUTOPILOT.time + secs\n-- To save processing
        time, we recalculate only twice a second.\nif math.floor(EC_AUTOPILOT.time
        * 2) ~= math.floor(now * 2) then\nEC_AUTOPILOT.recalculate()\nend\nEC_AUTOPILOT.time
        = now\nend\nEC_AUTOPILOT.flush = function(secs)\nfor i, cbs in ipairs(EC_AUTOPILOT.callbacks)
        do\nlocal cb = cbs[1]\ncb(table.unpack(cbs, 2, #cbs))\nend\nend\nCommandSelect.add(EC_AUTOPILOT)\nlocal
        ENGINE_SHIP = {\nname = \"Control engine using the SHIP shiplib\",\ndesc =
        [[Pretty much the same as default, but clearer in code for me.]],\nisEngine
        = true\n}\nfunction ENGINE_SHIP.start()\nsystem.print(\"Setting throttle info\")\nSHIP.reset()\nend\nfunction
        ENGINE_SHIP.onSTOPENGINES()\nSHIP.killEngines()\nend\nfunction ENGINE_SHIP.onBOOSTER()\nSHIP.plan.booster
        = not SHIP.plan.booster\nend\nfunction ENGINE_SHIP.startSPEEDDOWN()\nENGINE_SHIP.alterSpeed(-0.1)\nend\nfunction
        ENGINE_SHIP.startSPEEDUP()\nENGINE_SHIP.alterSpeed(0.1)\nend\nfunction ENGINE_SHIP.alterSpeed(amt)\nlocal
        cur = SHIP.plan.throttle + amt\nif cur > 1.0 then\ncur = 1.0\nend\nif cur
        < -1.0 then\ncur = -1.0\nend\nSHIP.plan.throttle = cur\nend\nfunction ENGINE_SHIP.update(secs)\nlocal
        amt = system.getThrottleInputFromMouseWheel()\nif math.abs(amt) > 0.01 then\nENGINE_SHIP.alterSpeed(0.1
        * amt)\nend\nend\nfunction ENGINE_SHIP.onLIGHT()\nif unit.isAnyHeadlightSwitchedOn()
        == 1 then\nunit.switchOffHeadlights()\nelse\nunit.switchOnHeadlights()\nend\nend\nfunction
        ENGINE_SHIP.startGROUNDALTITUDEUP()\nSHIP.plan.hoverAt = SHIP.plan.hoverAt
        + 1.0\nif SHIP.plan.hoverAt > 50.0 then\nSHIP.plan.hoverAt = 50.0\nend\nend\nfunction
        ENGINE_SHIP.loopGROUNDALTITUDEUP()\nSHIP.plan.hoverAt = SHIP.plan.hoverAt
        + 1.0\nif SHIP.plan.hoverAt > 50.0 then\nSHIP.plan.hoverAt = 50.0\nend\nend\nfunction
        ENGINE_SHIP.startGROUNDALTITUDEDOWN()\nSHIP.plan.hoverAt = SHIP.plan.hoverAt
        - 1.0\nif SHIP.plan.hoverAt < 1.0 then\nSHIP.plan.hoverAt = 1.0\nend\nend\nfunction
        ENGINE_SHIP.loopGROUNDALTITUDEDOWN()\nSHIP.plan.hoverAt = SHIP.plan.hoverAt
        - 1.0\nif SHIP.plan.hoverAt < 1.0 then\nSHIP.plan.hoverAt = 1.0\nend\nend\nfunction
        ENGINE_SHIP.onWARP()\nif warpdrive ~= nil then\nwarpdrive.activateWarp()\nend\nend\nfunction
        ENGINE_SHIP.onANTIGRAVITY()\nif antigrav ~= nil then\nantigrav.toggle()\nend\nend\nfunction
        ENGINE_SHIP.flush(secs)\n-- OVERRIDE by shipos\nlocal pitchInput = PHYSICS.keyState(\"BACKWARD\")
        - PHYSICS.keyState(\"FORWARD\")\nlocal rollInput = PHYSICS.keyState(\"RIGHT\")
        - PHYSICS.keyState(\"LEFT\")\nlocal yawInput = PHYSICS.keyState(\"YAWLEFT\")
        - PHYSICS.keyState(\"YAWRIGHT\")\nSHIP.plan.throttleLateral = PHYSICS.keyState(\"STRAFERIGHT\")
        - PHYSICS.keyState(\"STRAFELEFT\")\nSHIP.plan.throttleVertical = PHYSICS.keyState(\"UP\")
        - PHYSICS.keyState(\"DOWN\")\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal
        finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput
        = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput
        = PHYSICS.keyState(\"BRAKE\")\nSHIP.spin(finalPitchInput, finalRollInput,
        finalYawInput)\nSHIP.brake(finalBrakeInput)\nend\nCommandSelect.add(ENGINE_SHIP,
        true)\n-- Autopilot Screen\n-- This is for managing autopilot information.\n--
        1. Bookmark current location, with 5-character name\n-- 2. List of bookmarks
        to go to.\nlocal AutoPilotScreen = {\nname = \"Autopilot\",\nCHOICES = {},\nChoice
        = 1,\ninNameEntry = false,\ndeleteat = 0\n}\nAutoPilotScreen.reset = function()\nAutoPilotScreen.CHOICES
        = {\n{namer = true, name = \"Bookmark Current Location\"},\n{clearer = true,
        name = \"Clear set destination\"}\n}\nAutoPilotScreen.Choice = 1\nAutoPilotScreen.inNameEntry
        = false\nlocal bms = AutoPilotScreen.getBookmarks()\nfor _, bm in ipairs(bms)
        do\ntable.insert(AutoPilotScreen.CHOICES, bm)\nend\nend\nAutoPilotScreen.getBookmarks
        = function()\nif databank.hasKey(\"bookmarks\") then\nlocal ret = nil\nif\npcall(\nfunction()\nlocal
        s = databank.getStringValue(\"bookmarks\")\nret = json.decode(s)\nend\n)\nthen\nif
        type(ret) == \"table\" then\nreturn ret\nend\nend\nend\nreturn {}\nend\nAutoPilotScreen.addBookmark
        = function(bm)\nlocal bms = AutoPilotScreen.getBookmarks()\ntable.insert(bms,
        bm)\ndatabank.setStringValue(\"bookmarks\", json.encode(bms))\nAutoPilotScreen.reset()\nend\nAutoPilotScreen.deleteBookmark
        = function(idx, todel)\nlocal bms = AutoPilotScreen.getBookmarks()\nlocal
        newbms = {}\nlocal done = false\nfor _, bm in ipairs(bms) do\nif not done
        and bm.position[1] == todel.position[1] and bm.name == todel.name and bm.altitude
        == todel.altitude then\ndone = true\nelse\ntable.insert(newbms, bm)\nend\nend\ndatabank.setStringValue(\"bookmarks\",
        json.encode(newbms))\nAutoPilotScreen.reset()\nend\nlocal BMState = {\nchars
        = {\"A\"},\npos = 1\n}\nlocal BMMAP_DOWN = {\n[\"A\"] = \"B\", [\"B\"] = \"C\",
        [\"C\"] = \"D\", [\"D\"] = \"E\", [\"E\"] = \"F\",\n[\"F\"] = \"G\", [\"G\"]
        = \"H\", [\"H\"] = \"I\", [\"I\"] = \"J\", [\"J\"] = \"K\",\n[\"K\"] = \"L\",
        [\"L\"] = \"M\", [\"M\"] = \"N\", [\"N\"] = \"O\", [\"O\"] = \"P\",\n[\"P\"]
        = \"Q\", [\"Q\"] = \"R\", [\"R\"] = \"S\", [\"S\"] = \"T\", [\"T\"] = \"U\",\n[\"U\"]
        = \"V\", [\"V\"] = \"W\", [\"W\"] = \"X\", [\"X\"] = \"Y\", [\"Y\"] = \"Z\",\n[\"Z\"]
        = \"1\", [\"1\"] = \"2\", [\"2\"] = \"3\", [\"3\"] = \"4\", [\"4\"] = \"5\",\n[\"5\"]
        = \"6\", [\"6\"] = \"7\", [\"7\"] = \"8\", [\"8\"] = \"9\", [\"9\"] = \"0\",\n[\"0\"]
        = \" \", [\" \"] = \"A\"\n}\nlocal BMMAP_UP = {\n[\"A\"] = \" \", [\"B\"]
        = \"A\", [\"C\"] = \"B\", [\"D\"] = \"C\", [\"E\"] = \"D\",\n[\"F\"] = \"E\",
        [\"G\"] = \"F\", [\"H\"] = \"G\", [\"I\"] = \"H\", [\"J\"] = \"I\",\n[\"K\"]
        = \"J\", [\"L\"] = \"K\", [\"M\"] = \"L\", [\"N\"] = \"M\", [\"O\"] = \"N\",\n[\"P\"]
        = \"O\", [\"Q\"] = \"P\", [\"R\"] = \"Q\", [\"S\"] = \"R\", [\"T\"] = \"S\",\n[\"U\"]
        = \"T\", [\"V\"] = \"U\", [\"W\"] = \"V\", [\"X\"] = \"W\", [\"Y\"] = \"X\",\n[\"Z\"]
        = \"Y\", [\"1\"] = \"Z\", [\"2\"] = \"1\", [\"3\"] = \"2\", [\"4\"] = \"3\",\n[\"5\"]
        = \"4\", [\"6\"] = \"5\", [\"7\"] = \"6\", [\"8\"] = \"7\", [\"9\"] = \"8\",\n[\"0\"]
        = \"9\", [\" \"] = \"0\"\n}\nBMState.render = function()\nlocal chars = {}\nfor
        p, char in ipairs(BMState.chars) do\ntable.insert(chars, el(\"div\", {class
        = (p == BMState.pos and \"sel ch\" or \"ch\")}, char))\nend\nreturn el(\n\"div\",\n{class
        = \"namer\"},\n[[<p>Enter a name: A = prev char D = next char, S = abc, W
        = zyx.</p>]] ..\ntable.concat(chars, \"\") .. [[<p>Press space to add bookmark</p>]]\n)\nend\nBMState.up
        = function()\nlocal cur = BMState.chars[BMState.pos]\ncur = BMMAP_UP[cur]\nBMState.chars[BMState.pos]
        = cur\nend\nBMState.down = function()\nlocal cur = BMState.chars[BMState.pos]\ncur
        = BMMAP_DOWN[cur]\nBMState.chars[BMState.pos] = cur\nend\nBMState.left = function()\nBMState.pos
        = BMState.pos - 1\nif BMState.pos < 1 then\nBMState.pos = 1\nend\nend\nBMState.right
        = function()\nBMState.pos = BMState.pos + 1\nif BMState.pos > 20 then\nBMState.pos
        = 20\nend\nif BMState.pos > #BMState.chars then\ntable.insert(BMState.chars,
        \"A\")\nend\nend\nAutoPilotScreen.Style =\nel(\n\"style\",\n[[\n.namer { position:
        fixed; width: 20vw; height: 20vh; padding: 2em; display: block; left: 45vw;
        top: 45vh; font-size: 3vh; color: white; background-color: #666699ee; }\n.ch
        { display: inline-block; width: 3vh; height: 3vh; text-align: center; }\n.sel
        { background-color: #669966ee; }\n.bookmarks { position: fixed; display: block;
        left: 40vw; top: 35vh; }\n.estab { display: block; width: 15vw; height: 4vh;
        margin: 0; padding: 5px; background-color: grey; font-size: 1.5vh; color:
        white; }\n.essel { background-color: yellow; color: black; }\n]]\n)\nAutoPilotScreen.onFORWARD
        = function()\nif AutoPilotScreen.inNameEntry then\nBMState.up()\nreturn\nend\nAutoPilotScreen.Choice
        = AutoPilotScreen.Choice - 1\nif AutoPilotScreen.Choice < 1 then\nAutoPilotScreen.Choice
        = #AutoPilotScreen.CHOICES\nend\nend\nAutoPilotScreen.onBACKWARD = function()\nif
        AutoPilotScreen.inNameEntry then\nBMState.down()\nreturn\nend\nAutoPilotScreen.Choice
        = AutoPilotScreen.Choice + 1\nif AutoPilotScreen.Choice > #AutoPilotScreen.CHOICES
        then\nAutoPilotScreen.Choice = 1\nend\nend\nAutoPilotScreen.onYAWLEFT = function()\nif
        AutoPilotScreen.inNameEntry then\nBMState.left()\nreturn\nend\nend\nAutoPilotScreen.onYAWRIGHT
        = function()\nif AutoPilotScreen.inNameEntry then\nBMState.right()\nreturn\nend\nend\nAutoPilotScreen.onLEFT
        = function()\nif AutoPilotScreen.inNameEntry then\nAutoPilotScreen.inNameEntry
        = false\nreturn\nend\nlocal choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\nif
        not choice.position then\nreturn\nend\nlocal now = system.getTime()\nif now
        - AutoPilotScreen.deleteat < 2.0 then\nAutoPilotScreen.deleteBookmark(AutoPilotScreen.Choice,
        choice)\nelse\nAutoPilotScreen.deleteat = now\nend\nend\nAutoPilotScreen.bookmark
        = function(name)\nlocal bm = {\nname = name,\nposition = core.getConstructWorldPos(),\naltitude
        = PHYSICS.altitude,\ninatmo = PHYSICS.inAtmo,\n}\nAutoPilotScreen.addBookmark(bm)\nend\nfunction
        clearDestination()\ndatabank.setStringValue(\"destination\", \"{}\")\nMainScreen.destination
        = {}\nend\nAutoPilotScreen.onUP = function()\nif AutoPilotScreen.inNameEntry
        then\nAutoPilotScreen.bookmark(table.concat(BMState.chars, \"\"))\nreturn\nend\nlocal
        choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\nif choice.namer
        then\nAutoPilotScreen.inNameEntry = true\nBMState.chars = {\"A\"}\nBMState.pos
        = 1\nreturn\nend\nif choice.clearer then\nclearDestination()\nend\nif not
        choice.position then\nreturn\nend\ndatabank.setStringValue(\"destination\",
        json.encode(choice))\nMainScreen.destination = choice\nend\nAutoPilotScreen.render
        = function()\nlocal tabs = {}\nlocal chosen = nil\nfor i, engine in ipairs(AutoPilotScreen.CHOICES)
        do\nlocal cls = \"estab\"\nif i == AutoPilotScreen.Choice then\ncls = \"estab
        essel\"\nchosen = engine\nend\ntable.insert(tabs, el(\"div\", {class = cls},
        engine.name))\nend\nlocal bmname = \"\"\nif AutoPilotScreen.inNameEntry then\nbmname
        = BMState.render()\nend\nreturn AutoPilotScreen.Style .. el(\"div\", {class
        = \"bookmarks\"}, tabs) .. bmname\nend\n-- HUD Configuration\n-- This is loaded
        fairly early on, so HUD instances can\n-- register themselves with HUDConfig\nlocal
        HUDConfig = {\nname = \"HUD Config\",\nHUDS = {},\nOPTIONS = {},\nChoice =
        1,\nENABLED = {}\n}\nlocal function getOpt(opt)\nif not databank.hasKey(opt.key)
        then\nreturn opt.val\nend\nif opt.datatype == \"bool\" then\nreturn databank.getIntValue(opt.key)
        ~= 0\nend\nif opt.datatype == \"int\" then\nreturn databank.getIntValue(opt.key)\nend\nif
        opt.datatype == \"float\" then\nreturn databank.getFloatValue(opt.key)\nend\nend\nlocal
        function setOpt(opt, val)\nopt.hud.opts[opt.id] = val\nif opt.datatype ==
        \"bool\" then\ndatabank.setIntValue(opt.key, val and 1 or 0)\nend\nif opt.datatype
        == \"int\" then\nreturn databank.setIntValue(opt.key, val)\nend\nif opt.datatype
        == \"float\" then\nreturn databank.setFloatValue(opt.key, val)\nend\nend\nlocal
        hudodd = false\nlocal HUDUI = {}\nHUDUI.BoolHandler = {\nrender = function(opt)\nif
        getOpt(opt) then\nreturn \"YES\"\nelse\nreturn \"NO\"\nend\nend,\nonSpace
        = function(opt)\nlocal val = not getOpt(opt)\nsetOpt(opt, val)\nif opt.onset
        then\nopt.onset(opt, val)\nend\nend\n}\nHUDUI.IntHandler = {\nrender = function(opt)\nlocal
        v = getOpt(opt)\nreturn string.format(\"%d\", v)\nend,\nonLeft = function(opt)\nlocal
        val = getOpt(opt) - opt.step\nif val < opt.min then\nval = opt.min\nend\nsetOpt(opt,
        val)\nif opt.onset then\nopt.onset(opt, val)\nend\nend,\nonRight = function(opt)\nlocal
        val = getOpt(opt) + opt.step\nif val > opt.max then\nval = opt.max\nend\nsetOpt(opt,
        val)\nif opt.onset then\nopt.onset(opt, val)\nend\nend\n}\nfunction HUDConfig.setEnabled(opt,
        val)\nlocal hud = opt.hud\nhud.opts.enabled = val\nif val then\nHUDConfig.ENABLED[hud.name]
        = hud\nif hud.start then\nhud.start(hud)\nend\nelse\nHUDConfig.ENABLED[hud.name]
        = nil\nif hud.stop then\nhud.stop(hud)\nend\nend\nend\nfunction HUDConfig.addHUD(hud)\nlocal
        cls = \"heven\"\nif hudodd then\ncls = \"hodd\"\nend\nhudodd = not hudodd\ntable.insert(HUDConfig.HUDS,
        hud)\nif type(hud.opts.enabled) == type(true) then\ntable.insert(\nHUDConfig.OPTIONS,\n{\ncls
        = cls, -- for HUDUI rendering and grouping\nhud = hud,\nid = \"enabled\",\ndatatype
        = \"bool\",\nval = hud.opts.enabled,\nonset = HUDConfig.setEnabled,\nname
        = \"Enable \" .. hud.name,\nuihandler = HUDUI.BoolHandler,\nkey = hud.key
        .. \".\" .. \"enabled\"\n}\n)\nend\nif hud.config then\nfor k, v in pairs(hud.config)
        do\nif not v.cls then\nv.cls = cls\nend\nif not v.hud then\nv.hud = hud\nend\nif
        not v.val then\nv.val = hud.opts[k]\nend\nif not v.name then\nv.name = k\nend\nif
        not v.key then\nv.key = hud.key .. \".\" .. k\nend\nif not v.id then\nv.id
        = k\nend\ntable.insert(HUDConfig.OPTIONS, v)\nend\nend\nend\nHUDConfig.Style
        =\nel(\n\"style\",\n[[\n.hudlist { position: fixed; display: block; left:
        20vw; top: 35vh; }\n.heven { background-color: #333399; }\n.hodd { background-color:
        #339933; }\n.hi { display: block; width: 35vw; height: 4vh; margin: 0; padding:
        5px; font-size: 2vh; color: white; }\n.hsel { background-color: yellow; color:
        black; }\n.hv { display: block; float: right; margin-right: 1vw; }\n]]\n)\nHUDConfig.onFORWARD
        = function()\nHUDConfig.Choice = HUDConfig.Choice - 1\nif HUDConfig.Choice
        < 1 then\nHUDConfig.Choice = #HUDConfig.OPTIONS\nend\nend\nHUDConfig.onBACKWARD
        = function()\nHUDConfig.Choice = HUDConfig.Choice + 1\nif HUDConfig.Choice
        > #HUDConfig.OPTIONS then\nHUDConfig.Choice = 1\nend\nend\nHUDConfig.onYAWLEFT
        = function()\nlocal opt = HUDConfig.OPTIONS[HUDConfig.Choice]\nif opt.uihandler.onLeft
        then\nopt.uihandler.onLeft(opt)\nend\nend\nHUDConfig.onYAWRIGHT = function()\nlocal
        opt = HUDConfig.OPTIONS[HUDConfig.Choice]\nif opt.uihandler.onRight then\nopt.uihandler.onRight(opt)\nend\nend\nHUDConfig.onUP
        = function()\nlocal opt = HUDConfig.OPTIONS[HUDConfig.Choice]\nif opt.uihandler.onSpace
        then\nopt.uihandler.onSpace(opt)\nend\nend\nHUDConfig.render = function()\nlocal
        tabs = {}\nlocal chosen = nil\nfor i, opt in ipairs(HUDConfig.OPTIONS) do\nlocal
        cls = opt.cls .. \" hi\"\nif i == HUDConfig.Choice then\ncls = \"hi hsel\"\nchosen
        = opt\nend\ntable.insert(tabs, el(\"div\", {class = cls}, {opt.name, el(\"div\",
        {class = \"hv\"}, opt.uihandler.render(opt))}))\nend\nreturn HUDConfig.Style
        .. el(\"div\", {class = \"hudlist\"}, tabs)\nend\nHUDConfig.start = function()\n--
        In here we load all data from databank for each option.\nfor i, opt in pairs(HUDConfig.OPTIONS)
        do\nlocal val = getOpt(opt)\nif opt.onset then\nopt.onset(opt, val)\nend\nopt.hud.opts[opt.id]
        = val\nend\nend\n-- Widget HUDS from default ship configuration\nlocal function
        displayCategoryPanel(elements, title, widgettype)\nif #elements > 0 then\nlocal
        panel = system.createWidgetPanel(title)\nlocal widget = system.createWidget(panel,
        widgettype)\nfor i, el in pairs(elements) do\nsystem.addDataToWidget(elements[i].getDataId(),
        widget)\nend\nreturn panel\nend\nend\nlocal function addFuelWidget(name, varname)\nlocal
        widget = {\nname = \"Default \" .. name .. \" Widget\",\nkey = \"defaultwidget\"
        .. varname,\nopts = {\nenabled = false\n}\n}\nfunction widget.start(self)\nself.panel
        = displayCategoryPanel(_G.fueltanks[varname], name .. \" Fuel\", \"fuel_container\")\nend\nfunction
        widget.stop(self)\nsystem.destroyWidgetPanel(self.panel)\nend\nHUDConfig.addHUD(widget)\nend\naddFuelWidget(\"Atmo\",
        \"atmo\")\naddFuelWidget(\"Space\", \"space\")\naddFuelWidget(\"Rocket\",
        \"rocket\")\nlocal HUDWidgetCore = {\nname = \"Hide Controller Default\",\nkey
        = \"defaultwidgetcore\",\nopts = {\nenabled = false\n}\n}\nfunction HUDWidgetCore.start(self)\nunit.hide()\nend\nfunction
        HUDWidgetCore.stop(self)\nunit.show()\nend\nHUDConfig.addHUD(HUDWidgetCore)\n--
        Damaged element display. Only visible with damage\n-- To display a lot of
        debug information related to autopilot\nlocal HUDDamage = {\nname = \"Damage
        Display\",\nkey = \"damagepanel\",\nopts = {\nenabled = true,\nposX = 50,\nposY
        = 600\n},\nconfig = {\nposX = {\nmin = 0,\ndefault = 50,\nmax = SCREEN_X,\ndatatype
        = \"int\",\nuihandler = HUDUI.IntHandler,\nname = \"Position X\",\nstep =
        20\n},\nposY = {\nmin = 0,\ndefault = 600,\nmax = SCREEN_Y,\ndatatype = \"int\",\nuihandler
        = HUDUI.IntHandler,\nname = \"Position Y\",\nstep = 20\n}\n}\n}\nfunction
        HUDDamage.check()\nlocal uids = core.getElementIdList()\nlocal damaged = {}\nfor
        _, uid in ipairs(uids) do\nlocal max = core.getElementMaxHitPointsById(uid)\nlocal
        cur = core.getElementHitPointsById(uid)\nif cur < max then\ntable.insert(damaged,
        {core.getElementNameById(uid), cur, max})\nend\nend\nreturn damaged\nend\nfunction
        HUDDamage.addData(data, name, val)\ntable.insert(data, el(\"tr\", {}, {\nel(\"td\",
        {}, name),\nel(\"th\", {}, val),\n}))\nend\nHUDDamage.style = [[<style>\ntable.dam
        { display: block; position: fixed; width: 9vw; font-size: 150%; }\ntable.dam
        th { width: 3vw; height: 1vh; text-align: right; color: red; }\ntable.dam
        td { width: 5vw; height: 1vh; text-align: left; }\n</style>]]\nfunction HUDDamage.render()\nlocal
        data = {}\nlocal damaged = HUDDamage.check()\nif #damaged < 1 then\nHUDDamage.addData(data,
        \"All Systems\", \"OKAY\")\nelse\nfor _, e in ipairs(damaged) do\nif e[2]
        == 0 then\nHUDDamage.addData(data, e[1], \"Broken\")\nelse\nHUDDamage.addData(data,
        e[1], string.format(\"%d/%d\", math.floor(e[2]), math.floor(e[3])))\nend\nend\nend\nreturn
        HUDDamage.style .. el(\"table\",\n{\nstyle = string.format(\n\"left: %dpx;
        top: %dpx;\",\nHUDDamage.opts.posX,\nHUDDamage.opts.posY\n),\nclass = \"dam\",\n},\ndata\n)\nend\nHUDConfig.addHUD(HUDDamage)\n--
        Rezoix's DU-hud\n-- https://github.com/Rezoix/DU-hud\nlocal HUDRezoix = {\nname
        = \"Rezoix's DU HUD\",\nkey = \"hudrezoix\",\nopts = {\nenabled = false\n}\n}\nfunction
        HUDRezoix.render()\nlocal altitude = core.getAltitude()\nlocal velocity =
        core.getVelocity()\nlocal speed = vec3(velocity):len()\nlocal worldV = vec3(core.getWorldVertical())\nlocal
        constrF = vec3(core.getConstructWorldOrientationForward())\nlocal constrR
        = vec3(core.getConstructWorldOrientationRight())\nlocal constrV = vec3(core.getConstructWorldOrientationUp())\nlocal
        pitch = gyro.getPitch()\n--180 - getRoll(worldV, constrR, constrF)\nlocal
        roll = gyro.getRoll()\n--getRoll(worldV, constrF, constrR)\nlocal bottomText
        = \"ROLL\"\nlocal mode = 0\nif (altitude == 0) then\nmode = 1\nelse\nmode
        = 0\nend\nif (mode == 1) then\nif (speed > 5) then\npitch = math.deg(math.atan(velocity[2],
        velocity[3])) - 90\nroll = math.deg(math.atan(velocity[2], velocity[1])) -
        90\nelse\npitch = 0\nroll = 0\nend\nbottomText = \"YAW\"\nend\ncontent =\n[[\n<style>\nbody
        {margin: 0}\nsvg {display:block; position:absolute; top:0; left:0}\n.majorLine
        {stroke:aqua;opacity:0.7;stroke-width:3;fill-opacity:0;}\n.minorLine {stroke:aqua;opacity:0.3;stroke-width:3;fill-opacity:0;}\n.text
        {fill:aqua;font-family:Montserrat;font-weight:bold}\n#space {}\n#ecu {}\n#atmos
        {}\n</style>\n<svg height=\"100%\" width=\"100%\" viewBox=\"0 0 1920 1080\">\n<g
        class=\"majorLine\">\n<line x1=\"939\" y1=\"537\" x2=\"957\" y2=\"519\"/>\n<line
        x1=\"939\" y1=\"543\" x2=\"957\" y2=\"561\"/>\n<line x1=\"981\" y1=\"537\"
        x2=\"963\" y2=\"519\"/>\n<line x1=\"981\" y1=\"543\" x2=\"963\" y2=\"561\"/>\n<line
        x1=\"932\" y1=\"540\" x2=\"945\" y2=\"540\"/>\n<line x1=\"988\" y1=\"540\"
        x2=\"975\" y2=\"540\"/>\n<line x1=\"960\" y1=\"512\" x2=\"960\" y2=\"525\"/>\n<line
        x1=\"960\" y1=\"568\" x2=\"960\" y2=\"555\"/>\n<g style=\"opacity:0.2\">\n<line
        x1=\"920\" y1=\"540\" x2=\"840\" y2=\"540\"/>\n<line x1=\"1000\" y1=\"540\"
        x2=\"1080\" y2=\"540\"/>\n<line x1=\"960\" y1=\"500\" x2=\"960\" y2=\"470\"/>\n<line
        x1=\"960\" y1=\"580\" x2=\"960\" y2=\"610\"/>\n</g>\n<path d=\"M 700 0 L 740
        35 Q 960 55 1180 35 L 1220 0\"/>\n<path d=\"M 792 550 L 785 550 L 785 650
        L 792 650\"/>\n</g>\n<g>\n<polygon points=\"782,540 800,535 800,545\" style=\"fill:rgb(42,
        234, 248);opacity:0.7\"/>\n<polygon points=\"1138,540 1120,535 1120,545\"
        style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n<polygon points=\"960,725
        955,707 965,707\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n</g>\n<g
        class=\"text\">\n<g font-size=10>\n<text x=\"785\" y=\"530\" text-anchor=\"start\">PITCH</text>\n<text
        x=\"1135\" y=\"530\" text-anchor=\"end\">PITCH</text>\n<text x=\"960\" y=\"688\"
        text-anchor=\"middle\">ROLL</text>\n<text x=\"790\" y=\"660\" text-anchor=\"start\">THRL</text>\n</g>\n<g
        font-size=15>\n<text x=\"1020\" y=\"33\" text-anchor=\"middle\" id=\"space\">SPACE</text>\n<text
        x=\"900\" y=\"33\" text-anchor=\"middle\" id=\"atmos\">ATMOS</text>\n<text
        x=\"960\" y=\"35\" text-anchor=\"middle\" id=\"ecu\">ECU</text>\n</g>\n</g>]]\npitchC
        = math.floor(pitch)\nfor i = pitchC - 25, pitchC + 25 do\nif (i % 10 == 0)
        then\nnum = i\nif (num > 180) then\nnum = -180 + 10 * (i - 18)\nelseif (num
        < -170) then\nnum = 180 + 10 * (i + 18)\nend\ncontent =\ncontent ..\n[[<g
        transform=\"translate(0 ]] ..\n(-i * 5 + pitch * 5) ..\n[[)\">\n<text x=\"745\"
        y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\nnum ..\n[[</text>\n<text x=\"1175\" y=\"540\" style=\"fill:rgb(1, 165,
        177);text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\nnum .. [[</text></g>]]\nend\nlen = 5\nif (i % 10 == 0) then\nlen = 30\nelseif
        (i % 5 == 0) then\nlen = 15\nend\ncontent =\ncontent ..\n[[\n<g transform=\"translate(0
        ]] ..\n(-i * 5 + pitch * 5) ..\n[[)\">\n<line x1=\"]] ..\n(780 - len) ..\n[[\"
        y1=\"540\" x2=\"780\" y2=\"540\"style=\"stroke:rgb(1, 165, 177);opacity:0.3;stroke-width:3\"/>\n<line
        x1=\"]] ..\n(1140 + len) ..\n[[\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:3\"/></g>]]\nend\nrollC = math.floor(roll)\nfor
        i = rollC - 35, rollC + 35 do\nif (i % 10 == 0) then\nnum = math.abs(i)\nif
        (num > 180) then\nnum = 180 + (180 - num)\nend\ncontent =\ncontent ..\n[[<g
        transform=\"rotate(]] ..\n(i - roll) ..\n[[,960,460)\">\n<text x=\"960\" y=\"760\"
        style=\"fill:rgb(1, 165, 177);text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\nnum .. [[</text></g>]]\nend\nlen = 5\nif (i % 10 == 0) then\nlen = 15\nelseif
        (i % 5 == 0) then\nlen = 10\nend\ncontent =\ncontent ..\n[[<g transform=\"rotate(]]
        ..\n(i - roll) ..\n[[,960,460)\">\n<line x1=\"960\" y1=\"730\" x2=\"960\"
        y2=\"]] ..\n(730 + len) .. [[\" style=\"stroke:rgb(1, 165, 177);opacity:0.3;stroke-width:2\"/></g>]]\nend\n--
        -unit.getThrottle()*0.97\ncontent =\ncontent ..\n[[<g transform=\"translate(0
        ]] ..\n(-50) ..\n[[)\">\n<polygon points=\"788,650 800,647 800,653\" style=\"fill:rgb(1,
        165, 177);opacity:0.7\"/>\n</g>]]\ncontent = content .. [[\n</svg>\n]]\nreturn
        content\nend\nHUDConfig.addHUD(HUDRezoix)\n-- Compact fuel gauges\n-- To replace
        the big ol' ugly widget.\nlocal HUDFuelGauges = {\nname = \"Compact Fuel Gauges\",\nkey
        = \"compactfuel\",\nopts = {\nenabled = false,\nposX = 50,\nposY = 50\n},\nconfig
        = {\nposX = {\nmin = 0,\ndefault = 50,\nmax = SCREEN_X,\ndatatype = \"int\",\nuihandler
        = HUDUI.IntHandler,\nname = \"Position X\",\nstep = 20\n},\nposY = {\nmin
        = 0,\ndefault = 50,\nmax = SCREEN_Y,\ndatatype = \"int\",\nuihandler = HUDUI.IntHandler,\nname
        = \"Position Y\",\nstep = 20\n}\n}\n}\nHUDFuelGauges.COLORS = {\natmo = \"#ccccff\",\nspace
        = \"yellow\",\nrocket = \"red\"\n}\nfunction HUDFuelGauges.renderTank(ft,
        tank, i)\nlocal color = HUDFuelGauges.COLORS[ft]\nlocal dat = json.decode(tank.getData())\nreturn
        el(\n\"g\",\n{\nel(\"rect\", {y = i * 30, width = 100, height = 20, fill =
        \"#00000000\", stroke = color, rx = 2}),\nel(\"rect\", {y = i * 30, width
        = (dat.percentage), height = 20, fill = color, rx = 2})\n}\n)\nend\nfunction
        HUDFuelGauges.render()\nlocal tanklist = {}\nfor _, fueltype in pairs({\"atmo\",
        \"space\", \"rocket\"}) do\nlocal tanks = _G.fueltanks[fueltype]\nif tanks
        and #tanks > 0 then\nfor _, tank in ipairs(tanks) do\ntable.insert(tanklist,
        HUDFuelGauges.renderTank(fueltype, tank, #tanklist))\nend\nend\nend\nreturn
        el(\n\"svg\",\n{\nstyle = string.format(\n\"display: block; position: fixed;
        left: %d; top: %d;\",\nHUDFuelGauges.opts.posX,\nHUDFuelGauges.opts.posY\n)\n},\ntanklist\n)\nend\nHUDConfig.addHUD(HUDFuelGauges)\n--
        Autopilot Information Display\n-- To display a lot of debug information related
        to autopilot\nlocal HUDAutopilot = {\nname = \"Autopilot Infopanel\",\nkey
        = \"autopilotpanel\",\nopts = {\nenabled = false,\nposX = 50,\nposY = 200\n},\nconfig
        = {\nposX = {\nmin = 0,\ndefault = 50,\nmax = SCREEN_X,\ndatatype = \"int\",\nuihandler
        = HUDUI.IntHandler,\nname = \"Position X\",\nstep = 20\n},\nposY = {\nmin
        = 0,\ndefault = 200,\nmax = SCREEN_Y,\ndatatype = \"int\",\nuihandler = HUDUI.IntHandler,\nname
        = \"Position Y\",\nstep = 20\n}\n}\n}\nfunction HUDAutopilot.addData(data,
        name, val)\ntable.insert(data, el(\"tr\", {}, {\nel(\"td\", {}, name),\nel(\"th\",
        {}, val),\n}))\nend\nHUDAutopilot.style = [[<style>\ntable.ap { display: block;
        position: fixed; font-size: 120%; }\ntable.ap td { width: 4vw; height: 1vh;
        text-align: left; }\ntable.ap th { width: 6vw; height: 1vh; text-align: right;
        }\n</style>]]\nfunction HUDAutopilot.render()\nlocal data = {}\nif MainScreen.destination
        and MainScreen.destination.position then\nHUDAutopilot.addData(data, \"Destination\",
        MainScreen.destination.name)\nlocal dpos = vec3(MainScreen.destination.position)\nlocal
        sbody = DU.getNearestBody(PHYSICS.position)\nlocal dbody = DU.getNearestBody(dpos)\nHUDAutopilot.addData(data,
        \"Location\", sbody.name)\nif sbody.name ~= dbody.name then\nHUDAutopilot.addData(data,
        \"Target Body\", dbody.name)\nend\nlocal phead = PHYSICS.getRotationDiff(getRoll(dpos
        - PHYSICS.position, PHYSICS.constructRight, PHYSICS.constructUp), 180)\nlocal
        yhead = getRoll(dpos - PHYSICS.position, PHYSICS.constructUp, PHYSICS.constructRight)\nHUDAutopilot.addData(data,
        \"Phead\", string.format(\"%d\", math.floor(phead)))\nHUDAutopilot.addData(data,
        \"Yhead\", string.format(\"%d\", math.floor(yhead)))\nend\nif not PHYSICS.inAtmo
        then\nHUDAutopilot.addData(data, \"Brake Dist\", Render.distance(PHYSICS.brakeDistance))\nHUDAutopilot.addData(data,
        \"Brake Time\", Render.time(PHYSICS.brakeTime))\nend\nreturn HUDAutopilot.style
        .. el(\"table\",\n{\nstyle = string.format(\n\"left: %dpx; top: %dpx;\",\nHUDAutopilot.opts.posX,\nHUDAutopilot.opts.posY\n),\nclass
        = \"ap\",\n},\ndata\n)\nend\nHUDConfig.addHUD(HUDAutopilot)\n-- Main screen,
        which tabs between different modes, and\n-- keeps state across children.\n--\n--
        We always have a ShipRunner running, even if ShipOff\n-- ShipRunner is background\n--
        Current Screen is foreground\n-- Main Tabs on top, always.\n-- MainScreen
        must be global for earlier files to access it.\nMainScreen = {\nShipRunner
        = {},\nShipCommand = nil,\nScreen = ScreenStart,\nTab = 1,\nACTIVE = {},\ndestination
        = nil\n}\nMainScreen.TABS = {\n{name = \"Control\", isControl = true, render
        = function()\nend}\n}\nif unit.isRemoteControlled() == 1 then\ntable.insert(\nMainScreen.TABS,\n{name
        = \"Walk\", isWalk = true, freeze = false, render = function()\nend}\n)\nend\ntable.insert(MainScreen.TABS,
        CommandSelect)\ntable.insert(MainScreen.TABS, AutoPilotScreen)\ntable.insert(MainScreen.TABS,
        HUDConfig)\n-- Control is active first.\nMainScreen.ACTIVE = MainScreen.TABS[1]\nMainScreen.onGEAR
        = function()\nMainScreen.Tab = MainScreen.Tab + 1\nif MainScreen.Tab > #MainScreen.TABS
        then\nMainScreen.Tab = 1\nend\nMainScreen.ACTIVE = MainScreen.TABS[MainScreen.Tab]\nif
        MainScreen.ACTIVE.isWalk then\nsystem.freeze(0)\nelse\nsystem.freeze(1)\nend\nend\nfunction
        MainScreen.setControl()\nMainScreen.Tab = 1\nMainScreen.ACTIVE = MainScreen.TABS[1]\nend\nfunction
        onFlush(secs)\nPHYSICS.update()\nif MainScreen.ShipCommand and MainScreen.ShipCommand.flush
        then\nMainScreen.ShipCommand.flush(secs)\nelseif MainScreen.ShipRunner and
        MainScreen.ShipRunner.flush then\nMainScreen.ShipRunner.flush(secs)\nend\nSHIP.flush()\nend\nfunction
        tabStyle()\nreturn el(\n\"style\",\n[[\n.maintabs { position: fixed; display:
        block; left: 40vw; top: 15vh; }\n.tab { display: inline-block; width: 5vw;
        height: 4vh; margin: 0; padding: 5px; background-color: grey; font-size: 2vh;
        color: white; }\n.sel { background-color: yellow; color: black; }\n.dest {
        display: block; position: fixed; left: 45vw; top: 26vh; font-size: 2vh; color:
        green; font-weight: bold; }\n.info { display: block; position: fixed; left:
        40vw; top: 20vh; font-size: 3vh; color: red; font-weight: bold; background-color:
        #66666666; }\n]]\n)\nend\nfunction renderTabs()\nlocal tabs = {}\nfor i, tab
        in ipairs(MainScreen.TABS) do\nlocal cls = \"tab\"\nif i == MainScreen.Tab
        then\ncls = \"tab sel\"\nend\ntable.insert(tabs, el(\"div\", {class = cls},
        tab.name))\nend\nreturn el(\"div\", {class = \"maintabs\"}, tabs)\nend\nfunction
        generateContent()\nlocal selected = MainScreen.TABS[MainScreen.Tab]\nlocal
        subscreen = \"\"\nif selected.render then\nsubscreen = selected.render() or
        \"\"\nelse\nsubscreen = \"NO RENDERER?\"\nend\nlocal shipcommand = \"\"\nif
        MainScreen.ShipCommand then\nshipcommand = el(\"div\", {class = \"info\"},
        \"Executing: \" .. MainScreen.ShipCommand.name .. \"(Q to cancel)\")\nend\nlocal
        dest = \"\"\nif MainScreen.destination and MainScreen.destination.name then\ndest
        = el(\"div\", {class = \"dest\"}, \"Destination: \" .. (MainScreen.destination.name
        or \"None?\"))\nend\nreturn el(\n\"html\",\n{\nel(\n\"head\",\n{\ntabStyle()\n}\n),\nel(\n\"body\",\n{\nrenderTabs(),\nrenderHUD(),\nsubscreen,\nshipcommand,\ndest\n}\n)\n}\n)\nend\nfunction
        renderHUD()\nlocal ret = {}\nfor _, hud in pairs(HUDConfig.ENABLED) do\nif
        hud.render then\ntable.insert(ret, hud.render())\nend\nend\nreturn table.concat(ret,
        \"\")\nend\nfunction MainScreen.start()\nsystem.freeze(1)\nsystem.showScreen(1)\nif
        databank.hasKey(\"destination\") then\nMainScreen.destination = json.decode(databank.getStringValue(\"destination\"))\nend\nlocal
        ec = databank.getStringValue(\"ec\")\nif ec and ec ~= nil and ec ~= \"\" then\nMainScreen.ShipCommand
        = CommandSelect.ENGINES_NAME[ec]\nif MainScreen.ShipCommand.resume then\nMainScreen.ShipCommand.resume()\nend\nend\nlocal
        eng = databank.getStringValue(\"eng\")\nif not eng or eng == nil or eng ==
        \"\" then\neng = ENGINE_SHIP.name\nend\nMainScreen.ShipRunner = CommandSelect.ENGINES_NAME[eng]\nif
        MainScreen.ShipRunner.start then\nMainScreen.ShipRunner.start()\nend\nend\nlocal
        NEXTRENDER = 0.0\nlocal FLYTIME = 0.0\nfunction onUpdate(secs)\nSHIP.update()\nif
        FLYTIME == 0.0 then\ninitialize()\nend\nFLYTIME = FLYTIME + secs\nif MainScreen.ShipRunner
        and MainScreen.ShipRunner.update then\nif not (MainScreen.ShipCommand and
        MainScreen.ShipCommand.override) then\nMainScreen.ShipRunner.update(secs)\nend\nend\nif
        MainScreen.ShipCommand and MainScreen.ShipCommand.update then\nMainScreen.ShipCommand.update(secs)\nend\nif
        FLYTIME > NEXTRENDER then\ncollectgarbage()\nfor _, hud in pairs(HUDConfig.ENABLED)
        do\nif hud.update then\nhud.update(secs)\nend\nend\nsystem.setScreen(generateContent())\nNEXTRENDER
        = FLYTIME + 0.1 -- 10 times a second\nend\nend\nfunction setEngineControl(engine)\nif
        engine.start then\nengine.start()\nend\nMainScreen.ShipRunner = engine\ndatabank.setStringValue(\"eng\",
        engine.name)\nend\nfunction clearEngineCommand()\nif MainScreen.ShipCommand
        and MainScreen.ShipCommand.stop then\nMainScreen.ShipCommand.stop()\nend\ndatabank.setStringValue(\"ec\",
        \"\")\nMainScreen.ShipCommand = nil\nend\nfunction setEngineCommand(cmd)\nif
        cmd.start then\ncmd.start()\nend\ndatabank.setStringValue(\"ec\", cmd.name)\nMainScreen.ShipCommand
        = cmd\nend\n-- Input from the player comes through here\nfunction press(s)\nif
        s == \"GEAR\" then\nMainScreen.onGEAR()\nreturn\nend\nlocal listener = MainScreen.ACTIVE\nif
        s == \"LEFT\" and MainScreen.ShipCommand and listener.isControl then\nclearEngineCommand()\nreturn\nend\nif
        listener.isWalk then\nreturn\nend\nif listener.isControl then\nif MainScreen.ShipCommand
        then\nlistener = MainScreen.ShipCommand\nend\nif not listener.override_controls
        then\nPHYSICS.PRESSED[s] = true\nlistener = MainScreen.ShipRunner\nend\nend\nlocal
        kb = \"start\" .. s\nif listener[kb] then\nlistener[kb]()\nend\nend\nfunction
        release(s)\nif s == \"GEAR\" then\nreturn\nend\nlocal listener = MainScreen.ACTIVE\nif
        listener.isWalk then\nreturn\nend\nif listener.isControl then\nPHYSICS.PRESSED[s]
        = nil\nlistener = MainScreen.ShipRunner\nend\nlocal kb = \"stop\" .. s\nlocal
        kb2 = \"on\" .. s\nif listener[kb] then\nlistener[kb]()\nelseif listener[kb2]
        then\nlistener[kb2]()\nelseif listener.hit then\nlistener.hit(s)\nend\nend\nfunction
        loopKey(s)\nif s == \"GEAR\" then\nreturn\nend\nlocal listener = MainScreen.ACTIVE\nif
        listener.isWalk then\nreturn\nend\nif listener.isControl then\nlistener =
        MainScreen.ShipRunner\nend\nlocal kb = \"loop\" .. s\nif listener[kb] then\nlistener[kb]()\nend\nend\nfunction
        initialize()\nsystem.print(\"Initializing ShipOS 0.01\")\nPHYSICS.update()\nHUDConfig.start()\nMainScreen.start()\nAutoPilotScreen.reset()\nlocal
        body = DU.getNearestBody(PHYSICS.position)\nsystem.print(\"Nearest: \" ..
        body.name)\nend\n"
  unit:
    start:
      lua: |-
        _G.fueltanks = {
        atmo = atmofueltank,
        space = spacefueltank,
        rocket = rocketfueltank,
        }
