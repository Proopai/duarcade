---
name: Ship OS Conf
slots:
  databank:
    class: DatabankUnit
  atmofueltank:
    class: AtmoFuelContainer
    select: all
  spacefueltank:
    class: SpaceFuelContainer
    select: all
  rocketfueltank:
    class: RocketFuelContainer
    select: all
  gyro:
    class: GyroUnit
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  core:
    class: CoreUnit
handlers:
  system:
    actionStart:
      lua: press("ANTIGRAVITY")
      args: [antigravity]
    actionStop:
      lua: release("ANTIGRAVITY")
      args: [antigravity]
    actionStart:
      lua: press("BACKWARD")
      args: [backward]
    actionStop:
      lua: release("BACKWARD")
      args: [backward]
    actionStart:
      lua: press("BOOSTER")
      args: [booster]
    actionStop:
      lua: release("BOOSTER")
      args: [booster]
    actionLoop:
      lua: loopKey("BRAKE")
      args: [brake]
    actionStart:
      lua: press("BRAKE")
      args: [brake]
    actionStop:
      lua: release("BRAKE")
      args: [brake]
    actionStart:
      lua: press("DOWN")
      args: [down]
    actionStop:
      lua: release("DOWN")
      args: [down]
    flush:
      lua: onFlush(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("FORWARD")
      args: [forward]
    actionStop:
      lua: release("FORWARD")
      args: [forward]
    actionStart:
      lua: press("GEAR")
      args: [gear]
    actionStop:
      lua: release("GEAR")
      args: [gear]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStart:
      lua: press("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStop:
      lua: release("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStop:
      lua: release("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("LALT")
      args: [lalt]
    actionStop:
      lua: release("LALT")
      args: [lalt]
    actionStart:
      lua: press("LEFT")
      args: [left]
    actionStop:
      lua: release("LEFT")
      args: [left]
    actionStart:
      lua: press("LIGHT")
      args: [light]
    actionStop:
      lua: release("LIGHT")
      args: [light]
    actionStart:
      lua: press("LSHIFT")
      args: [lshift]
    actionStop:
      lua: release("LSHIFT")
      args: [lshift]
    actionStart:
      lua: press("RIGHT")
      args: [right]
    actionStop:
      lua: release("RIGHT")
      args: [right]
    actionLoop:
      lua: loopKey("SPEEDDOWN")
      args: [speeddown]
    actionStart:
      lua: press("SPEEDDOWN")
      args: [speeddown]
    actionStop:
      lua: release("SPEEDDOWN")
      args: [speeddown]
    actionLoop:
      lua: loopKey("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("SPEEDUP")
      args: [speedup]
    actionStop:
      lua: release("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("STOPENGINES")
      args: [stopengines]
    actionStop:
      lua: release("STOPENGINES")
      args: [stopengines]
    actionStart:
      lua: press("STRAFELEFT")
      args: [strafeleft]
    actionStop:
      lua: release("STRAFELEFT")
      args: [strafeleft]
    actionStart:
      lua: press("STRAFERIGHT")
      args: [straferight]
    actionStop:
      lua: release("STRAFERIGHT")
      args: [straferight]
    actionStart:
      lua: press("UP")
      args: [up]
    actionStop:
      lua: release("UP")
      args: [up]
    update:
      lua: onUpdate(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("WARP")
      args: [warp]
    actionStop:
      lua: release("WARP")
      args: [warp]
    actionStart:
      lua: press("YAWLEFT")
      args: [yawleft]
    actionStop:
      lua: release("YAWLEFT")
      args: [yawleft]
    actionStart:
      lua: press("YAWRIGHT")
      args: [yawright]
    actionStop:
      lua: release("YAWRIGHT")
      args: [yawright]
    start:
      lua: "local SCREEN_X = 1920\nlocal SCREEN_Y = 1080\n\nfunction ischild(tbl)\n
        \   if type(tbl) == \"string\" then\n        return true\n    end\n    --
        Or if it has array-style indexes.\n    for i, _ in ipairs(tbl) do\n        return
        true\n    end\n    return false\nend\n\nfunction el(name, params, children)\n
        \   local attrvals = \"\"\n    if ischild(params) then\n        children =
        params\n    elseif params then\n        for k, v in pairs(params) do\n            k
        =\n                k:gsub(\n                \"%u\",\n                function(c)\n
        \                   return \"-\" .. c:lower()\n                end\n            )\n
        \           attrvals = attrvals .. \" \" .. k .. '=\"' .. v .. '\"'\n        end\n
        \   end\n    if type(children) == \"string\" then\n        return string.format(\"<%s%s>%s</%s>\",
        name, attrvals, children, name)\n    elseif type(children) == \"table\" then\n
        \       return string.format(\"<%s%s>%s</%s>\", name, attrvals, table.concat(children,
        \"\\n\"), name)\n    else\n        return string.format(\"<%s%s />\", name,
        attrvals)\n    end\nend\n\nlastarg = \"\"\nfunction eldebug(arg)\n    if arg
        ~= lastarg then\n        system.print(string.gsub(string.gsub(arg, \"<\",
        \"(\"), \">\", \")\"))\n        lastarg = arg\n    end\n    return arg\nend\n\nlocal
        Render = {}\n\nRender.distance = function(meters)\n    meters = math.floor(meters)\n
        \   if meters < 10000 then\n        return string.format(\"%dm\", meters)\n
        \   elseif meters < 250000 then\n        return string.format(\"%dkm\", math.floor(meters
        / 1000))\n    else\n        return string.format(\"%dsu\", math.floor(meters
        / 200000))\n    end\nend\n\nRender.time = function(secs)\n    local sign =
        ''\n    if secs < 0 then\n        sign = '-'\n    end\n    secs = math.abs(secs)\n
        \   local days = math.floor(secs / 86400)\n    secs = secs % 86400\n    local
        hours = math.floor(secs / 3600)\n    secs = secs % 3600\n    local minutes
        = math.floor(secs / 60)\n    secs = math.floor(secs % 60)\n    if days > 0
        then\n        return string.format(\"%s%dd %.2dh\", sign, days, hours)\n    elseif
        hours > 0 then\n        return string.format(\"%s%dh %.2dm\", sign, hours,
        minutes)\n    elseif minutes > 0 then\n        return string.format(\"%s%dm
        %.2ds\", sign, minutes, secs)\n    else\n        return string.format(\"%s%ds\",
        sign, secs)\n    end\nend\nfunction Kinematics() --\n  --[[ \n    DualUniverse
        kinematic equations\n    Author: JayleBreak\n    Usage (unit.start):\n    Kinematics
        = require('autoconf.custom.kinematics')\n    Methods:\n     computeAccelerationTime
        - \"relativistic\" version of t = (vf - vi)/a\n     computeDistanceAndTime
        - Return distance & time needed to reach final speed.\n     computeTravelTime
        - \"relativistic\" version of t=(sqrt(2ad+v^2)-v)/a\n    Description\n    DualUniverse
        increases the effective mass of constructs as their absolute\n    speed increases
        by using the \"lorentz\" factor (from relativity) as the scale\n    factor.
        \ This results in an upper bound on the absolute speed of constructs\n    (excluding
        \"warp\" drive) that is set to 30 000 KPH (8 333 MPS). This module\n    provides
        utilities for computing some physical quantities taking this\n    scaling
        into account.\n    ]]\n    local Kinematic = {} -- just a namespace\n    local
        C = 30000000 / 3600\n    local C2 = C * C\n    local ITERATIONS = 100 -- iterations
        over engine \"warm-up\" period\n    local function lorentz(v)\n        return
        1 / math.sqrt(1 - v * v / C2)\n    end\n    --\n    -- computeAccelerationTime
        - \"relativistic\" version of t = (vf - vi)/a\n    -- initial      [in]: initial
        (positive) speed in meters per second.\n    -- acceleration [in]: constant
        acceleration until 'finalSpeed' is reached.\n    -- final        [in]: the
        speed at the end of the time interval.\n    -- return: the time in seconds
        spent in traversing the distance\n    --\n    function Kinematic.computeAccelerationTime(initial,
        acceleration, final)\n        -- The low speed limit of following is: t=(vf-vi)/a
        (from: vf=vi+at)\n        local k1 = C * math.asin(initial / C)\n        return
        (C * math.asin(final / C) - k1) / acceleration\n    end\n    --\n    -- computeDistanceAndTime
        - Return distance & time needed to reach final speed.\n    -- initial[in]:
        \    Initial speed in meters per second.\n    -- final[in]:       Final speed
        in meters per second.\n    -- restMass[in]:    Mass of the construct at rest
        in Kg.\n    -- thrust[in]:      Engine's maximum thrust in Newtons.\n    --
        t50[in]:         (default: 0) Time interval to reach 50% thrust in seconds.\n
        \   -- brakeThrust[in]: (default: 0) Constant thrust term when braking.\n
        \   -- return: Distance (in meters), time (in seconds) required for change.\n
        \   --\n    function Kinematic.computeDistanceAndTime(initial, final, restMass,
        thrust, t50, brakeThrust)\n        -- This function assumes that the applied
        thrust is colinear with the\n        -- velocity. Furthermore, it does not
        take into account the influence\n        -- of gravity, not just in terms
        of its impact on velocity, but also\n        -- its impact on the orientation
        of thrust relative to velocity.\n        -- These factors will introduce (usually)
        small errors which grow as\n        -- the length of the trip increases.\n
        \       t50 = t50 or 0\n        brakeThrust = brakeThrust or 0 -- usually
        zero when accelerating\n        local tau0 = lorentz(initial)\n        local
        speedUp = initial <= final\n        local a0 = thrust * (speedUp and 1 or
        -1) / restMass\n        local b0 = -brakeThrust / restMass\n        local
        totA = a0 + b0\n        if speedUp and totA <= 0 or not speedUp and totA >=
        0 then\n            return -1, -1 -- no solution\n        end\n        local
        distanceToMax, timeToMax = 0, 0\n        -- If, the T50 time is set, then
        assume engine is at zero thrust and will\n        -- reach full thrust in
        2*T50 seconds. Thrust curve is given by:\n        -- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2
        where z=pi*(t/t50 - 1)/2\n        -- Acceleration is given by F(z)/m(z) where
        m(z) = m/sqrt(1-v^2/c^2)\n        -- or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2\n
        \       if a0 ~= 0 and t50 > 0 then\n            -- Closed form solution for
        velocity exists:\n            -- v(t) = -c*tan(w)/sqrt(tan(w)^2+1) => w =
        -asin(v/c)\n            -- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c\n
        \           -- @ t=0, v(0) = vi\n            -- pi*c*k1/pi/c = -asin(vi/c)\n
        \           -- k1 = asin(vi/c)\n            local k1 = math.asin(initial /
        C)\n            local c1 = math.pi * (a0 / 2 + b0)\n            local c2 =
        a0 * t50\n            local c3 = C * math.pi\n            local v = function(t)\n
        \               local w = (c1 * t - c2 * math.sin(math.pi * t / 2 / t50) +
        c3 * k1) / c3\n                local tan = math.tan(w)\n                return
        C * tan / math.sqrt(tan * tan + 1)\n            end\n            local speedchk
        = speedUp and function(s)\n                    return s >= final\n                end
        or function(s)\n                    return s <= final\n                end\n
        \           timeToMax = 2 * t50\n            if speedchk(v(timeToMax)) then\n
        \               local lasttime = 0\n                while math.abs(timeToMax
        - lasttime) > 0.5 do\n                    local t = (timeToMax + lasttime)
        / 2\n                    if speedchk(v(t)) then\n                        timeToMax
        = t\n                    else\n                        lasttime = t\n                    end\n
        \               end\n            end\n            -- There is no closed form
        solution for distance in this case.\n            -- Numerically integrate
        for time t=0 to t=2*T50 (or less)\n            local lastv = initial\n            local
        tinc = timeToMax / ITERATIONS\n            for step = 1, ITERATIONS do\n                local
        speed = v(step * tinc)\n                distanceToMax = distanceToMax + (speed
        + lastv) * tinc / 2\n                lastv = speed\n            end\n            if
        timeToMax < 2 * t50 then\n                return distanceToMax, timeToMax\n
        \           end\n            initial = lastv\n        end\n        -- At full
        thrust, acceleration only depends on the Lorentz factor:\n        -- v(t)'
        = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0\n        -- -> v = c*sin((at+k1)/c)\n
        \       -- @ t=0, v=vi: k1 = c*asin(vi/c)\n        -- -> t = (c*asin(v/c)
        - k1)/a\n        -- x(t)' = c*sin((at+k1)/c)\n        -- x = k2 - c^2 cos((at+k1)/c)/a\n
        \       -- @ t=0, x=0: k2 = c^2 * cos(k1/c)/a\n        local k1 = C * math.asin(initial
        / C)\n        local time = (C * math.asin(final / C) - k1) / totA\n        local
        k2 = C2 * math.cos(k1 / C) / totA\n        local distance = k2 - C2 * math.cos((totA
        * time + k1) / C) / totA\n        return distance + distanceToMax, time +
        timeToMax\n    end\n    --\n    -- computeTravelTime - \"relativistic\" version
        of t=(sqrt(2ad+v^2)-v)/a\n    -- initialSpeed [in]: initial (positive) speed
        in meters per second\n    -- acceleration [in]: constant acceleration until
        'distance' is traversed\n    -- distance [in]: the distance traveled in meters\n
        \   -- return: the time in seconds spent in traversing the distance\n    --\n
        \   function Kinematic.computeTravelTime(initial, acceleration, distance)\n
        \       -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a\n        --
        (from: d=vt+at^2/2)\n        if distance == 0 then\n            return 0\n
        \       end\n        if acceleration > 0 then\n            local k1 = C *
        math.asin(initial / C)\n            local k2 = C2 * math.cos(k1 / C) / acceleration\n
        \           return (C * math.acos(acceleration * (k2 - distance) / C2) - k1)
        / acceleration\n        end\n        assert(initial > 0, \"Acceleration and
        initial speed are both zero.\")\n        return distance / initial\n    end\n
        \   function Kinematic.lorentz(v)\n        return lorentz(v)\n    end\n    return
        Kinematic\nend\nKinematic = Kinematics()\n-- Physics stuff used by most of
        the scripted engines.\n-- Axis\nlocal PHYSICS = {\n    PRESSED = {},\n    nullvec
        = vec3(0.0, 0.0, 0.0)\n}\n\nfunction PHYSICS.keyState(key)\n    return PHYSICS.PRESSED[key]
        and 1 or 0\nend\n\nfunction d2r(v)\n    return v * constants.deg2rad\nend\n\nfunction
        PHYSICS.update()\n    -- Information about the ship\n    local unit_data =
        json.decode(unit.getData())\n    PHYSICS.maxBrakeForce = unit_data[\"maxBrake\"]
        or 100000000\n    PHYSICS.currentSpeed = unit_data[\"speed\"]\n    PHYSICS.currentBrake
        = unit_data[\"currentBrake\"]\n    PHYSICS.currentAccel = unit_data[\"acceleration\"]\n\n
        \   -- Gravity and which way is 'up'\n    PHYSICS.worldGravity = vec3(core.getWorldGravity())\n
        \   PHYSICS.worldVertical = vec3(core.getWorldVertical())\n    PHYSICS.altitude
        = core.getAltitude()\n    PHYSICS.position = vec3(core.getConstructWorldPos())\n\n
        \   -- Construct orientation\n    PHYSICS.constructUp = vec3(core.getConstructWorldOrientationUp())\n
        \   PHYSICS.constructForward = vec3(core.getConstructWorldOrientationForward())\n
        \   PHYSICS.constructRight = vec3(core.getConstructWorldOrientationRight())\n\n
        \   PHYSICS.constructLocalUp = vec3(core.getConstructOrientationUp())\n    PHYSICS.constructLocalForward
        = vec3(core.getConstructOrientationForward())\n    PHYSICS.constructLocalRight
        = vec3(core.getConstructOrientationRight())\n\n    PHYSICS.constructMass =
        core.getConstructMass()\n\n    -- Ship velocity relative to the world\n    PHYSICS.constructVelocity
        = vec3(core.getWorldVelocity())\n    PHYSICS.constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\n
        \   PHYSICS.constructVelocitySpeed = vec3(core.getWorldVelocity()):len()\n\n
        \   -- Angular velocity\n    PHYSICS.constructAngularVelocity = vec3(core.getWorldAngularVelocity())\n
        \   PHYSICS.airAngularFriction = vec3(core.getWorldAirFrictionAngularAcceleration())\n\n
        \   -- Pitch and Roll relative to the planet\n    -- I want pitch of 0 to
        be ship = flat, but game thinks flat = -90\n    PHYSICS.currentPitchDeg =
        (getRoll(PHYSICS.worldVertical, PHYSICS.constructRight, PHYSICS.constructUp)
        + 90) % 360\n    PHYSICS.currentRollDeg = getRoll(PHYSICS.worldVertical, PHYSICS.constructForward,
        PHYSICS.constructRight)\n    PHYSICS.currentYawDeg = getRoll(PHYSICS.worldVertical,
        PHYSICS.constructUp, PHYSICS.constructForward)\n\n    PHYSICS.atmosphereDensity
        = unit.getAtmosphereDensity()\n    PHYSICS.inAtmo = PHYSICS.worldVertical:len()
        > 0.01 and PHYSICS.atmosphereDensity > 0.0\n\n    PHYSICS.brakeDistance, PHYSICS.brakeTime
        = Kinematic.computeDistanceAndTime(\n            PHYSICS.constructVelocitySpeed,
        -- current speed\n\t    0, -- end speed\n\t    PHYSICS.constructMass,\n\t
        \   0, -- Forward force for turn and  burn, we don't bother\n\t    0, -- Warmup
        time for turn and burn\n\t    PHYSICS.maxBrakeForce) -- TODO: Include gravity?\nend\n\nfunction
        PHYSICS.getRotationDiff(targetRotation, currentRotation)\n    -- if targetrotation
        = 0 and currentRotation = 270, then diff should be -90,\n    -- not 270.\n
        \   -- target: 90. current: 120. Should return  -30\n    -- target: 0. current:
        270 . Should return 90\n    local targetDiff = (targetRotation - currentRotation)
        % 360\n    if targetDiff > 180.0 then\n        targetDiff = -(360 - targetDiff)\n
        \   elseif targetDiff < -180.0 then\n        targetDiff = -(360 + targetDiff)\n
        \   end\n    return targetDiff\nend\nfunction PHYSICS.getRotationCorrection(targetRotation,
        currentRotation)\n    local targetDiff = PHYSICS.getRotationDiff(targetRotation,
        currentRotation)\n    -- targetDiff is >= -180 <= 180\n    -- If abs() < 10,
        then return 0.5, otherwise 1.0\n    local mul = targetDiff > 0 and 1.0 or
        -1.0\n    if math.abs(targetDiff) < 0.1 then\n        return 0.0\n    elseif
        math.abs(targetDiff) < 10 then\n        return mul * 0.1\n    elseif math.abs(targetDiff)
        < 45 then\n        return mul * 0.5\n    else\n        return mul\n    end\nend\n\n--
        Rotation\nfunction PHYSICS.setRotationVelocity(angularVelocity, torqueFactor)\n
        \   local angularAcceleration = torqueFactor * (angularVelocity - PHYSICS.constructAngularVelocity)\n
        \   angularAcceleration = angularAcceleration - PHYSICS.airAngularFriction
        -- Try to compensate air friction\n\n    unit.setEngineCommand(\"torque\",
        {vec3(0.0, 0.0, 0.0):unpack()}, {angularAcceleration:unpack()}, 1, 0, \"\",
        \"\", \"\", 0)\nend\n\nfunction PHYSICS.setShipRotation(pitch, roll, yaw)\n
        \   local target = -pitch * PHYSICS.constructRight + roll * PHYSICS.constructForward
        + yaw * PHYSICS.constructUp\n\n    PHYSICS.setRotationVelocity(target, 2.0)\nend\nlocal
        SHIP = {}\n\nSHIP.plan = {\n    throttle = 0.0,\n    throttleLateral = 0.0,\n
        \   throttleVertical = 0.0,\n    pitch = 0.0,\n    roll = 0.0,\n    yaw =
        0.0,\n    brake = 0.0,\n    booster = false,\n    hoverAt = 4.0\n}\n\nSHIP.LONGITUDINAL
        = 0\nSHIP.LATERAL = 1\nSHIP.VERTICAL = 2\n\nSHIP.TORQUE = 2.0\n\nSHIP.setVectorThrust
        = function(throttle, tags, kinematicdirection, thrustdirection)\n    local
        thrust = PHYSICS.nullvec\n    if math.abs(throttle) > 0.01 then\n        local
        maxThrust = core.getMaxKinematicsParametersAlongAxis(tags, {kinematicdirection:unpack()})\n
        \       local speedF, speedB, spaceF, spaceB = table.unpack(maxThrust)\n        if
        not PHYSICS.inAtmo then\n            speedF, speedB = spaceF, spaceB\n        end\n
        \       local speed = speedF\n        if throttle < 0 then\n            speed
        = speedB\n        end\n        thrust = thrustdirection * speed * math.abs(throttle)\n
        \   end\n    unit.setEngineCommand(tags, {thrust:unpack()}, {PHYSICS.nullvec:unpack()},
        true, false, \"\", \"\", \"\", 0)\nend\n\nSHIP.update = function()\n    unit.setAxisCommandValue(SHIP.LONGITUDINAL,
        SHIP.plan.throttle)\n    unit.setAxisCommandValue(SHIP.LATERAL, SHIP.plan.throttleLateral)\n
        \   unit.setAxisCommandValue(SHIP.VERTICAL, SHIP.plan.throttleVertical)\nend\n\nSHIP.flush
        = function()\n    SHIP.setVectorThrust(\n        SHIP.plan.throttle,\n        \"thrust
        analog longitudinal\",\n        PHYSICS.constructLocalForward,\n        PHYSICS.constructForward\n
        \   )\n    SHIP.setVectorThrust(\n        SHIP.plan.throttleLateral,\n        \"thrust
        analog lateral\",\n        PHYSICS.constructLocalRight,\n        PHYSICS.constructRight\n
        \   )\n    SHIP.setVectorThrust(\n        SHIP.plan.throttleVertical,\n        \"thrust
        analog vertical\",\n        PHYSICS.constructLocalUp,\n        PHYSICS.constructUp\n
        \   )\n\n    local desiredAngularVelocity =\n        SHIP.plan.pitch * PHYSICS.constructRight
        + SHIP.plan.roll * PHYSICS.constructForward +\n        SHIP.plan.yaw * PHYSICS.constructUp\n\n
        \   PHYSICS.setRotationVelocity(desiredAngularVelocity, SHIP.TORQUE)\n\n    unit.setEngineThrust(\"brake\",
        SHIP.plan.brake * PHYSICS.maxBrakeForce)\n    if SHIP.plan.booster then\n
        \       -- Any non-zero value, really.\n        unit.setEngineThrust(\"booster\",
        100.0)\n    else\n        unit.setEngineThrust(\"booster\", 0.0)\n    end\n
        \   if SHIP.plan.hoverAt > 0.0 then\n        unit.activateGroundEngineAltitudeStabilization(SHIP.plan.hoverAt)\n
        \   else\n        unit.deactivateGroundEngineAltitudeStabilization()\n    end\nend\n\nSHIP.unhover
        = function()\n    SHIP.plan.hoverAt = -1.0\nend\n\nSHIP.hover = function(amt)\n
        \   amt = amt or 10.0\n    SHIP.plan.hoverAt = amt\nend\n\nSHIP.reset = function()\n
        \   unit.setupAxisCommandProperties(0, 0)\n    SHIP.plan = {\n        throttle
        = 0.0,\n        throttleLateral = 0.0,\n        throttleVertical = 0.0,\n
        \       pitch = 0.0,\n        roll = 0.0,\n        yaw = 0.0,\n        brake
        = 0.0,\n        booster = false,\n        hoverAt = 4.0\n    }\nend\n\nSHIP.killEngines
        = SHIP.reset\n\nSHIP.spin = function(pitch, roll, yaw)\n    SHIP.plan.pitch
        = pitch\n    SHIP.plan.roll = roll\n    SHIP.plan.yaw = yaw\nend\n\nSHIP.rotateTo
        = function(pitch, roll, yaw)\n    if pitch == nil then\n        pitch = PHYSICS.currentPitchDeg\n
        \   end\n    if roll == nil then\n        roll = PHYSICS.currentRollDeg\n
        \   end\n    if yaw == nil then\n        yaw = PHYSICS.currentYawDeg\n    end\n
        \   pitch = PHYSICS.getRotationCorrection(pitch, PHYSICS.currentPitchDeg)\n
        \   roll = PHYSICS.getRotationCorrection(roll, PHYSICS.currentRollDeg)\n    yaw
        = PHYSICS.getRotationCorrection(yaw, PHYSICS.currentYawDeg)\n    SHIP.spin(pitch,
        roll, yaw)\nend\n\nSHIP.throttleTo = function(amt)\n    SHIP.plan.throttle
        = utils.clamp(amt, -1.0, 1.0)\nend\n\nSHIP.extendLandingGears = function()\n
        \   unit.extendLandingGears()\nend\n\nSHIP.retractLandingGears = function()\n
        \   unit.retractLandingGears()\nend\n\nSHIP.getCorrectionThrust = function(heading)\n
        \   local rval = utils.sign(heading)\n    if math.abs(heading) > 90 then\n\treturn
        rval * 0.3\n    elseif math.abs(heading) > 15 then\n\treturn rval * 0.05\n
        \   elseif math.abs(heading) > 5 then\n\treturn rval * 0.01\n    end\n    return
        0\nend\n\nSHIP.turnToSpaceVector = function(vec)\n    local phead = getRoll(vec,
        PHYSICS.constructForward, PHYSICS.constructUp)\n    local yhead = -getRoll(vec,
        PHYSICS.constructUp, PHYSICS.constructRight)\n    local pvec = SHIP.getCorrectionThrust(phead)\n
        \   local yvec = SHIP.getCorrectionThrust(yhead)\n    -- Roll doesn't matter\n
        \   SHIP.spin(pvec, 0.0, yvec)\nend\n\nSHIP.turnToHeadingAtmo = function(pitch,
        heading)\n    local targetYaw = nil\n    local roll = 0\n    if math.abs(heading)
        > 90 then\n\ttargetYaw = 0.5\n\troll = 20\n    elseif math.abs(heading) >
        15 then\n\ttargetYaw = 0.2\n\troll = 10\n    elseif math.abs(heading) > 5
        then\n\ttargetYaw = math.abs(heading) / 100\n\troll = 5\n    elseif math.abs(heading)
        > 0.01 then\n\ttargetYaw = math.abs(heading) / 100\n\troll = 0\n    else\n\ttargetYaw
        = 0.0\n\troll = 0.0\n    end\n    if heading > 0 then\n\ttargetYaw = -targetYaw\n
        \   else\n\troll = -roll\n    end\n    local pvel = PHYSICS.getRotationCorrection(pitch,
        PHYSICS.currentPitchDeg)\n    local rvel = PHYSICS.getRotationCorrection(roll,
        PHYSICS.currentRollDeg)\n    local yvel = targetYaw\n    SHIP.spin(pvel, rvel,
        yvel)\nend\n\nSHIP.stabilize = function()\n    SHIP.rotateTo(0.0, 0.0, nil)\nend\n\nSHIP.brake
        = function(amt)\n    SHIP.plan.brake = amt or 1.0\nend\n-- Dealing with Dual
        Universe's planetary and moon bodies,\n-- Gravity, Locations, Bookmark styles,
        etc\n\nlocal DU = {}\n\nfunction DU.getNearestBody(loc)\n    -- Far planet
        for \"default\"\n    local nearest = DU.BODIES[4]\n    local ndist = (loc
        - nearest.center):len()\n    for id, body in pairs(DU.BODIES) do\n        local
        bdist = (loc - body.center):len()\n\tif bdist < ndist then\n\t    ndist =
        bdist\n\t    nearest = body\n\tend\n    end\n    return nearest\nend\n\nfunction
        DU.distanceFromSurface(loc, body)\n    return (loc - body.center):len() -
        body.radius\nend\n-- Taken from: https://github.com/Dimencia/DU-Orbital-Hud/blob/master/ButtonHUD.conf\n--
        Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom
        with minor modifications\nDU.BODIES = {\n    [1] = {\n\tGM = 6930729684,\n\tbodyId
        = 1,\n\tcenter = vec3({x = 17465536.000, y = 22665536.000, z = -34464.000}),\n\tname
        = \"Madis\",\n\tplanetarySystemId = 0,\n\tradius = 44300\n    },\n    [2]
        = {\n\tGM = 157470826617,\n\tbodyId = 2,\n\tcenter = vec3({x = -8.000, y =
        -8.000, z = -126303.000}),\n\tname = \"Alioth\",\n\tplanetarySystemId = 0,\n\tradius
        = 126068\n    },\n    [3] = {\n\tGM = 11776905000,\n\tbodyId = 3,\n\tcenter
        = vec3({x = 29165536.000, y = 10865536.000, z = 65536.000}),\n\tname = \"Thades\",\n\tplanetarySystemId
        = 0,\n\tradius = 49000\n    },\n    [4] = {\n\tGM = 14893847582,\n\tbodyId
        = 4,\n\tcenter = vec3({x = -13234464.000, y = 55765536.000, z = 465536.000}),\n\tname
        = \"Talemai\",\n\tplanetarySystemId = 0,\n\tradius = 57450\n    },\n    [5]
        = {\n\tGM = 16951680000,\n\tbodyId = 5,\n\tcenter = vec3({x = -43534464.000,
        y = 22565536.000, z = -48934464.000}),\n\tname = \"Feli\",\n\tplanetarySystemId
        = 0,\n\tradius = 60000\n    },\n    [6] = {\n\tGM = 10502547741,\n\tbodyId
        = 6,\n\tcenter = vec3({x = 52765536.000, y = 27165538.000, z = 52065535.000}),\n\tname
        = \"Sicari\",\n\tplanetarySystemId = 0,\n\tradius = 51100\n    },\n    [7]
        = {\n\tGM = 13033380591,\n\tbodyId = 7,\n\tcenter = vec3({x = 58665538.000,
        y = 29665535.000, z = 58165535.000}),\n\tname = \"Sinnen\",\n\tplanetarySystemId
        = 0,\n\tradius = 54950\n    },\n    [8] = {\n\tGM = 18477723600,\n\tbodyId
        = 8,\n\tcenter = vec3({x = 80865538.000, y = 54665536.000, z = -934463.940}),\n\tname
        = \"Teoma\",\n\tplanetarySystemId = 0,\n\tradius = 62000\n    },\n    [9]
        = {\n\tGM = 18606274330,\n\tbodyId = 9,\n\tcenter = vec3({x = -94134462.000,
        y = 12765534.000, z = -3634464.000}),\n\tname = \"Jago\",\n\tplanetarySystemId
        = 0,\n\tradius = 61590\n    },\n    [10] = {\n\tGM = 78480000,\n\tbodyId =
        10,\n\tcenter = vec3({x = 17448118.224, y = 22966846.286, z = 143078.820}),\n\tname
        = \"Madis Moon 1\",\n\tplanetarySystemId = 0,\n\tradius = 10000\n    },\n
        \   [11] = {\n\tGM = 237402000,\n\tbodyId = 11,\n\tcenter = vec3({x = 17194626.000,
        y = 22243633.880, z = -214962.810}),\n\tname = \"Madis Moon 2\",\n\tplanetarySystemId
        = 0,\n\tradius = 11000\n    },\n    [12] = {\n\tGM = 265046609,\n\tbodyId
        = 12,\n\tcenter = vec3({x = 17520614.000, y = 22184730.000, z = -309989.990}),\n\tname
        = \"Madis Moon 3\",\n\tplanetarySystemId = 0,\n\tradius = 15005\n    },\n
        \   [21] = {\n\tGM = 2118960000,\n\tbodyId = 21,\n\tcenter = vec3({x = 457933.000,
        y = -1509011.000, z = 115524.000}),\n\tname = \"Alioth Moon 1\",\n\tplanetarySystemId
        = 0,\n\tradius = 30000\n    },\n    [22] = {\n\tGM = 2165833514,\n\tbodyId
        = 22,\n\tcenter = vec3({x = -1692694.000, y = 729681.000, z = -411464.000}),\n\tname
        = \"Alioth Moon 4\",\n\tplanetarySystemId = 0,\n\tradius = 30330\n    },\n
        \   [26] = {\n\tGM = 68234043600,\n\tbodyId = 26,\n\tcenter = vec3({x = -1404835.000,
        y = 562655.000, z = -285074.000}),\n\tname = \"Sanctuary\",\n\tplanetarySystemId
        = 0,\n\tradius = 83400\n    },\n    [30] = {\n\tGM = 211564034,\n\tbodyId
        = 30,\n\tcenter = vec3({x = 29214402.000, y = 10907080.695, z = 433858.200}),\n\tname
        = \"Thades Moon 1\",\n\tplanetarySystemId = 0,\n\tradius = 14002\n    },\n
        \   [31] = {\n\tGM = 264870000,\n\tbodyId = 31,\n\tcenter = vec3({x = 29404193.000,
        y = 10432768.000, z = 19554.131}),\n\tname = \"Thades Moon 2\",\n\tplanetarySystemId
        = 0,\n\tradius = 15000\n    },\n    [40] = {\n\tGM = 141264000,\n\tbodyId
        = 40,\n\tcenter = vec3({x = -13503090.000, y = 55594325.000, z = 769838.640}),\n\tname
        = \"Talemai Moon 2\",\n\tplanetarySystemId = 0,\n\tradius = 12000\n    },\n
        \   [41] = {\n\tGM = 106830900,\n\tbodyId = 41,\n\tcenter = vec3({x = -12800515.000,
        y = 55700259.000, z = 325207.840}),\n\tname = \"Talemai Moon 3\",\n\tplanetarySystemId
        = 0,\n\tradius = 11000\n    },\n    [42] = {\n\tGM = 264870000,\n\tbodyId
        = 42,\n\tcenter = vec3({x = -13058408.000, y = 55781856.000, z = 740177.760}),\n\tname
        = \"Talemai Moon 1\",\n\tplanetarySystemId = 0,\n\tradius = 15000\n    },\n
        \   [50] = {\n\tGM = 499917600,\n\tbodyId = 50,\n\tcenter = vec3({x = -43902841.780,
        y = 22261034.700, z = -48862386.000}),\n\tname = \"Feli Moon 1\",\n\tplanetarySystemId
        = 0,\n\tradius = 14000\n    },\n    [70] = {\n\tGM = 396912600,\n\tbodyId
        = 70,\n\tcenter = vec3({x = 58969616.000, y = 29797945.000, z = 57969449.000}),\n\tname
        = \"Sinnen Moon 1\",\n\tplanetarySystemId = 0,\n\tradius = 17000\n    },\n
        \   [100] = {\n\tGM = 13975172474,\n\tbodyId = 100,\n\tcenter = vec3({x =
        98865536.000, y = -13534464.000, z = -934461.990}),\n\tname = \"Lacobus\",\n\tplanetarySystemId
        = 0,\n\tradius = 55650\n    },\n    [101] = {\n\tGM = 264870000,\n\tbodyId
        = 101,\n\tcenter = vec3({x = 98905288.170, y = -13950921.100, z = -647589.530}),\n\tname
        = \"Lacobus Moon 3\",\n\tplanetarySystemId = 0,\n\tradius = 15000\n    },\n
        \   [102] = {\n\tGM = 444981600,\n\tbodyId = 102,\n\tcenter = vec3({x = 99180968.000,
        y = -13783862.000, z = -926156.400}),\n\tname = \"Lacobus Moon 1\",\n\tplanetarySystemId
        = 0,\n\tradius = 18000\n    },\n    [103] = {\n\tGM = 211503600,\n\tbodyId
        = 103,\n\tcenter = vec3({x = 99250052.000, y = -13629215.000, z = -1059341.400}),\n\tname
        = \"Lacobus Moon 2\",\n\tplanetarySystemId = 0,\n\tradius = 14000\n    },\n
        \   [110] = {\n\tGM = 9204742375,\n\tbodyId = 110,\n\tcenter = vec3({x = 14165536.000,
        y = -85634465.000, z = -934464.300}),\n\tname = \"Symeon\",\n\tplanetarySystemId
        = 0,\n\tradius = 49050\n    },\n    [120] = {\n\tGM = 7135606629,\n\tbodyId
        = 120,\n\tcenter = vec3({x = 2865536.700, y = -99034464.000, z = -934462.020}),\n\tname
        = \"Ion\",\n\tplanetarySystemId = 0,\n\tradius = 44950\n    },\n    [121]
        = {\n\tGM = 106830900,\n\tbodyId = 121,\n\tcenter = vec3({x = 2472916.800,
        y = -99133747.000, z = -1133582.800}),\n\tname = \"Ion Moon 1\",\n\tplanetarySystemId
        = 0,\n\tradius = 11000\n    },\n    [122] = {\n\tGM = 176580000,\n\tbodyId
        = 122,\n\tcenter = vec3({x = 2995424.500, y = -99275010.000, z = -1378480.700}),\n\tname
        = \"Ion Moon 2\",\n\tplanetarySystemId = 0,\n\tradius = 15000\n    }\n}\n--
        Flying Engine Selection screen. The first tab of main screen.\n-- This is
        loaded fairly early on, so ShipEngine instances can\n-- register themselves
        with CommandSelection.\n\nlocal CommandSelect = {\n    name = \"Engine\",\n
        \   ENGINES = {},\n    ENGINES_NAME = {},\n    Choice = 1\n}\n\nCommandSelect.add
        = function(cmd, hide)\n    if not hide then\n        table.insert(CommandSelect.ENGINES,
        cmd)\n    end\n    CommandSelect.ENGINES_NAME[cmd.name] = cmd\nend\n\nCommandSelect.Style
        =\n    el(\n    \"style\",\n    [[\n\t    .enginetabs { position: fixed; display:
        block; left: 20vw; top: 35vh; }\n\t    .estab { display: block; width: 15vw;
        height: 4vh; margin: 0; padding: 5px; background-color: grey; font-size: 1.5vh;
        color: white; }\n\t    .essel { background-color: yellow; color: black; }\n\t
        \   .esdesc { position: fixed; display: block; left: 35vw; top: 35vh; background-color:
        #666666cc; padding: 1em; width: 30vw; height: 30vh; font-size: 2vh; }\n    ]]\n)\n\nCommandSelect.onFORWARD
        = function()\n    CommandSelect.Choice = CommandSelect.Choice - 1\n    if
        CommandSelect.Choice < 1 then\n        CommandSelect.Choice = #CommandSelect.ENGINES\n
        \   end\nend\n\nCommandSelect.onBACKWARD = function()\n    CommandSelect.Choice
        = CommandSelect.Choice + 1\n    if CommandSelect.Choice > #CommandSelect.ENGINES
        then\n        CommandSelect.Choice = 1\n    end\nend\n\nCommandSelect.onUP
        = function()\n    local choice = CommandSelect.ENGINES[CommandSelect.Choice]\n
        \   system.print(\"selecting engine\")\n    if choice.isEngine then\n        setEngineControl(choice)\n
        \   else\n        setEngineCommand(choice)\n    end\n    MainScreen.setControl()\nend\n\nCommandSelect.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, engine
        in ipairs(CommandSelect.ENGINES) do\n        local cls = \"estab\"\n        if
        i == CommandSelect.Choice then\n            cls = \"estab essel\"\n            chosen
        = engine\n        end\n        table.insert(tabs, el(\"div\", {class = cls},
        engine.name))\n    end\n    return CommandSelect.Style .. el(\"div\", {class
        = \"enginetabs\"}, tabs) .. el(\"div\", {class = \"esdesc\"}, chosen.desc)\nend\nlocal
        EC_LAND = {\n    name = \"Land Ship\",\n    desc = [[\n1) Shut off all thrust
        engines. Turn on all brakes.<br>\n2) Stabilize pitch and Roll to 0.<br>\n3)
        Extend landing gears.<br>\n4) Lower Altitude Stabilization to zero.<br>\n5)
        Shut down altitude stabilizers.\n]],\n    override = false\n}\n\nEC_LAND.start
        = function()\n    -- BRAKE ALL THE THINGS, but only if speed is low. If we
        are going fast, we\n    -- may be coasting.\n\n    EC_LAND.stage = \"stabilize\"\n
        \   SHIP.killEngines()\nend\n\nEC_LAND.resume = function()\n    EC_LAND.stage
        = \"done\"\n    SHIP.unhover()\nend\n\nEC_LAND.stop = function()\nend\n\nEC_LAND.flush
        = function(secs)\n    if EC_LAND.stage ~= \"done\" then\n        SHIP.stabilize()\n
        \   else\n        SHIP.killEngines()\n        SHIP.unhover()\n    end\n    if
        math.abs(PHYSICS.constructVelocitySpeed) > 0.2 then\n        SHIP.brake()\n
        \   end\n    if EC_LAND.stage == \"stabilize\" then\n        if\n            math.abs(PHYSICS.getRotationDiff(PHYSICS.currentPitchDeg,
        0)) < 2.0 and\n                math.abs(PHYSICS.getRotationDiff(PHYSICS.currentRollDeg,
        0)) < 2.0\n         then\n            SHIP.extendLandingGears()\n            EC_LAND.stage
        = \"extend\"\n            EC_LAND.timer = 0.0\n        end\n    end\n    if
        EC_LAND.stage == \"extend\" then\n        EC_LAND.timer = EC_LAND.timer +
        secs\n        if EC_LAND.timer > 3.0 then\n            system.print(\"extended\")\n
        \           EC_LAND.stage = \"lower\"\n            EC_LAND.timer = 0\n            SHIP.hover(1.0)\n
        \       end\n    end\n    if EC_LAND.stage == \"lower\" then\n        if math.abs(PHYSICS.constructVelocitySpeed)
        < 0.4 then\n            system.print(\"lowered, finished\")\n            EC_LAND.stage
        = \"done\"\n            SHIP.killEngines()\n            SHIP.unhover()\n            clearEngineCommand()\n
        \       end\n    end\nend\n\nCommandSelect.add(EC_LAND)\nlocal EC_HOVER =
        {\n    name = \"Hover\",\n    desc = [[\n1) Engage all brakes\n2) Set hover
        to 30 meters\n3) Rotate to be as flat as possible\n]],\n    override = false,\n
        \   runtime = 0.0\n}\n\nEC_HOVER.start = function()\n    -- BRAKE ALL THE
        THINGS, but only if speed is low. If we are going fast, we\n    -- may be
        coasting.\n\n    SHIP.retractLandingGears()\n    EC_HOVER.runtime = 0.0\nend\n\nEC_HOVER.resume
        = EC_HOVER.start\n\nEC_HOVER.stop = function()\nend\n\nEC_HOVER.flush = function(secs)\n
        \   EC_HOVER.runtime = EC_HOVER.runtime + secs\n    SHIP.stabilize()\n    SHIP.brake()\n
        \   SHIP.hover(30)\n    if EC_HOVER.runtime > 3.0 and math.abs(PHYSICS.constructVelocitySpeed)
        < 0.2 then\n        clearEngineCommand()\n    end\nend\n\nCommandSelect.add(EC_HOVER)\nlocal
        AP_DESCENT_THROTTLE = 0.2 --export: Throttle % to use on descent / approach\nlocal
        AP_DESCENT_DISTANCE = 2200 --export: How far away from destination to start
        descending\nlocal AP_CRUISE_ALTITUDE = 800 --export: How high above target
        altitude to cruise?\nlocal AP_CLIMB_PITCH = 15 --export: In degrees, how high
        to aim the ship during initial, full power climb.\nlocal AP_CRUISE_PITCH =
        6.0 --export: Pitch to cruise at. If you're bouncing up and down, adjust this.\n\nlocal
        AP_ESCAPE_PITCH = 15.0 --export: Pitch to climb out of atmosphere with.\n\nlocal
        EC_AUTOPILOT = {\n    name = 'Autopilot',\n    desc = [[\nEngage autopilot.
        Destination: (Select destination from autopilot menu)\n]],\n    desctemplate
        = [[\nEngage autopilot. Destination: %s.\n]],\n    override = false,\n\n    callbacks
        = {},\n    last_announcement = nil,\n    time = 0.0,\n    arrived = false,\n}\n\nEC_AUTOPILOT.start
        = function()\n    EC_AUTOPILOT.time = 0.0\n    EC_AUTOPILOT.arrived = false\n
        \   EC_AUTOPILOT.announcements = {}\n    EC_AUTOPILOT.recalculate()\nend\n\nEC_AUTOPILOT.announce
        = function(msg)\n    if EC_AUTOPILOT.last_announcement == msg then return
        end\n    EC_AUTOPILOT.last_announcement = msg\n    system.print(\"ANNOUNCEMENT:
        \" .. msg)\nend\n\nEC_AUTOPILOT.resume = EC_AUTOPILOT.start\n\nEC_AUTOPILOT.stop
        = function()\nend\n\n-- This is called twice a second\nEC_AUTOPILOT.recalculate
        = function()\n    if not databank.hasKey('destination') then return end\n
        \   EC_AUTOPILOT.callbacks = {}\n    -- This is the meat of autopilot.\n    --
        To start: discover our position relative to destination, our status\n    --
        \   (in atmo safe, in space safe, in space approaching, in atmo approaching)\n
        \   -- Then, determine which do we want to do:\n    --     - Brake and stop
        if we are close enough\n    --     - Determine if we are in-atmosphere or
        not\n    --     - Near, in atmo: Cross-planetary plotting\n    --     - Destination
        extraplanetary, in atmo: Take off.\n    --     - Approaching planet from space?
        YIKES.\n    --         - Be very conservative when approaching a space destination.\n
        \   --     - In space: Determine: speed up or slow down, and in which angle\n
        \   local destination = MainScreen.destination\n    if not (destination and
        destination.name) then\n\tclearEngineCommand()\n\treturn\n    end\n    local
        dpos = vec3(destination.position)\n    local mypos = vec3(core.getConstructWorldPos())\n
        \   local vdiff = dpos - mypos\n    local vdirection = vdiff:normalize()\n
        \   local dist = vdiff:len()\n    local inatmo = PHYSICS.inAtmo\n\n    local
        cbs = EC_AUTOPILOT.callbacks\n\n    -- vdiff also defines what vector we want
        to aim at.\n    -- If we're in atmo, though, we only want the yaw heading.\n
        \   local yaw_heading = getRoll(vdiff, PHYSICS.constructUp, PHYSICS.constructRight)\n
        \   local altDiff = PHYSICS.altitude - destination.altitude\n\n    local mybody
        = DU.getNearestBody(PHYSICS.position)\n    local dbody = DU.getNearestBody(vec3(destination.position))\n
        \   local samebody = mybody.id == dbody.id\n    local saltitude = DU.distanceFromSurface(PHYSICS.position,
        dbody)\n    local daltitude = DU.distanceFromSurface(vec3(destination.position),
        dbody)\n\n    SHIP.retractLandingGears()\n\n    -- I think there's no planets
        more than 1.5 SU wide, and there's no\n    if saltitude < 10000 and daltitude
        < 10000 and samebody then\n\n\tlocal flatdist = math.sqrt(dist*dist - altDiff*altDiff)\n\n\tlocal
        desiredAltitude = 0.0\n\n\t-- Still experimenting between speed and throttle\n\tlocal
        desiredSpeed = 0.0\n\tlocal desiredThrottle = 0.0\n\n        if EC_AUTOPILOT.arrived
        and PHYSICS.currentSpeed < 1.0 then\n\t    table.insert(cbs, {clearEngineCommand})\n\t
        \   table.insert(cbs, {clearDestination})\n\t    table.insert(cbs, {setEngineCommand,
        EC_LAND})\n        elseif EC_AUTOPILOT.arrived or flatdist < 30.0 then\n\t
        \   EC_AUTOPILOT.arrived = true\n\t    table.insert(cbs, {SHIP.stabilize})\n\t
        \   table.insert(cbs, {SHIP.throttleTo, 0.0})\n\t    table.insert(cbs, {SHIP.killEngines})\n\t
        \   table.insert(cbs, {SHIP.brake, 1.0})\n\t    table.insert(cbs, {SHIP.hover,
        10})\n\t    return\n\telseif flatdist < AP_DESCENT_DISTANCE then\n\t    desiredThrottle
        = AP_DESCENT_THROTTLE\n\t    desiredSpeed = 20.0\n\t    local fact = flatdist
        / AP_DESCENT_DISTANCE\n\t    desiredAltitude = destination.altitude + AP_CRUISE_ALTITUDE
        * (fact * fact)\n\telse\n\t    desiredThrottle = 1.0\n\t    desiredAltitude
        = destination.altitude + AP_CRUISE_ALTITUDE\n\t    desiredSpeed = 1000.0\n\tend\n\n\tlocal
        vertdiff = desiredAltitude - PHYSICS.altitude\n\n\tlocal pitch = 0.0\n\tlocal
        brakeTo = 0.0\n\n\tif PHYSICS.currentSpeed - desiredSpeed > 60 then\n\t    brakeTo
        = 1.0\n\telseif PHYSICS.currentSpeed - desiredSpeed > 10 then\n\t    brakeTo
        = 0.2\n\telse\n\t    brakeTo = 0.0\n\tend\n\n\tif vertdiff > 50 then\n\t    pitch
        = AP_CLIMB_PITCH\n\telseif vertdiff > -20 then\n\t    pitch = AP_CRUISE_PITCH\n\telseif
        vertdiff > -60 then\n\t    pitch = -5.0\n\telse\n\t    pitch = -15.0\n\tend\n\n\tdesiredThrottle
        = utils.clamp(desiredThrottle, 0.0, 1.0)\n\n\t-- At a very high distance (on
        other side of planet), yaw heading gets confused easily.\n\tif dist > 30000
        and math.abs(yaw_heading) < 5 then\n\t    yaw_heading = 0\n\tend\n\n        --
        Cross-planetary travel\n\ttable.insert(cbs, {SHIP.turnToHeadingAtmo, pitch,
        yaw_heading})\n\ttable.insert(cbs, {SHIP.hover, 30})\n\ttable.insert(cbs,
        {SHIP.throttleTo, desiredThrottle})\n\ttable.insert(cbs, {SHIP.brake, brakeTo})\n
        \   elseif inatmo then\n        -- If we are here, we have to take off. Destination
        is either in space, or\n\t-- on another body.\n\ttable.insert(cbs, {SHIP.throttleTo,
        1.0})\n\ttable.insert(cbs, {SHIP.brake, 0.0})\n        if EC_AUTOPILOT.time
        < 40 then\n\t    table.insert(cbs, {SHIP.turnToHeadingAtmo, AP_CLIMB_PITCH,
        yaw_heading})\n\t    EC_AUTOPILOT.announce(\"Begin takeoff\")\n\telseif PHYSICS.altitude
        < 3000 then\n\t    -- TODO: Depend on body gravity+density+etc?\n\t    SHIP.rotateTo(AP_CLIMB_PITCH,
        0.0, nil)\n\t    EC_AUTOPILOT.announce(\"Climb to escape\")\n\telse\n\t    SHIP.rotateTo(AP_ESCAPE_PITCH,
        0.0, nil)\n\t    EC_AUTOPILOT.announce(\"Attempting to escape atmo\")\n\tend\n
        \   elseif PHYSICS.altitude < 30000 and not samebody then\n\tEC_AUTOPILOT.announce(\"Out
        of atmosphere, attempting to escape\")\n        -- Continue to try escaping
        our planet.\n\tif inatmo then\n\t    table.insert(cbs, {SHIP.turnToHeadingAtmo,
        AP_CLIMB_PITCH, yaw_heading})\n\telse\n\t    table.insert(cbs, {SHIP.turnToSpaceVector,
        vdirection})\n\tend\n\ttable.insert(cbs, {SHIP.throttleTo, 1.0})\n\ttable.insert(cbs,
        {SHIP.brake, 0.0})\n    else\n        -- TODO: Raycast and determine if any
        of the bodies are in the way\n\t-- TODO: Correct vector instead of just accel
        towards point\n        local stopIn = dist\n        if saltitude < stopIn
        then stopIn = saltitude end\n\tstopIn = stopIn - 10000 -- Atmosphere\n\tEC_AUTOPILOT.announce(\"Performing
        space approach\")\n\tlocal brakedist = PHYSICS.brakeDistance * 1.5 -- Padding
        for Gravity until I can account for it\n\ttable.insert(cbs, {SHIP.turnToSpaceVector,
        vdirection})\n\tif (PHYSICS.currentSpeed > 270.0 and stopIn <= brakedist)
        or\n\t   (SHIP.plan.brake == 1.0 and stopIn < (brakedist * 1.2)) then\n\t
        \   -- 277 m/s is just under 1000 km/h, which is the damage point for\n\t
        \   -- entering atmosphere.\n\t    table.insert(cbs, {SHIP.brake, 1.0})\n\t
        \   table.insert(cbs, {SHIP.throttleTo, 0.0})\n\telseif brakedist < (stopIn
        * 0.75) then\n\t    table.insert(cbs, {SHIP.brake, 0.0})\n\t    table.insert(cbs,
        {SHIP.throttleTo, 1.0})\n\telse\n\t    table.insert(cbs, {SHIP.brake, 0.0})\n\t
        \   table.insert(cbs, {SHIP.throttleTo, 0.0})\n\tend\n    end\n\nend\n\nEC_AUTOPILOT.update
        = function(secs)\n    local now = EC_AUTOPILOT.time + secs\n    -- To save
        processing time, we recalculate only twice a second.\n    if math.floor(EC_AUTOPILOT.time
        * 2) ~= math.floor(now * 2) then\n        EC_AUTOPILOT.recalculate()\n    end\n
        \   EC_AUTOPILOT.time = now\nend\n\nEC_AUTOPILOT.flush = function(secs)\n
        \   for i, cbs in ipairs(EC_AUTOPILOT.callbacks) do\n        local cb = cbs[1]\n
        \       cb(table.unpack(cbs, 2, #cbs))\n    end\nend\n\nCommandSelect.add(EC_AUTOPILOT)\nlocal
        ENGINE_SHIP = {\n    name = \"Control engine using the SHIP shiplib\",\n    desc
        = [[Pretty much the same as default, but clearer in code for me.]],\n    isEngine
        = true\n}\n\nfunction ENGINE_SHIP.start()\n    system.print(\"Setting throttle
        info\")\n    SHIP.reset()\nend\n\nfunction ENGINE_SHIP.onSTOPENGINES()\n    SHIP.killEngines()\nend\n\nfunction
        ENGINE_SHIP.onBOOSTER()\n    SHIP.plan.booster = not SHIP.plan.booster\nend\n\nfunction
        ENGINE_SHIP.startSPEEDDOWN()\n    ENGINE_SHIP.alterSpeed(-0.1)\nend\n\nfunction
        ENGINE_SHIP.startSPEEDUP()\n    ENGINE_SHIP.alterSpeed(0.1)\nend\n\nfunction
        ENGINE_SHIP.alterSpeed(amt)\n    local cur = SHIP.plan.throttle + amt\n    if
        cur > 1.0 then\n        cur = 1.0\n    end\n    if cur < -1.0 then\n        cur
        = -1.0\n    end\n    SHIP.plan.throttle = cur\nend\n\nfunction ENGINE_SHIP.update(secs)\n
        \   local amt = system.getThrottleInputFromMouseWheel()\n    if math.abs(amt)
        > 0.01 then\n        ENGINE_SHIP.alterSpeed(0.1 * amt)\n    end\nend\n\nfunction
        ENGINE_SHIP.onLIGHT()\n    if unit.isAnyHeadlightSwitchedOn() == 1 then\n
        \       unit.switchOffHeadlights()\n    else\n        unit.switchOnHeadlights()\n
        \   end\nend\n\nfunction ENGINE_SHIP.startGROUNDALTITUDEUP()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\n    if SHIP.plan.hoverAt > 50.0 then\n        SHIP.plan.hoverAt
        = 50.0\n    end\nend\n\nfunction ENGINE_SHIP.loopGROUNDALTITUDEUP()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\n    if SHIP.plan.hoverAt > 50.0 then\n        SHIP.plan.hoverAt
        = 50.0\n    end\nend\n\nfunction ENGINE_SHIP.startGROUNDALTITUDEDOWN()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt - 1.0\n    if SHIP.plan.hoverAt < 1.0 then\n        SHIP.plan.hoverAt
        = 1.0\n    end\nend\n\nfunction ENGINE_SHIP.loopGROUNDALTITUDEDOWN()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt - 1.0\n    if SHIP.plan.hoverAt < 1.0 then\n        SHIP.plan.hoverAt
        = 1.0\n    end\nend\n\nfunction ENGINE_SHIP.onWARP()\n    if warpdrive ~=
        nil then\n        warpdrive.activateWarp()\n    end\nend\n\nfunction ENGINE_SHIP.onANTIGRAVITY()\n
        \   if antigrav ~= nil then\n        antigrav.toggle()\n    end\nend\n\nfunction
        ENGINE_SHIP.flush(secs)\n    -- OVERRIDE by shipos\n    local pitchInput =
        PHYSICS.keyState(\"BACKWARD\") - PHYSICS.keyState(\"FORWARD\")\n    local
        rollInput = PHYSICS.keyState(\"RIGHT\") - PHYSICS.keyState(\"LEFT\")\n    local
        yawInput = PHYSICS.keyState(\"YAWLEFT\") - PHYSICS.keyState(\"YAWRIGHT\")\n\n
        \   SHIP.plan.throttleLateral = PHYSICS.keyState(\"STRAFERIGHT\") - PHYSICS.keyState(\"STRAFELEFT\")\n
        \   SHIP.plan.throttleVertical = PHYSICS.keyState(\"UP\") - PHYSICS.keyState(\"DOWN\")\n\n
        \   local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n
        \   local finalRollInput = rollInput + system.getControlDeviceYawInput()\n
        \   local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n
        \   local finalBrakeInput = PHYSICS.keyState(\"BRAKE\")\n\n    SHIP.spin(finalPitchInput,
        finalRollInput, finalYawInput)\n\n    SHIP.brake(finalBrakeInput)\nend\n\nCommandSelect.add(ENGINE_SHIP,
        true)\n-- Autopilot Screen\n-- This is for managing autopilot information.\n--
        1. Bookmark current location, with 5-character name\n-- 2. List of bookmarks
        to go to.\n\nlocal AutoPilotScreen = {\n    name = \"Autopilot\",\n    CHOICES
        = {},\n    Choice = 1,\n    inNameEntry = false,\n    deleteat = 0\n}\n\nAutoPilotScreen.reset
        = function()\n    AutoPilotScreen.CHOICES = {\n        {namer = true, name
        = \"Bookmark Current Location\"},\n        {clearer = true, name = \"Clear
        set destination\"}\n    }\n    AutoPilotScreen.Choice = 1\n    AutoPilotScreen.inNameEntry
        = false\n\n    local bms = AutoPilotScreen.getBookmarks()\n    for _, bm in
        ipairs(bms) do\n        table.insert(AutoPilotScreen.CHOICES, bm)\n    end\nend\n\nAutoPilotScreen.getBookmarks
        = function()\n    if databank.hasKey(\"bookmarks\") then\n        local ret
        = nil\n        if\n            pcall(\n                function()\n                    local
        s = databank.getStringValue(\"bookmarks\")\n                    ret = json.decode(s)\n
        \               end\n            )\n         then\n            if type(ret)
        == \"table\" then\n                return ret\n            end\n        end\n
        \   end\n    return {}\nend\n\nAutoPilotScreen.addBookmark = function(bm)\n
        \   local bms = AutoPilotScreen.getBookmarks()\n    table.insert(bms, bm)\n
        \   databank.setStringValue(\"bookmarks\", json.encode(bms))\n    AutoPilotScreen.reset()\nend\n\nAutoPilotScreen.deleteBookmark
        = function(idx, todel)\n    local bms = AutoPilotScreen.getBookmarks()\n    local
        newbms = {}\n    local done = false\n    for _, bm in ipairs(bms) do\n        if
        not done and bm.position[1] == todel.position[1] and bm.name == todel.name
        and bm.altitude == todel.altitude then\n            done = true\n        else\n
        \           table.insert(newbms, bm)\n        end\n    end\n    databank.setStringValue(\"bookmarks\",
        json.encode(newbms))\n    AutoPilotScreen.reset()\nend\n\nlocal BMState =
        {\n    chars = {\"A\"},\n    pos = 1\n}\n\nlocal BMMAP_DOWN = {\n    [\"A\"]
        = \"B\", [\"B\"] = \"C\", [\"C\"] = \"D\", [\"D\"] = \"E\", [\"E\"] = \"F\",\n
        \   [\"F\"] = \"G\", [\"G\"] = \"H\", [\"H\"] = \"I\", [\"I\"] = \"J\", [\"J\"]
        = \"K\",\n    [\"K\"] = \"L\", [\"L\"] = \"M\", [\"M\"] = \"N\", [\"N\"] =
        \"O\", [\"O\"] = \"P\",\n    [\"P\"] = \"Q\", [\"Q\"] = \"R\", [\"R\"] = \"S\",
        [\"S\"] = \"T\", [\"T\"] = \"U\",\n    [\"U\"] = \"V\", [\"V\"] = \"W\", [\"W\"]
        = \"X\", [\"X\"] = \"Y\", [\"Y\"] = \"Z\",\n    [\"Z\"] = \"1\", [\"1\"] =
        \"2\", [\"2\"] = \"3\", [\"3\"] = \"4\", [\"4\"] = \"5\",\n    [\"5\"] = \"6\",
        [\"6\"] = \"7\", [\"7\"] = \"8\", [\"8\"] = \"9\", [\"9\"] = \"0\",\n    [\"0\"]
        = \" \", [\" \"] = \"A\"\n}\n\nlocal BMMAP_UP = {\n    [\"A\"] = \" \", [\"B\"]
        = \"A\", [\"C\"] = \"B\", [\"D\"] = \"C\", [\"E\"] = \"D\",\n    [\"F\"] =
        \"E\", [\"G\"] = \"F\", [\"H\"] = \"G\", [\"I\"] = \"H\", [\"J\"] = \"I\",\n
        \   [\"K\"] = \"J\", [\"L\"] = \"K\", [\"M\"] = \"L\", [\"N\"] = \"M\", [\"O\"]
        = \"N\",\n    [\"P\"] = \"O\", [\"Q\"] = \"P\", [\"R\"] = \"Q\", [\"S\"] =
        \"R\", [\"T\"] = \"S\",\n    [\"U\"] = \"T\", [\"V\"] = \"U\", [\"W\"] = \"V\",
        [\"X\"] = \"W\", [\"Y\"] = \"X\",\n    [\"Z\"] = \"Y\", [\"1\"] = \"Z\", [\"2\"]
        = \"1\", [\"3\"] = \"2\", [\"4\"] = \"3\",\n    [\"5\"] = \"4\", [\"6\"] =
        \"5\", [\"7\"] = \"6\", [\"8\"] = \"7\", [\"9\"] = \"8\",\n    [\"0\"] = \"9\",
        [\" \"] = \"0\"\n}\n\nBMState.render = function()\n    local chars = {}\n
        \   for p, char in ipairs(BMState.chars) do\n        table.insert(chars, el(\"div\",
        {class = (p == BMState.pos and \"sel ch\" or \"ch\")}, char))\n    end\n\n
        \   return el(\n        \"div\",\n        {class = \"namer\"},\n        [[<p>Enter
        a name: A = prev char D = next char, S = abc, W = zyx.</p>]] ..\n            table.concat(chars,
        \"\") .. [[<p>Press space to add bookmark</p>]]\n    )\nend\n\nBMState.up
        = function()\n    local cur = BMState.chars[BMState.pos]\n    cur = BMMAP_UP[cur]\n
        \   BMState.chars[BMState.pos] = cur\nend\n\nBMState.down = function()\n    local
        cur = BMState.chars[BMState.pos]\n    cur = BMMAP_DOWN[cur]\n    BMState.chars[BMState.pos]
        = cur\nend\n\nBMState.left = function()\n    BMState.pos = BMState.pos - 1\n
        \   if BMState.pos < 1 then\n        BMState.pos = 1\n    end\nend\n\nBMState.right
        = function()\n    BMState.pos = BMState.pos + 1\n    if BMState.pos > 20 then\n
        \       BMState.pos = 20\n    end\n    if BMState.pos > #BMState.chars then\n
        \       table.insert(BMState.chars, \"A\")\n    end\nend\n\nAutoPilotScreen.Style
        =\n    el(\n    \"style\",\n    [[\n\t    .namer { position: fixed; width:
        20vw; height: 20vh; padding: 2em; display: block; left: 45vw; top: 45vh; font-size:
        3vh; color: white; background-color: #666699ee; }\n\t    .ch { display: inline-block;
        width: 3vh; height: 3vh; text-align: center; }\n\t    .sel { background-color:
        #669966ee; }\n\t    .bookmarks { position: fixed; display: block; left: 40vw;
        top: 35vh; }\n\t    .estab { display: block; width: 15vw; height: 4vh; margin:
        0; padding: 5px; background-color: grey; font-size: 1.5vh; color: white; }\n\t
        \   .essel { background-color: yellow; color: black; }\n    ]]\n)\n\nAutoPilotScreen.onFORWARD
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.up()\n
        \       return\n    end\n    AutoPilotScreen.Choice = AutoPilotScreen.Choice
        - 1\n    if AutoPilotScreen.Choice < 1 then\n        AutoPilotScreen.Choice
        = #AutoPilotScreen.CHOICES\n    end\nend\n\nAutoPilotScreen.onBACKWARD = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        BMState.down()\n        return\n
        \   end\n    AutoPilotScreen.Choice = AutoPilotScreen.Choice + 1\n    if AutoPilotScreen.Choice
        > #AutoPilotScreen.CHOICES then\n        AutoPilotScreen.Choice = 1\n    end\nend\n\nAutoPilotScreen.onYAWLEFT
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.left()\n
        \       return\n    end\nend\n\nAutoPilotScreen.onYAWRIGHT = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        BMState.right()\n        return\n
        \   end\nend\n\nAutoPilotScreen.onLEFT = function()\n    if AutoPilotScreen.inNameEntry
        then\n        AutoPilotScreen.inNameEntry = false\n        return\n    end\n
        \   local choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\n    if
        not choice.position then\n        return\n    end\n    local now = system.getTime()\n
        \   if now - AutoPilotScreen.deleteat < 2.0 then\n        AutoPilotScreen.deleteBookmark(AutoPilotScreen.Choice,
        choice)\n    else\n        AutoPilotScreen.deleteat = now\n    end\nend\n\nAutoPilotScreen.bookmark
        = function(name)\n    local bm = {\n        name = name,\n        position
        = core.getConstructWorldPos(),\n        altitude = PHYSICS.altitude,\n        inatmo
        = PHYSICS.inAtmo,\n    }\n    AutoPilotScreen.addBookmark(bm)\nend\n\nfunction
        clearDestination()\n    databank.setStringValue(\"destination\", \"{}\")\n
        \   MainScreen.destination = {}\nend\n\nAutoPilotScreen.onUP = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        AutoPilotScreen.bookmark(table.concat(BMState.chars,
        \"\"))\n        return\n    end\n    local choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\n
        \   if choice.namer then\n        AutoPilotScreen.inNameEntry = true\n        BMState.chars
        = {\"A\"}\n        BMState.pos = 1\n        return\n    end\n    if choice.clearer
        then\n        clearDestination()\n    end\n    if not choice.position then\n
        \       return\n    end\n    databank.setStringValue(\"destination\", json.encode(choice))\n
        \   MainScreen.destination = choice\nend\n\nAutoPilotScreen.render = function()\n
        \   local tabs = {}\n    local chosen = nil\n    for i, engine in ipairs(AutoPilotScreen.CHOICES)
        do\n        local cls = \"estab\"\n        if i == AutoPilotScreen.Choice
        then\n            cls = \"estab essel\"\n            chosen = engine\n        end\n
        \       table.insert(tabs, el(\"div\", {class = cls}, engine.name))\n    end\n
        \   local bmname = \"\"\n    if AutoPilotScreen.inNameEntry then\n        bmname
        = BMState.render()\n    end\n    return AutoPilotScreen.Style .. el(\"div\",
        {class = \"bookmarks\"}, tabs) .. bmname\nend\n-- HUD Configuration\n-- This
        is loaded fairly early on, so HUD instances can\n-- register themselves with
        HUDConfig\n\nlocal HUDConfig = {\n    name = \"HUD Config\",\n    HUDS = {},\n
        \   OPTIONS = {},\n    Choice = 1,\n    ENABLED = {}\n}\n\nlocal function
        getOpt(opt)\n    if not databank.hasKey(opt.key) then\n        return opt.val\n
        \   end\n    if opt.datatype == \"bool\" then\n        return databank.getIntValue(opt.key)
        ~= 0\n    end\n    if opt.datatype == \"int\" then\n        return databank.getIntValue(opt.key)\n
        \   end\n    if opt.datatype == \"float\" then\n        return databank.getFloatValue(opt.key)\n
        \   end\nend\nlocal function setOpt(opt, val)\n    opt.hud.opts[opt.id] =
        val\n    if opt.datatype == \"bool\" then\n        databank.setIntValue(opt.key,
        val and 1 or 0)\n    end\n    if opt.datatype == \"int\" then\n        return
        databank.setIntValue(opt.key, val)\n    end\n    if opt.datatype == \"float\"
        then\n        return databank.setFloatValue(opt.key, val)\n    end\nend\n\nlocal
        hudodd = false\n\nlocal HUDUI = {}\n\nHUDUI.BoolHandler = {\n    render =
        function(opt)\n        if getOpt(opt) then\n            return \"YES\"\n        else\n
        \           return \"NO\"\n        end\n    end,\n    onSpace = function(opt)\n
        \       local val = not getOpt(opt)\n        setOpt(opt, val)\n        if
        opt.onset then\n            opt.onset(opt, val)\n        end\n    end\n}\n\nHUDUI.IntHandler
        = {\n    render = function(opt)\n        local v = getOpt(opt)\n        return
        string.format(\"%d\", v)\n    end,\n    onLeft = function(opt)\n        local
        val = getOpt(opt) - opt.step\n        if val < opt.min then\n            val
        = opt.min\n        end\n        setOpt(opt, val)\n        if opt.onset then\n
        \           opt.onset(opt, val)\n        end\n    end,\n    onRight = function(opt)\n
        \       local val = getOpt(opt) + opt.step\n        if val > opt.max then\n
        \           val = opt.max\n        end\n        setOpt(opt, val)\n\n        if
        opt.onset then\n            opt.onset(opt, val)\n        end\n    end\n}\n\nfunction
        HUDConfig.setEnabled(opt, val)\n    local hud = opt.hud\n    hud.opts.enabled
        = val\n    if val then\n        HUDConfig.ENABLED[hud.name] = hud\n        if
        hud.start then\n            hud.start(hud)\n        end\n    else\n        HUDConfig.ENABLED[hud.name]
        = nil\n        if hud.stop then\n            hud.stop(hud)\n        end\n
        \   end\nend\n\nfunction HUDConfig.addHUD(hud)\n    local cls = \"heven\"\n
        \   if hudodd then\n        cls = \"hodd\"\n    end\n    hudodd = not hudodd\n
        \   table.insert(HUDConfig.HUDS, hud)\n    if type(hud.opts.enabled) == type(true)
        then\n        table.insert(\n            HUDConfig.OPTIONS,\n            {\n
        \               cls = cls, -- for HUDUI rendering and grouping\n                hud
        = hud,\n                id = \"enabled\",\n                datatype = \"bool\",\n
        \               val = hud.opts.enabled,\n                onset = HUDConfig.setEnabled,\n
        \               name = \"Enable \" .. hud.name,\n                uihandler
        = HUDUI.BoolHandler,\n                key = hud.key .. \".\" .. \"enabled\"\n
        \           }\n        )\n    end\n    if hud.config then\n        for k,
        v in pairs(hud.config) do\n            if not v.cls then\n                v.cls
        = cls\n            end\n            if not v.hud then\n                v.hud
        = hud\n            end\n            if not v.val then\n                v.val
        = hud.opts[k]\n            end\n            if not v.name then\n                v.name
        = k\n            end\n            if not v.key then\n                v.key
        = hud.key .. \".\" .. k\n            end\n            if not v.id then\n                v.id
        = k\n            end\n            table.insert(HUDConfig.OPTIONS, v)\n        end\n
        \   end\nend\n\nHUDConfig.Style =\n    el(\n    \"style\",\n    [[\n  .hudlist
        { position: fixed; display: block; left: 20vw; top: 35vh; }\n  .heven { background-color:
        #333399; }\n  .hodd { background-color: #339933; }\n  .hi { display: block;
        width: 35vw; height: 4vh; margin: 0; padding: 5px; font-size: 2vh; color:
        white; }\n  .hsel { background-color: yellow; color: black; }\n  .hv { display:
        block; float: right; margin-right: 1vw; }\n]]\n)\n\nHUDConfig.onFORWARD =
        function()\n    HUDConfig.Choice = HUDConfig.Choice - 1\n    if HUDConfig.Choice
        < 1 then\n        HUDConfig.Choice = #HUDConfig.OPTIONS\n    end\nend\n\nHUDConfig.onBACKWARD
        = function()\n    HUDConfig.Choice = HUDConfig.Choice + 1\n    if HUDConfig.Choice
        > #HUDConfig.OPTIONS then\n        HUDConfig.Choice = 1\n    end\nend\n\nHUDConfig.onYAWLEFT
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onLeft then\n        opt.uihandler.onLeft(opt)\n    end\nend\n\nHUDConfig.onYAWRIGHT
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onRight then\n        opt.uihandler.onRight(opt)\n    end\nend\n\nHUDConfig.onUP
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onSpace then\n        opt.uihandler.onSpace(opt)\n    end\nend\n\nHUDConfig.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, opt
        in ipairs(HUDConfig.OPTIONS) do\n        local cls = opt.cls .. \" hi\"\n
        \       if i == HUDConfig.Choice then\n            cls = \"hi hsel\"\n            chosen
        = opt\n        end\n        table.insert(tabs, el(\"div\", {class = cls},
        {opt.name, el(\"div\", {class = \"hv\"}, opt.uihandler.render(opt))}))\n    end\n
        \   return HUDConfig.Style .. el(\"div\", {class = \"hudlist\"}, tabs)\nend\n\nHUDConfig.start
        = function()\n    -- In here we load all data from databank for each option.\n
        \   for i, opt in pairs(HUDConfig.OPTIONS) do\n        local val = getOpt(opt)\n
        \       if opt.onset then\n            opt.onset(opt, val)\n        end\n
        \       opt.hud.opts[opt.id] = val\n    end\nend\n-- Widget HUDS from default
        ship configuration\n\nlocal function displayCategoryPanel(elements, title,
        widgettype)\n    if #elements > 0 then\n        local panel = system.createWidgetPanel(title)\n
        \       local widget = system.createWidget(panel, widgettype)\n        for
        i, el in pairs(elements) do\n            system.addDataToWidget(elements[i].getDataId(),
        widget)\n        end\n        return panel\n    end\nend\n\nlocal function
        addFuelWidget(name, varname)\n    local widget = {\n        name = \"Default
        \" .. name .. \" Widget\",\n        key = \"defaultwidget\" .. varname,\n
        \       opts = {\n            enabled = false\n        }\n    }\n\n    function
        widget.start(self)\n        self.panel = displayCategoryPanel(_G.fueltanks[varname],
        name .. \" Fuel\", \"fuel_container\")\n    end\n\n    function widget.stop(self)\n
        \       system.destroyWidgetPanel(self.panel)\n    end\n\n    HUDConfig.addHUD(widget)\nend\n\naddFuelWidget(\"Atmo\",
        \"atmo\")\naddFuelWidget(\"Space\", \"space\")\naddFuelWidget(\"Rocket\",
        \"rocket\")\n\nlocal HUDWidgetCore = {\n    name = \"Hide Controller Default\",\n
        \   key = \"defaultwidgetcore\",\n    opts = {\n        enabled = false\n
        \   }\n}\n\nfunction HUDWidgetCore.start(self)\n    unit.hide()\nend\n\nfunction
        HUDWidgetCore.stop(self)\n    unit.show()\nend\n\nHUDConfig.addHUD(HUDWidgetCore)\n--
        Damaged element display. Only visible with damage\n-- To display a lot of
        debug information related to autopilot\n\nlocal HUDDamage = {\n    name =
        \"Damage Display\",\n    key = \"damagepanel\",\n    opts = {\n        enabled
        = true,\n        posX = 50,\n        posY = 600\n    },\n    config = {\n
        \       posX = {\n            min = 0,\n            default = 50,\n            max
        = SCREEN_X,\n            datatype = \"int\",\n            uihandler = HUDUI.IntHandler,\n
        \           name = \"Position X\",\n            step = 20\n        },\n        posY
        = {\n            min = 0,\n            default = 600,\n            max = SCREEN_Y,\n
        \           datatype = \"int\",\n            uihandler = HUDUI.IntHandler,\n
        \           name = \"Position Y\",\n            step = 20\n        }\n    }\n}\n\n\nfunction
        HUDDamage.check()\n    local uids = core.getElementIdList()\n\n    local damaged
        = {}\n    for _, uid in ipairs(uids) do\n        local max = core.getElementMaxHitPointsById(uid)\n
        \       local cur = core.getElementHitPointsById(uid)\n        if cur < max
        then\n            table.insert(damaged, {core.getElementNameById(uid), cur,
        max})\n        end\n    end\n    return damaged\nend\n\nfunction HUDDamage.addData(data,
        name, val)\n    table.insert(data, el(\"tr\", {}, {\n        el(\"td\", {},
        name),\n        el(\"th\", {}, val),\n    }))\nend\n\nHUDDamage.style = [[<style>\n
        \   table.dam { display: block; position: fixed; width: 9vw; font-size: 150%;
        }\n    table.dam th { width: 3vw; height: 1vh; text-align: right; color: red;
        }\n    table.dam td { width: 5vw; height: 1vh; text-align: left; }\n</style>]]\n\nfunction
        HUDDamage.render()\n    local data = {}\n    local damaged = HUDDamage.check()\n
        \   if #damaged < 1 then\n\tHUDDamage.addData(data, \"All Systems\", \"OKAY\")\n
        \   else\n        for _, e in ipairs(damaged) do\n\t    if e[2] == 0 then\n\t\tHUDDamage.addData(data,
        e[1], \"Broken\")\n\t    else\n\t\tHUDDamage.addData(data, e[1], string.format(\"%d/%d\",
        math.floor(e[2]), math.floor(e[3])))\n\t    end\n\tend\n    end\n    return
        HUDDamage.style .. el(\"table\",\n        {\n            style = string.format(\n
        \               \"left: %dpx; top: %dpx;\",\n                HUDDamage.opts.posX,\n
        \               HUDDamage.opts.posY\n            ),\n\t    class = \"dam\",\n
        \       },\n        data\n    )\nend\n\nHUDConfig.addHUD(HUDDamage)\n-- Rezoix's
        DU-hud\n-- https://github.com/Rezoix/DU-hud\n\nlocal HUDRezoix = {\n    name
        = \"Rezoix's DU HUD\",\n    key = \"hudrezoix\",\n    opts = {\n        enabled
        = false\n    }\n}\n\nfunction HUDRezoix.render()\n    local altitude = core.getAltitude()\n
        \   local velocity = core.getVelocity()\n    local speed = vec3(velocity):len()\n
        \   local worldV = vec3(core.getWorldVertical())\n    local constrF = vec3(core.getConstructWorldOrientationForward())\n
        \   local constrR = vec3(core.getConstructWorldOrientationRight())\n    local
        constrV = vec3(core.getConstructWorldOrientationUp())\n\n    local pitch =
        gyro.getPitch()\n     --180 - getRoll(worldV, constrR, constrF)\n    local
        roll = gyro.getRoll()\n     --getRoll(worldV, constrF, constrR)\n    local
        bottomText = \"ROLL\"\n    local mode = 0\n\n    if (altitude == 0) then\n
        \       mode = 1\n    else\n        mode = 0\n    end\n\n    if (mode == 1)
        then\n        if (speed > 5) then\n            pitch = math.deg(math.atan(velocity[2],
        velocity[3])) - 90\n            roll = math.deg(math.atan(velocity[2], velocity[1]))
        - 90\n        else\n            pitch = 0\n            roll = 0\n        end\n
        \       bottomText = \"YAW\"\n    end\n\n    content =\n        [[\n        <style>\n
        \           body {margin: 0}\n            svg {display:block; position:absolute;
        top:0; left:0}\n            .majorLine {stroke:aqua;opacity:0.7;stroke-width:3;fill-opacity:0;}\n
        \           .minorLine {stroke:aqua;opacity:0.3;stroke-width:3;fill-opacity:0;}\n
        \           .text {fill:aqua;font-family:Montserrat;font-weight:bold}\n\n
        \           #space {}\n            #ecu {}\n            #atmos {}\n\n\n        </style>\n
        \       <svg height=\"100%\" width=\"100%\" viewBox=\"0 0 1920 1080\">\n            <g
        class=\"majorLine\">\n                <line x1=\"939\" y1=\"537\" x2=\"957\"
        y2=\"519\"/>\n                <line x1=\"939\" y1=\"543\" x2=\"957\" y2=\"561\"/>\n
        \               <line x1=\"981\" y1=\"537\" x2=\"963\" y2=\"519\"/>\n                <line
        x1=\"981\" y1=\"543\" x2=\"963\" y2=\"561\"/>\n\n                <line x1=\"932\"
        y1=\"540\" x2=\"945\" y2=\"540\"/>\n                <line x1=\"988\" y1=\"540\"
        x2=\"975\" y2=\"540\"/>\n                <line x1=\"960\" y1=\"512\" x2=\"960\"
        y2=\"525\"/>\n                <line x1=\"960\" y1=\"568\" x2=\"960\" y2=\"555\"/>\n\n
        \               <g style=\"opacity:0.2\">\n                    <line x1=\"920\"
        y1=\"540\" x2=\"840\" y2=\"540\"/>\n                    <line x1=\"1000\"
        y1=\"540\" x2=\"1080\" y2=\"540\"/>\n                    <line x1=\"960\"
        y1=\"500\" x2=\"960\" y2=\"470\"/>\n                    <line x1=\"960\" y1=\"580\"
        x2=\"960\" y2=\"610\"/>\n                </g>\n\n                <path d=\"M
        700 0 L 740 35 Q 960 55 1180 35 L 1220 0\"/>\n                <path d=\"M
        792 550 L 785 550 L 785 650 L 792 650\"/>\n            </g>\n\n\n            <g>\n
        \               <polygon points=\"782,540 800,535 800,545\" style=\"fill:rgb(42,
        234, 248);opacity:0.7\"/>\n                <polygon points=\"1138,540 1120,535
        1120,545\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n                <polygon
        points=\"960,725 955,707 965,707\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n
        \           </g>\n\n            <g class=\"text\">\n                <g font-size=10>\n
        \                   <text x=\"785\" y=\"530\" text-anchor=\"start\">PITCH</text>\n
        \                   <text x=\"1135\" y=\"530\" text-anchor=\"end\">PITCH</text>\n
        \                   <text x=\"960\" y=\"688\" text-anchor=\"middle\">ROLL</text>\n
        \                   <text x=\"790\" y=\"660\" text-anchor=\"start\">THRL</text>\n
        \               </g>\n                <g font-size=15>\n                    <text
        x=\"1020\" y=\"33\" text-anchor=\"middle\" id=\"space\">SPACE</text>\n                    <text
        x=\"900\" y=\"33\" text-anchor=\"middle\" id=\"atmos\">ATMOS</text>\n                    <text
        x=\"960\" y=\"35\" text-anchor=\"middle\" id=\"ecu\">ECU</text>\n                </g>\n\n
        \           </g>]]\n\n    pitchC = math.floor(pitch)\n    for i = pitchC -
        25, pitchC + 25 do\n        if (i % 10 == 0) then\n            num = i\n            if
        (num > 180) then\n                num = -180 + 10 * (i - 18)\n            elseif
        (num < -170) then\n                num = 180 + 10 * (i + 18)\n            end\n\n
        \           content =\n                content ..\n                [[<g transform=\"translate(0
        ]] ..\n                    (-i * 5 + pitch * 5) ..\n                        [[)\">\n
        \               <text x=\"745\" y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                            num ..\n                                [[</text>\n
        \               <text x=\"1175\" y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                                    num .. [[</text></g>]]\n        end\n\n
        \       len = 5\n        if (i % 10 == 0) then\n            len = 30\n        elseif
        (i % 5 == 0) then\n            len = 15\n        end\n\n        content =\n
        \           content ..\n            [[\n        <g transform=\"translate(0
        ]] ..\n                (-i * 5 + pitch * 5) ..\n                    [[)\">\n
        \           <line x1=\"]] ..\n                        (780 - len) ..\n                            [[\"
        y1=\"540\" x2=\"780\" y2=\"540\"style=\"stroke:rgb(1, 165, 177);opacity:0.3;stroke-width:3\"/>\n
        \           <line x1=\"]] ..\n                                (1140 + len)
        ..\n                                    [[\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:3\"/></g>]]\n    end\n\n    rollC = math.floor(roll)\n
        \   for i = rollC - 35, rollC + 35 do\n        if (i % 10 == 0) then\n            num
        = math.abs(i)\n            if (num > 180) then\n                num = 180
        + (180 - num)\n            end\n            content =\n                content
        ..\n                [[<g transform=\"rotate(]] ..\n                    (i
        - roll) ..\n                        [[,960,460)\">\n            <text x=\"960\"
        y=\"760\" style=\"fill:rgb(1, 165, 177);text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                            num .. [[</text></g>]]\n        end\n\n        len
        = 5\n        if (i % 10 == 0) then\n            len = 15\n        elseif (i
        % 5 == 0) then\n            len = 10\n        end\n\n        content =\n            content
        ..\n            [[<g transform=\"rotate(]] ..\n                (i - roll)
        ..\n                    [[,960,460)\">\n        <line x1=\"960\" y1=\"730\"
        x2=\"960\" y2=\"]] ..\n                        (730 + len) .. [[\" style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:2\"/></g>]]\n    end\n\n    -- -unit.getThrottle()*0.97\n
        \   content =\n        content ..\n        [[<g transform=\"translate(0 ]]
        ..\n            (-50) ..\n                [[)\">\n            <polygon points=\"788,650
        800,647 800,653\" style=\"fill:rgb(1, 165, 177);opacity:0.7\"/>\n        </g>]]\n\n
        \   content = content .. [[\n\n        </svg>\n    ]]\n    return content\nend\n\nHUDConfig.addHUD(HUDRezoix)\n--
        Compact fuel gauges\n-- To replace the big ol' ugly widget.\n\nlocal HUDFuelGauges
        = {\n    name = \"Compact Fuel Gauges\",\n    key = \"compactfuel\",\n    opts
        = {\n        enabled = false,\n        posX = 50,\n        posY = 50\n    },\n
        \   config = {\n        posX = {\n            min = 0,\n            default
        = 50,\n            max = SCREEN_X,\n            datatype = \"int\",\n            uihandler
        = HUDUI.IntHandler,\n            name = \"Position X\",\n            step
        = 20\n        },\n        posY = {\n            min = 0,\n            default
        = 50,\n            max = SCREEN_Y,\n            datatype = \"int\",\n            uihandler
        = HUDUI.IntHandler,\n            name = \"Position Y\",\n            step
        = 20\n        }\n    }\n}\n\nHUDFuelGauges.COLORS = {\n    atmo = \"#ccccff\",\n
        \   space = \"yellow\",\n    rocket = \"red\"\n}\n\nfunction HUDFuelGauges.renderTank(ft,
        tank, i)\n    local color = HUDFuelGauges.COLORS[ft]\n    local dat = json.decode(tank.getData())\n
        \   return el(\n        \"g\",\n        {\n            el(\"rect\", {y = i
        * 30, width = 100, height = 20, fill = \"#00000000\", stroke = color, rx =
        2}),\n            el(\"rect\", {y = i * 30, width = (dat.percentage), height
        = 20, fill = color, rx = 2})\n        }\n    )\nend\n\nfunction HUDFuelGauges.render()\n
        \   local tanklist = {}\n    for _, fueltype in pairs({\"atmo\", \"space\",
        \"rocket\"}) do\n        local tanks = _G.fueltanks[fueltype]\n        if
        tanks and #tanks > 0 then\n            for _, tank in ipairs(tanks) do\n                table.insert(tanklist,
        HUDFuelGauges.renderTank(fueltype, tank, #tanklist))\n            end\n        end\n
        \   end\n    return el(\n        \"svg\",\n        {\n            style =
        string.format(\n                \"display: block; position: fixed; left: %d;
        top: %d;\",\n                HUDFuelGauges.opts.posX,\n                HUDFuelGauges.opts.posY\n
        \           )\n        },\n        tanklist\n    )\nend\n\nHUDConfig.addHUD(HUDFuelGauges)\n--
        Autopilot Information Display\n-- To display a lot of debug information related
        to autopilot\n\nlocal HUDAutopilot = {\n    name = \"Autopilot Infopanel\",\n
        \   key = \"autopilotpanel\",\n    opts = {\n        enabled = false,\n        posX
        = 50,\n        posY = 200\n    },\n    config = {\n        posX = {\n            min
        = 0,\n            default = 50,\n            max = SCREEN_X,\n            datatype
        = \"int\",\n            uihandler = HUDUI.IntHandler,\n            name =
        \"Position X\",\n            step = 20\n        },\n        posY = {\n            min
        = 0,\n            default = 200,\n            max = SCREEN_Y,\n            datatype
        = \"int\",\n            uihandler = HUDUI.IntHandler,\n            name =
        \"Position Y\",\n            step = 20\n        }\n    }\n}\n\nfunction HUDAutopilot.addData(data,
        name, val)\n    table.insert(data, el(\"tr\", {}, {\n        el(\"td\", {},
        name),\n        el(\"th\", {}, val),\n    }))\nend\n\nHUDAutopilot.style =
        [[<style>\n    table.ap { display: block; position: fixed; width: 9vw; font-size:
        150%; }\n    table.ap th { width: 3vw; height: 1vh; text-align: right; }\n
        \   table.ap td { width: 5vw; height: 1vh; text-align: left; }\n</style>]]\n\nfunction
        HUDAutopilot.render()\n    local data = {}\n    if MainScreen.destination
        and MainScreen.destination.position then\n\tHUDAutopilot.addData(data, \"Destination\",
        MainScreen.destination.name)\n        local dpos = vec3(MainScreen.destination.position)\n\tlocal
        sbody = DU.getNearestBody(PHYSICS.position)\n\tlocal dbody = DU.getNearestBody(dpos)\n\tHUDAutopilot.addData(data,
        \"Body\", sbody.name)\n\tif sbody.name ~= dbody.name then\n\t    HUDAutopilot.addData(data,
        \"Target Body\", sbody.name)\n\tend\n    end\n    if not PHYSICS.inAtmo then\n\tHUDAutopilot.addData(data,
        \"Brake Dist\", Render.distance(PHYSICS.brakeDistance))\n\tHUDAutopilot.addData(data,
        \"Brake Time\", Render.time(PHYSICS.brakeTime))\n    end\n    return HUDAutopilot.style
        .. el(\"table\",\n        {\n            style = string.format(\n                \"left:
        %dpx; top: %dpx;\",\n                HUDAutopilot.opts.posX,\n                HUDAutopilot.opts.posY\n
        \           ),\n\t    class = \"ap\",\n        },\n        data\n    )\nend\n\nHUDConfig.addHUD(HUDAutopilot)\n--
        Main screen, which tabs between different modes, and\n-- keeps state across
        children.\n--\n-- We always have a ShipRunner running, even if ShipOff\n--
        ShipRunner is background\n-- Current Screen is foreground\n-- Main Tabs on
        top, always.\n\n-- MainScreen must be global for earlier files to access it.\nMainScreen
        = {\n    ShipRunner = {},\n    ShipCommand = nil,\n    Screen = ScreenStart,\n
        \   Tab = 1,\n    ACTIVE = {},\n    destination = nil\n}\n\nMainScreen.TABS
        = {\n    {name = \"Control\", isControl = true, render = function()\n        end}\n}\n\nif
        unit.isRemoteControlled() == 1 then\n    table.insert(\n        MainScreen.TABS,\n
        \       {name = \"Walk\", isWalk = true, freeze = false, render = function()\n
        \           end}\n    )\nend\n\ntable.insert(MainScreen.TABS, CommandSelect)\ntable.insert(MainScreen.TABS,
        AutoPilotScreen)\ntable.insert(MainScreen.TABS, HUDConfig)\n\n-- Control is
        active first.\nMainScreen.ACTIVE = MainScreen.TABS[1]\n\nMainScreen.onGEAR
        = function()\n    MainScreen.Tab = MainScreen.Tab + 1\n    if MainScreen.Tab
        > #MainScreen.TABS then\n        MainScreen.Tab = 1\n    end\n    MainScreen.ACTIVE
        = MainScreen.TABS[MainScreen.Tab]\n    if MainScreen.ACTIVE.isWalk then\n
        \       system.freeze(0)\n    else\n        system.freeze(1)\n    end\nend\n\nfunction
        MainScreen.setControl()\n    MainScreen.Tab = 1\n    MainScreen.ACTIVE = MainScreen.TABS[1]\nend\n\nfunction
        onFlush(secs)\n    PHYSICS.update()\n    if MainScreen.ShipCommand and MainScreen.ShipCommand.flush
        then\n        MainScreen.ShipCommand.flush(secs)\n    elseif MainScreen.ShipRunner
        and MainScreen.ShipRunner.flush then\n        MainScreen.ShipRunner.flush(secs)\n
        \   end\n    SHIP.flush()\nend\n\nfunction tabStyle()\n    return el(\n        \"style\",\n
        \       [[\n        .maintabs { position: fixed; display: block; left: 40vw;
        top: 15vh; }\n        .tab { display: inline-block; width: 5vw; height: 4vh;
        margin: 0; padding: 5px; background-color: grey; font-size: 2vh; color: white;
        }\n        .sel { background-color: yellow; color: black; }\n\t.dest { display:
        block; position: fixed; left: 45vw; top: 26vh; font-size: 2vh; color: green;
        font-weight: bold; }\n\t.info { display: block; position: fixed; left: 40vw;
        top: 20vh; font-size: 3vh; color: red; font-weight: bold; background-color:
        #66666666; }\n    ]]\n    )\nend\n\nfunction renderTabs()\n    local tabs
        = {}\n    for i, tab in ipairs(MainScreen.TABS) do\n        local cls = \"tab\"\n
        \       if i == MainScreen.Tab then\n            cls = \"tab sel\"\n        end\n
        \       table.insert(tabs, el(\"div\", {class = cls}, tab.name))\n    end\n
        \   return el(\"div\", {class = \"maintabs\"}, tabs)\nend\n\nfunction generateContent()\n
        \   local selected = MainScreen.TABS[MainScreen.Tab]\n    local subscreen
        = \"\"\n    if selected.render then\n        subscreen = selected.render()
        or \"\"\n    else\n        subscreen = \"NO RENDERER?\"\n    end\n    local
        shipcommand = \"\"\n    if MainScreen.ShipCommand then\n        shipcommand
        = el(\"div\", {class = \"info\"}, \"Executing: \" .. MainScreen.ShipCommand.name
        .. \"(Q to cancel)\")\n    end\n    local dest = \"\"\n    if MainScreen.destination
        and MainScreen.destination.name then\n        dest = el(\"div\", {class =
        \"dest\"}, \"Destination: \" .. (MainScreen.destination.name or \"None?\"))\n
        \   end\n    return el(\n        \"html\",\n        {\n            el(\n                \"head\",\n
        \               {\n                    tabStyle()\n                }\n            ),\n
        \           el(\n                \"body\",\n                {\n                    renderTabs(),\n
        \                   renderHUD(),\n                    subscreen,\n                    shipcommand,\n
        \                   dest\n                }\n            )\n        }\n    )\nend\n\nfunction
        renderHUD()\n    local ret = {}\n    for _, hud in pairs(HUDConfig.ENABLED)
        do\n        if hud.render then\n            table.insert(ret, hud.render())\n
        \       end\n    end\n    return table.concat(ret, \"\")\nend\n\nfunction
        MainScreen.start()\n    system.freeze(1)\n    system.showScreen(1)\n    if
        databank.hasKey(\"destination\") then\n        MainScreen.destination = json.decode(databank.getStringValue(\"destination\"))\n
        \   end\n    local ec = databank.getStringValue(\"ec\")\n    if ec and ec
        ~= nil and ec ~= \"\" then\n        MainScreen.ShipCommand = CommandSelect.ENGINES_NAME[ec]\n
        \       if MainScreen.ShipCommand.resume then\n            MainScreen.ShipCommand.resume()\n
        \       end\n    end\n    local eng = databank.getStringValue(\"eng\")\n    if
        not eng or eng == nil or eng == \"\" then\n        eng = ENGINE_SHIP.name\n
        \   end\n    MainScreen.ShipRunner = CommandSelect.ENGINES_NAME[eng]\n    if
        MainScreen.ShipRunner.start then\n        MainScreen.ShipRunner.start()\n
        \   end\nend\n\nlocal NEXTRENDER = 0.0\nlocal FLYTIME = 0.0\n\nfunction onUpdate(secs)\n
        \   SHIP.update()\n    if FLYTIME == 0.0 then\n        initialize()\n    end\n
        \   FLYTIME = FLYTIME + secs\n    if MainScreen.ShipRunner and MainScreen.ShipRunner.update
        then\n        if not (MainScreen.ShipCommand and MainScreen.ShipCommand.override)
        then\n            MainScreen.ShipRunner.update(secs)\n        end\n    end\n
        \   if MainScreen.ShipCommand and MainScreen.ShipCommand.update then\n        MainScreen.ShipCommand.update(secs)\n
        \   end\n    if FLYTIME > NEXTRENDER then\n        collectgarbage()\n        for
        _, hud in pairs(HUDConfig.ENABLED) do\n            if hud.update then\n                hud.update(secs)\n
        \           end\n        end\n        system.setScreen(generateContent())\n
        \       NEXTRENDER = FLYTIME + 0.1 -- 10 times a second\n    end\nend\n\nfunction
        setEngineControl(engine)\n    if engine.start then\n        engine.start()\n
        \   end\n    MainScreen.ShipRunner = engine\n    databank.setStringValue(\"eng\",
        engine.name)\nend\n\nfunction clearEngineCommand()\n    if MainScreen.ShipCommand
        and MainScreen.ShipCommand.stop then\n        MainScreen.ShipCommand.stop()\n
        \   end\n    databank.setStringValue(\"ec\", \"\")\n    MainScreen.ShipCommand
        = nil\nend\n\nfunction setEngineCommand(cmd)\n    if cmd.start then\n        cmd.start()\n
        \   end\n    databank.setStringValue(\"ec\", cmd.name)\n    MainScreen.ShipCommand
        = cmd\nend\n\n-- Input from the player comes through here\nfunction press(s)\n
        \   if s == \"GEAR\" then\n        MainScreen.onGEAR()\n        return\n    end\n
        \   local listener = MainScreen.ACTIVE\n    if s == \"LEFT\" and MainScreen.ShipCommand
        and listener.isControl then\n        clearEngineCommand()\n        return\n
        \   end\n    if listener.isWalk then\n        return\n    end\n    if listener.isControl
        then\n        if MainScreen.ShipCommand then\n            listener = MainScreen.ShipCommand\n
        \       end\n        if not listener.override_controls then\n            PHYSICS.PRESSED[s]
        = true\n            listener = MainScreen.ShipRunner\n        end\n    end\n
        \   local kb = \"start\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   end\nend\nfunction release(s)\n    if s == \"GEAR\" then\n        return\n
        \   end\n    local listener = MainScreen.ACTIVE\n    if listener.isWalk then\n
        \       return\n    end\n    if listener.isControl then\n        PHYSICS.PRESSED[s]
        = nil\n        listener = MainScreen.ShipRunner\n    end\n    local kb = \"stop\"
        .. s\n    local kb2 = \"on\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   elseif listener[kb2] then\n        listener[kb2]()\n    elseif listener.hit
        then\n        listener.hit(s)\n    end\nend\nfunction loopKey(s)\n    if s
        == \"GEAR\" then\n        return\n    end\n    local listener = MainScreen.ACTIVE\n
        \   if listener.isWalk then\n        return\n    end\n    if listener.isControl
        then\n        listener = MainScreen.ShipRunner\n    end\n    local kb = \"loop\"
        .. s\n    if listener[kb] then\n        listener[kb]()\n    end\nend\nfunction
        initialize()\n    system.print(\"Initializing ShipOS 0.01\")\n    PHYSICS.update()\n
        \   HUDConfig.start()\n    MainScreen.start()\n    AutoPilotScreen.reset()\n
        \   local body = DU.getNearestBody(PHYSICS.position)\n    system.print(\"Nearest:
        \" .. body.name)\nend\n"
  unit:
    start:
      lua: |-
        _G.fueltanks = {
        atmo = atmofueltank,
        space = spacefueltank,
        rocket = rocketfueltank,
        }
