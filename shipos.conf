---
name: Ship OS Conf
slots:
  databank:
    class: DatabankUnit
  atmofueltank:
    class: AtmoFuelContainer
    select: all
  spacefueltank:
    class: SpaceFuelContainer
    select: all
  rocketfueltank:
    class: RocketFuelContainer
    select: all
  gyro:
    class: GyroUnit
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  core:
    class: CoreUnit
handlers:
  system:
    actionStart:
      lua: press("ANTIGRAVITY")
      args: [antigravity]
    actionStop:
      lua: release("ANTIGRAVITY")
      args: [antigravity]
    actionStart:
      lua: press("BACKWARD")
      args: [backward]
    actionStop:
      lua: release("BACKWARD")
      args: [backward]
    actionStart:
      lua: press("BOOSTER")
      args: [booster]
    actionStop:
      lua: release("BOOSTER")
      args: [booster]
    actionLoop:
      lua: loopKey("BRAKE")
      args: [brake]
    actionStart:
      lua: press("BRAKE")
      args: [brake]
    actionStop:
      lua: release("BRAKE")
      args: [brake]
    actionStart:
      lua: press("DOWN")
      args: [down]
    actionStop:
      lua: release("DOWN")
      args: [down]
    flush:
      lua: onFlush(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("FORWARD")
      args: [forward]
    actionStop:
      lua: release("FORWARD")
      args: [forward]
    actionStart:
      lua: press("GEAR")
      args: [gear]
    actionStop:
      lua: release("GEAR")
      args: [gear]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStart:
      lua: press("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStop:
      lua: release("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStop:
      lua: release("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("LALT")
      args: [lalt]
    actionStop:
      lua: release("LALT")
      args: [lalt]
    actionStart:
      lua: press("LEFT")
      args: [left]
    actionStop:
      lua: release("LEFT")
      args: [left]
    actionStart:
      lua: press("LIGHT")
      args: [light]
    actionStop:
      lua: release("LIGHT")
      args: [light]
    actionStart:
      lua: press("LSHIFT")
      args: [lshift]
    actionStop:
      lua: release("LSHIFT")
      args: [lshift]
    actionStart:
      lua: press("RIGHT")
      args: [right]
    actionStop:
      lua: release("RIGHT")
      args: [right]
    actionLoop:
      lua: loopKey("SPEEDDOWN")
      args: [speeddown]
    actionStart:
      lua: press("SPEEDDOWN")
      args: [speeddown]
    actionStop:
      lua: release("SPEEDDOWN")
      args: [speeddown]
    actionLoop:
      lua: loopKey("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("SPEEDUP")
      args: [speedup]
    actionStop:
      lua: release("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("STOPENGINES")
      args: [stopengines]
    actionStop:
      lua: release("STOPENGINES")
      args: [stopengines]
    actionStart:
      lua: press("STRAFELEFT")
      args: [strafeleft]
    actionStop:
      lua: release("STRAFELEFT")
      args: [strafeleft]
    actionStart:
      lua: press("STRAFERIGHT")
      args: [straferight]
    actionStop:
      lua: release("STRAFERIGHT")
      args: [straferight]
    actionStart:
      lua: press("UP")
      args: [up]
    actionStop:
      lua: release("UP")
      args: [up]
    update:
      lua: onUpdate(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("WARP")
      args: [warp]
    actionStop:
      lua: release("WARP")
      args: [warp]
    actionStart:
      lua: press("YAWLEFT")
      args: [yawleft]
    actionStop:
      lua: release("YAWLEFT")
      args: [yawleft]
    actionStart:
      lua: press("YAWRIGHT")
      args: [yawright]
    actionStop:
      lua: release("YAWRIGHT")
      args: [yawright]
    start:
      lua: "local SCREEN_X = 1920\nlocal SCREEN_Y = 1080\n\nfunction ischild(tbl)\n
        \   if type(tbl) == 'string' then\n\treturn true\n    end\n    -- Or if it
        has array-style indexes.\n    for i, _ in ipairs(tbl) do\n        return true\n
        \   end\n    return false\nend\n\nfunction el(name, params, children)\n    local
        attrvals = \"\"\n    if ischild(params) then\n        children = params\n
        \   elseif params then\n        for k, v in pairs(params) do\n            k
        = k:gsub(\"%u\", function(c) return '-' .. c:lower() end)\n            attrvals
        = attrvals .. \" \" .. k .. '=\"' .. v .. '\"'\n        end\n    end\n    if
        type(children) == 'string' then\n        return string.format(\"<%s%s>%s</%s>\",
        name, attrvals, children, name)\n    elseif type(children) == 'table' then\n
        \       return string.format(\"<%s%s>%s</%s>\", name, attrvals, table.concat(children,\"\\n\"),
        name)\n    else\n        return string.format(\"<%s%s />\", name, attrvals)\n
        \   end\nend\n\nlastarg = \"\"\nfunction eldebug(arg)\n    if arg ~= lastarg
        then\n\tsystem.print(string.gsub(string.gsub(arg, \"<\", \"(\"), \">\", \")\"))\n\tlastarg
        = arg\n    end\n    return arg\nend\n-- Physics stuff used by most of the
        scripted engines.\r\n-- Axis\r\nlocal PHYSICS = {\r\n    PRESSED = {},\r\n
        \   nullvec = vec3(0.0, 0.0, 0.0),\r\n}\r\n\r\nfunction PHYSICS.keyState(key)\r\n
        \   return PHYSICS.PRESSED[key] and 1 or 0\r\nend\r\n\r\nfunction d2r(v)\r\n
        \   return v * constants.deg2rad\r\nend\r\n\r\nfunction PHYSICS.update()\r\n
        \   -- Information about the ship\r\n    local unit_data = json.decode(unit.getData())\r\n
        \   PHYSICS.maxBrakeForce = unit_data['maxBrake'] or 100000000\r\n    PHYSICS.currentSpeed
        = unit_data['speed']\r\n    PHYSICS.currentBrake = unit_data['currentBrake']\r\n
        \   PHYSICS.currentAccel = unit_data['acceleration']\r\n\r\n    -- Gravity
        and which way is 'up'\r\n    PHYSICS.worldGravity = vec3(core.getWorldGravity())\r\n
        \   PHYSICS.worldVertical = vec3(core.getWorldVertical())\r\n    PHYSICS.altitude
        = core.getAltitude()\r\n\r\n    -- Construct orientation\r\n    PHYSICS.constructUp
        = vec3(core.getConstructWorldOrientationUp())\r\n    PHYSICS.constructForward
        = vec3(core.getConstructWorldOrientationForward())\r\n    PHYSICS.constructRight
        = vec3(core.getConstructWorldOrientationRight())\r\n\r\n    PHYSICS.constructLocalUp
        = vec3(core.getConstructOrientationUp())\r\n    PHYSICS.constructLocalForward
        = vec3(core.getConstructOrientationForward())\r\n    PHYSICS.constructLocalRight
        = vec3(core.getConstructOrientationRight())\r\n\r\n    -- Ship velocity relative
        to the world\r\n    PHYSICS.constructVelocity = vec3(core.getWorldVelocity())\r\n
        \   PHYSICS.constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\r\n
        \   PHYSICS.constructVelocitySpeed = vec3(core.getWorldVelocity()):len()\r\n
        \   \r\n    -- Angular velocity\r\n    PHYSICS.constructAngularVelocity =
        vec3(core.getWorldAngularVelocity())\r\n    PHYSICS.airAngularFriction = vec3(core.getWorldAirFrictionAngularAcceleration())\r\n\r\n
        \   -- Pitch and Roll relative to the planet\r\n    -- I want pitch of 0 to
        be ship = flat, but game thinks flat = -90\r\n    PHYSICS.currentPitchDeg
        = (getRoll(PHYSICS.worldVertical, PHYSICS.constructRight, PHYSICS.constructUp)
        + 90) % 360\r\n    PHYSICS.currentRollDeg = getRoll(PHYSICS.worldVertical,
        PHYSICS.constructForward, PHYSICS.constructRight)\r\n    PHYSICS.currentYawDeg
        = getRoll(PHYSICS.worldVertical, PHYSICS.constructUp, PHYSICS.constructForward)\r\n\r\n
        \   PHYSICS.atmosphereDensity = unit.getAtmosphereDensity()\r\nend\r\n\r\nfunction
        PHYSICS.isInAtmosphere()\r\n    return PHYSICS.worldVertical:len() > 0.01
        and PHYSICS.atmosphereDensity > 0.0\r\nend\r\n\r\nfunction PHYSICS.getRotationDiff(targetRotation,
        currentRotation)\r\n    -- if targetrotation = 0 and currentRotation = 270,
        then diff should be -90,\r\n    -- not 270.\r\n    -- target: 90. current:
        120. Should return  -30\r\n    -- target: 0. current: 270 . Should return
        90\r\n    local targetDiff = (targetRotation - currentRotation) % 360\r\n
        \   if targetDiff > 180.0 then\r\n        targetDiff = -(360 - targetDiff)\r\n
        \   elseif targetDiff < -180.0 then\r\n        targetDiff = -(360 + targetDiff)\r\n
        \   end\r\n    return targetDiff\r\n\r\nend\r\nfunction PHYSICS.getRotationCorrection(targetRotation,
        currentRotation)\r\n    local targetDiff = PHYSICS.getRotationDiff(targetRotation,
        currentRotation)\r\n    -- targetDiff is >= -180 <= 180\r\n    -- If abs()
        < 10, then return 0.5, otherwise 1.0\r\n    local mul = targetDiff > 0 and
        1.0 or -1.0\r\n    if math.abs(targetDiff) < 0.1 then\r\n        return 0.0\r\n
        \   elseif math.abs(targetDiff) < 10 then\r\n        return mul * 0.1\r\n
        \   elseif math.abs(targetDiff) < 45 then\r\n        return mul * 0.5\r\n
        \   else\r\n        return mul\r\n    end\r\nend\r\n\r\n-- Rotation\r\nfunction
        PHYSICS.setRotationVelocity(angularVelocity, torqueFactor)\r\n    local angularAcceleration
        = torqueFactor * (angularVelocity - PHYSICS.constructAngularVelocity)\r\n
        \   angularAcceleration = angularAcceleration - PHYSICS.airAngularFriction
        -- Try to compensate air friction\r\n\r\n    unit.setEngineCommand('torque',
        {vec3(0.0, 0.0, 0.0):unpack()}, {angularAcceleration:unpack()}, 1, 0, '',
        '', '', 0)\r\nend\r\n\r\nfunction PHYSICS.setShipRotation(pitch, roll, yaw)\r\n
        \   local target = -pitch * PHYSICS.constructRight +\r\n                   roll
        * PHYSICS.constructForward +\r\n\t\t   yaw * PHYSICS.constructUp\r\n\r\n    PHYSICS.setRotationVelocity(target,
        2.0)\r\nend\r\nlocal SHIP = {}\n\nSHIP.plan = {\n    throttle = 0.0,\n    throttleLateral
        = 0.0,\n    throttleVertical = 0.0,\n    pitch = 0.0,\n    roll = 0.0,\n    yaw
        = 0.0,\n    brake = 0.0,\n    booster = false,\n    hoverAt = 4.0,\n}\n\nSHIP.LONGITUDINAL
        = 0\nSHIP.LATERAL = 1\nSHIP.VERTICAL = 2\n\nSHIP.TORQUE = 2.0\n\nSHIP.setVectorThrust
        = function(throttle, tags, kinematicdirection, thrustdirection)\n    local
        thrust = PHYSICS.nullvec\n    if math.abs(throttle) > 0.01 then\n        local
        maxThrust = core.getMaxKinematicsParametersAlongAxis(tags, {kinematicdirection:unpack()})\n\tlocal
        speedF, speedB, spaceF, spaceB = table.unpack(maxThrust)\n\tif not PHYSICS.isInAtmosphere()
        then\n\t    speedF, speedB = spaceF, spaceB\n\tend\n\tlocal speed = speedF\n\tif
        throttle < 0 then\n\t    speed = speedB\n\tend\n\tthrust = thrustdirection
        * speed * math.abs(throttle)\n    end\n    unit.setEngineCommand(tags, {thrust:unpack()},
        {PHYSICS.nullvec:unpack()}, true, false, '', '', '', 0)\nend\n\nSHIP.update
        = function()\n    unit.setAxisCommandValue(SHIP.LONGITUDINAL, SHIP.plan.throttle)\n
        \   unit.setAxisCommandValue(SHIP.LATERAL, SHIP.plan.throttleLateral)\n    unit.setAxisCommandValue(SHIP.VERTICAL,
        SHIP.plan.throttleVertical)\nend\n\nSHIP.flush = function()\n    SHIP.setVectorThrust(SHIP.plan.throttle,
        'thrust analog longitudinal', PHYSICS.constructLocalForward, PHYSICS.constructForward)\n
        \   SHIP.setVectorThrust(SHIP.plan.throttleLateral, 'thrust analog lateral',
        PHYSICS.constructLocalRight, PHYSICS.constructRight)\n    SHIP.setVectorThrust(SHIP.plan.throttleVertical,
        'thrust analog vertical', PHYSICS.constructLocalUp, PHYSICS.constructUp)\n\n
        \   local desiredAngularVelocity = SHIP.plan.pitch * PHYSICS.constructRight
        +\n                                   SHIP.plan.roll * PHYSICS.constructForward
        +\n\t\t\t\t   SHIP.plan.yaw * PHYSICS.constructUp\n\n    PHYSICS.setRotationVelocity(desiredAngularVelocity,
        SHIP.TORQUE)\n\n    unit.setEngineThrust('brake', SHIP.plan.brake * PHYSICS.maxBrakeForce)\n
        \   if SHIP.plan.booster then\n        -- Any non-zero value, really.\n\tunit.setEngineThrust('booster',
        100.0)\n    else\n\tunit.setEngineThrust('booster', 0.0)\n    end\n    if
        SHIP.plan.hoverAt > 0.0 then\n\tunit.activateGroundEngineAltitudeStabilization(SHIP.plan.hoverAt)\n
        \   else\n\tunit.deactivateGroundEngineAltitudeStabilization()\n    end\nend\n\nSHIP.unhover
        = function()\n    SHIP.plan.hoverAt = -1.0\nend\n\nSHIP.hover = function(amt)\n
        \   amt = amt or 10.0\n    SHIP.plan.hoverAt = amt\nend\n\nSHIP.reset = function()\n
        \   unit.setupAxisCommandProperties(0, 0)\n    SHIP.plan = {\n        throttle
        = 0.0,\n        throttleLateral = 0.0,\n\tthrottleVertical = 0.0,\n\tpitch
        = 0.0,\n\troll = 0.0,\n\tyaw = 0.0,\n\tbrake = 0.0,\n\tbooster = false,\n\thoverAt
        = 4.0,\n    }\nend\n\nSHIP.killEngines = SHIP.reset\n\nSHIP.spin = function(pitch,
        roll, yaw)\n    SHIP.plan.pitch = pitch\n    SHIP.plan.roll = roll\n    SHIP.plan.yaw
        = yaw\nend\n\nSHIP.rotateTo = function(pitch, roll, yaw)\n    if pitch ==
        nil then pitch = PHYSICS.currentPitchDeg end\n    if roll == nil then roll
        = PHYSICS.currentRollDeg end\n    if yaw == nil then yaw = PHYSICS.currentYawDeg
        end\n    pitch = PHYSICS.getRotationCorrection(pitch, PHYSICS.currentPitchDeg)\n
        \   roll = PHYSICS.getRotationCorrection(roll, PHYSICS.currentRollDeg)\n    yaw
        = PHYSICS.getRotationCorrection(yaw, PHYSICS.currentYawDeg)\n    SHIP.spin(pitch,
        roll, yaw)\nend\n\nSHIP.throttleTo = function(amt)\n    SHIP.plan.throttle
        = utils.clamp(amt, -1.0, 1.0)\nend\n\nSHIP.extendLandingGears = function()\n
        \   unit.extendLandingGears()\nend\n\nSHIP.retractLandingGears = function()\n
        \   unit.retractLandingGears()\nend\n\nSHIP.turnToHeadingAtmo = function(pitch,
        heading)\n    local targetYaw = 0.0\n    local roll = 0\n    if math.abs(heading)
        > 90 then\n        targetYaw = 0.5\n\troll = 20\n    elseif math.abs(heading)
        > 15 then\n        targetYaw = 0.2\n\troll = 10\n    elseif math.abs(heading)
        > 2 then\n        targetYaw = math.abs(heading) / 100\n\troll = 5\n      elseif
        math.abs(heading) > 0.01 then\n        targetYaw = math.abs(heading) / 100\n\troll
        = 0\n    end\n    if heading > 0 then\n        targetYaw = -targetYaw\n    else\n\troll
        = -roll\n    end\n    local pvel = PHYSICS.getRotationCorrection(pitch, PHYSICS.currentPitchDeg)\n
        \   local rvel = PHYSICS.getRotationCorrection(roll, PHYSICS.currentRollDeg)\n
        \   local yvel = targetYaw\n    SHIP.spin(pvel, rvel, yvel)\nend\n\nSHIP.stabilize
        = function()\n\tSHIP.rotateTo(0.0, 0.0, nil)\nend\n\nSHIP.brake = function(amt)\n
        \   SHIP.plan.brake = amt or 1.0\nend\n-- Flying Engine Selection screen.
        The first tab of main screen.\n-- This is loaded fairly early on, so ShipEngine
        instances can\n-- register themselves with CommandSelection.\n\nlocal CommandSelect
        = {\n    name = \"Engine\",\n    ENGINES = {},\n    ENGINES_NAME = {},\n    Choice
        = 1,\n}\n\nCommandSelect.add = function(cmd, hide)\n    if not hide then\n\ttable.insert(CommandSelect.ENGINES,
        cmd)\n    end\n    CommandSelect.ENGINES_NAME[cmd.name] = cmd\nend\n\nCommandSelect.Style
        = el('style', [[\n  .enginetabs { position: fixed; display: block; left: 20vw;
        top: 35vh; }\n  .estab { display: block; width: 15vw; height: 4vh; margin:
        0; padding: 5px; background-color: grey; font-size: 1.5vh; color: white; }\n
        \ .essel { background-color: yellow; color: black; }\n  .esdesc { position:
        fixed; display: block; left: 35vw; top: 35vh; background-color: #666666cc;
        padding: 1em; width: 30vw; height: 30vh; font-size: 2vh; }\n]])\n\nCommandSelect.onFORWARD
        = function()\n    CommandSelect.Choice = CommandSelect.Choice - 1\n    if
        CommandSelect.Choice < 1 then\n\tCommandSelect.Choice = #CommandSelect.ENGINES\n
        \   end\nend\n\nCommandSelect.onBACKWARD = function()\n    CommandSelect.Choice
        = CommandSelect.Choice + 1\n    if CommandSelect.Choice > #CommandSelect.ENGINES
        then\n\tCommandSelect.Choice = 1\n    end\nend\n\nCommandSelect.onUP = function()\n
        \   local choice = CommandSelect.ENGINES[CommandSelect.Choice]\n    system.print(\"selecting
        engine\")\n    if choice.isEngine then\n\tsetEngineControl(choice)\n    else\n
        \       setEngineCommand(choice)\n    end\n    MainScreen.setControl()\nend\n\nCommandSelect.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, engine
        in ipairs(CommandSelect.ENGINES) do\n\tlocal cls = 'estab'\n\tif i == CommandSelect.Choice
        then\n\t    cls = 'estab essel'\n\t    chosen = engine\n\tend\n\ttable.insert(tabs,
        el('div', {class=cls}, engine.name))\n    end\n    return CommandSelect.Style
        .. el('div', {class='enginetabs'}, tabs) .. el('div', {class=\"esdesc\"},
        chosen.desc)\nend\nlocal EC_LAND = {\n    name = 'Land Ship',\n    desc =
        [[\n1) Shut off all thrust engines. Turn on all brakes.<br>\n2) Stabilize
        pitch and Roll to 0.<br>\n3) Extend landing gears.<br>\n4) Lower Altitude
        Stabilization to zero.<br>\n5) Shut down altitude stabilizers.\n]],\n    override
        = false,\n}\n\nEC_LAND.start = function()\n    -- BRAKE ALL THE THINGS, but
        only if speed is low. If we are going fast, we\n    -- may be coasting.\n\n
        \   EC_LAND.stage = 'stabilize'\n    SHIP.killEngines()\nend\n\nEC_LAND.resume
        = function()\n    EC_LAND.stage = 'done'\n    SHIP.unhover()\nend\n\nEC_LAND.stop
        = function()\nend\n\nEC_LAND.flush = function(secs)\n    if EC_LAND.stage
        ~= \"done\" then\n\tSHIP.stabilize()\n    else\n\tSHIP.killEngines()\n\tSHIP.unhover()\n
        \   end\n    if math.abs(PHYSICS.constructVelocitySpeed) > 0.2 then\n        SHIP.brake()\n
        \   end\n    if EC_LAND.stage == 'stabilize' then\n        if math.abs(PHYSICS.getRotationDiff(PHYSICS.currentPitchDeg,
        0)) < 2.0 and\n            math.abs(PHYSICS.getRotationDiff(PHYSICS.currentRollDeg,
        0)) < 2.0 then\n\t    SHIP.extendLandingGears()\n\t    EC_LAND.stage = \"extend\"\n\t
        \   EC_LAND.timer = 0.0\n\tend\n    end\n    if EC_LAND.stage == 'extend'
        then\n\tEC_LAND.timer = EC_LAND.timer + secs\n        if EC_LAND.timer > 3.0
        then\n\t    system.print(\"extended\")\n\t    EC_LAND.stage = 'lower'\n\t
        \   EC_LAND.timer = 0\n\t    SHIP.hover(1.0)\n\tend\n    end\n    if EC_LAND.stage
        == 'lower' then\n        if math.abs(PHYSICS.constructVelocitySpeed) < 0.4
        then\n\t    system.print(\"lowered, finished\")\n\t    EC_LAND.stage = 'done'\n\t
        \   SHIP.killEngines()\n\t    SHIP.unhover()\n\t    clearEngineCommand()\n\tend\n
        \   end\nend\n\nCommandSelect.add(EC_LAND)\nlocal EC_HOVER = {\n    name =
        'Hover',\n    desc = [[\n1) Engage all brakes\n2) Set hover to 30 meters\n3)
        Rotate to be as flat as possible\n]],\n    override = false,\n    runtime
        = 0.0,\n}\n\nEC_HOVER.start = function()\n    -- BRAKE ALL THE THINGS, but
        only if speed is low. If we are going fast, we\n    -- may be coasting.\n\n
        \   SHIP.retractLandingGears()\n    EC_HOVER.runtime = 0.0\nend\n\nEC_HOVER.resume
        = EC_HOVER.start\n\nEC_HOVER.stop = function()\nend\n\nEC_HOVER.flush = function(secs)\n
        \   EC_HOVER.runtime = EC_HOVER.runtime + secs\n    SHIP.stabilize()\n    SHIP.brake()\n
        \   SHIP.hover(30)\n    if EC_HOVER.runtime > 3.0 and math.abs(PHYSICS.constructVelocitySpeed)
        < 0.2 then\n\tclearEngineCommand()\n    end\nend\n\nCommandSelect.add(EC_HOVER)\nlocal
        EC_AUTOPILOT = {\n    name = 'Autopilot',\n    desc = [[\nEngage autopilot.
        Destination: (Select destination from autopilot menu)\n]],\n    desctemplate
        = [[\nEngage autopilot. Destination: %s.\n]],\n    override = false,\n\n    callbacks
        = {},\n    announcements = {},\n    time = 0.0,\n    throttle = 0.4,\n    arrived
        = false,\n}\n\nEC_AUTOPILOT.start = function()\n    EC_AUTOPILOT.time = 0.0\n
        \   EC_AUTOPILOT.arrived = false\n    EC_AUTOPILOT.announcements = {}\n    EC_AUTOPILOT.recalculate()\nend\n\nEC_AUTOPILOT.announce
        = function(msg)\n    if EC_AUTOPILOT.announcements[msg] then return end\n
        \   EC_AUTOPILOT.announcements[msg] = true\n    system.print(\"ANNOUNCEMENT:
        \" .. msg)\nend\n\nEC_AUTOPILOT.resume = EC_AUTOPILOT.start\n\nEC_AUTOPILOT.stop
        = function()\nend\n\n-- This is called twice a second\nEC_AUTOPILOT.recalculate
        = function()\n    if not databank.hasKey('destination') then return end\n
        \   EC_AUTOPILOT.callbacks = {}\n    -- This is the meat of autopilot.\n    --
        To start: discover our position relative to destination, our status\n    --
        \   (in atmo safe, in space safe, in space approaching, in atmo approaching)\n
        \   -- Then, determine which do we want to do:\n    --     - Brake and stop
        if we are close enough\n    --     - Determine if we are in-atmosphere or
        not\n    --     - Near, in atmo: Cross-planetary plotting\n    --     - Destination
        extraplanetary, in atmo: Take off.\n    --     - Approaching planet from space?
        YIKES.\n    --         - Be very conservative when approaching a space destination.\n
        \   --     - In space: Determine: speed up or slow down, and in which angle\n
        \   local destination = MainScreen.destination\n    if not (destination and
        destination.name) then\n\tclearEngineCommand()\n\treturn\n    end\n    local
        dpos = vec3(destination.position)\n    local mypos = vec3(core.getConstructWorldPos())\n
        \   local vdiff = dpos - mypos\n    local dist = vdiff:len()\n    EC_AUTOPILOT.announce(\"Plotting
        route for \" .. math.floor(dist / 1000) .. \"km\")\n    local inatmo = PHYSICS.isInAtmosphere()\n\n
        \   local cbs = EC_AUTOPILOT.callbacks\n\n    -- vdiff also defines what vector
        we want to aim at.\n    -- If we're in atmo, though, we only want the yaw
        heading.\n    local yaw_heading = getRoll(vdiff, PHYSICS.constructUp, PHYSICS.constructRight)\n
        \   local altDiff = PHYSICS.altitude - destination.altitude\n\n    SHIP.retractLandingGears()\n\n
        \   if inatmo and dist < 200000.0 and destination.inatmo then\n\n\tlocal flatdist
        = math.sqrt(dist*dist - altDiff*altDiff)\n\n\tlocal desiredAltitude = 0.0\n\n\t--
        Still experimenting between speed and throttle\n\tlocal desiredSpeed = 0.0\n\tlocal
        desiredThrottle = 0.0\n\n        if EC_AUTOPILOT.arrived and PHYSICS.currentSpeed
        < 1.0 then\n\t    table.insert(cbs, {clearEngineCommand})\n\t    table.insert(cbs,
        {clearDestination})\n\t    table.insert(cbs, {setEngineCommand, EC_LAND})\n
        \       elseif EC_AUTOPILOT.arrived or flatdist < 15.0 then\n\t    EC_AUTOPILOT.arrived
        = true\n\t    table.insert(cbs, {SHIP.stabilize})\n\t    table.insert(cbs,
        {SHIP.throttleTo, 0.0})\n\t    table.insert(cbs, {SHIP.killEngines})\n\t    table.insert(cbs,
        {SHIP.brake, 1.0})\n\t    table.insert(cbs, {SHIP.hover, 10})\n\t    return\n\telseif
        flatdist < 50.0 then\n\t    desiredThrottle = 0.1\n\t    desiredSpeed = 20.0\n\t
        \   desiredAltitude = destination.altitude + 10\n\telseif flatdist < 400.0
        then\n\t    desiredThrottle = 0.2\n\t    desiredSpeed = 60.0\n\t    desiredAltitude
        = destination.altitude + 20\n\telseif flatdist < 600.0 then\n\t    desiredThrottle
        = 0.2\n\t    desiredSpeed = 80.0\n\t    desiredAltitude = destination.altitude
        + 60\n\telseif flatdist < 1000 then\n\t    desiredThrottle = 0.3\n\t    desiredAltitude
        = destination.altitude + 100\n\t    desiredSpeed = 80.0\n\telseif flatdist
        < 2000 then\n\t    desiredThrottle = 0.6\n\t    desiredAltitude = destination.altitude
        + 200\n\t    desiredSpeed = 1000.0\n\telseif flatdist < 5000 then\n\t    desiredThrottle
        = 1.0\n\t    desiredAltitude = destination.altitude + 600\n\t    desiredSpeed
        = 1000.0\n\telse\n\t    desiredThrottle = 1.0\n\t    desiredAltitude = destination.altitude
        + 800\n\t    desiredSpeed = 1000.0\n\tend\n\n\tlocal vertdiff = desiredAltitude
        - PHYSICS.altitude\n\n\tlocal pitch = 0.0\n\tlocal brakeTo = 0.0\n\n\tif PHYSICS.currentSpeed
        - desiredSpeed > 60 then\n\t    brakeTo = 1.0\n\telseif PHYSICS.currentSpeed
        - desiredSpeed > 10 then\n\t    brakeTo = 0.4\n\telse\n\t    brakeTo = 0.0\n\tend\n
        \       \n\tif vertdiff > 40 then\n\t    pitch = 15.0\n\telseif vertdiff >
        -40 then\n\t    pitch = 5.0\n\telse\n\t    pitch = -12.0\n\t    brakeTo =
        0.4\n\tend\n\n\tEC_AUTOPILOT.throttle = utils.clamp(desiredThrottle, 0.0,
        1.0)\n\n        -- Cross-planetary travel\n\ttable.insert(cbs, {SHIP.turnToHeadingAtmo,
        pitch, yaw_heading})\n\ttable.insert(cbs, {SHIP.hover, 30})\n\ttable.insert(cbs,
        {SHIP.throttleTo, EC_AUTOPILOT.throttle})\n\ttable.insert(cbs, {SHIP.brake,
        brakeTo})\n    else\n        EC_AUTOPILOT.announce(\"Interplanetary travel
        TBD\")\n    end\n    \nend\n\nEC_AUTOPILOT.update = function(secs)\n    local
        now = EC_AUTOPILOT.time + (secs * 2)\n    if math.floor(EC_AUTOPILOT.time)
        ~= math.floor(now) then\n        EC_AUTOPILOT.recalculate()\n    end\n    EC_AUTOPILOT.time
        = now\nend\n\nEC_AUTOPILOT.flush = function(secs)\n    for i, cbs in ipairs(EC_AUTOPILOT.callbacks)
        do\n        local cb = cbs[1]\n        cb(table.unpack(cbs, 2, #cbs))\n    end\nend\n\nCommandSelect.add(EC_AUTOPILOT)\nlocal
        ENGINE_SHIP = {\r\n    name = 'Control engine using the SHIP shiplib',\r\n
        \   desc = [[Pretty much the same as default, but clearer in code for me.]],\r\n
        \   isEngine = true,\r\n}\r\n\r\nfunction ENGINE_SHIP.start()\r\n    system.print(\"Setting
        throttle info\")\r\n    SHIP.reset()\r\nend\r\n\r\nfunction ENGINE_SHIP.onSTOPENGINES()\r\n
        \   SHIP.killEngines()\r\nend\r\n\r\nfunction ENGINE_SHIP.onBOOSTER()\r\n
        \   SHIP.plan.booster = not SHIP.plan.booster\r\nend\r\n\r\nfunction ENGINE_SHIP.startSPEEDDOWN()\r\n
        \   ENGINE_SHIP.alterSpeed(-0.1)\r\nend\r\n\r\nfunction ENGINE_SHIP.startSPEEDUP()\r\n
        \   ENGINE_SHIP.alterSpeed(0.1)\r\nend\r\n\r\nfunction ENGINE_SHIP.alterSpeed(amt)\r\n
        \   local cur = SHIP.plan.throttle + amt\r\n    if cur > 1.0 then cur = 1.0
        end\r\n    if cur < -1.0 then cur = -1.0 end\r\n    SHIP.plan.throttle = cur\r\nend\r\n\r\nfunction
        ENGINE_SHIP.update(secs)\r\n    local amt = system.getThrottleInputFromMouseWheel()\r\n
        \   if math.abs(amt) > 0.01 then\r\n      ENGINE_SHIP.alterSpeed(0.1 * amt)\r\n
        \   end\r\nend\r\n\r\nfunction ENGINE_SHIP.onLIGHT()\r\n    if unit.isAnyHeadlightSwitchedOn()
        == 1 then\r\n        unit.switchOffHeadlights()\r\n    else\r\n\tunit.switchOnHeadlights()\r\n
        \   end\r\nend\r\n\r\nfunction ENGINE_SHIP.startGROUNDALTITUDEUP()\r\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\r\n    if SHIP.plan.hoverAt > 50.0 then SHIP.plan.hoverAt
        = 50.0 end\r\nend\r\n\r\nfunction ENGINE_SHIP.loopGROUNDALTITUDEUP()\r\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\r\n    if SHIP.plan.hoverAt > 50.0 then SHIP.plan.hoverAt
        = 50.0 end\r\nend\r\n\r\nfunction ENGINE_SHIP.startGROUNDALTITUDEDOWN()\r\n
        \   SHIP.plan.hoverAt = SHIP.plan.hoverAt - 1.0\r\n    if SHIP.plan.hoverAt
        < 1.0 then SHIP.plan.hoverAt = 1.0 end\r\nend\r\n\r\nfunction ENGINE_SHIP.loopGROUNDALTITUDEDOWN()\r\n
        \   SHIP.plan.hoverAt = SHIP.plan.hoverAt - 1.0\r\n    if SHIP.plan.hoverAt
        < 1.0 then SHIP.plan.hoverAt = 1.0 end\r\nend\r\n\r\nfunction ENGINE_SHIP.onWARP()\r\n
        \   if warpdrive ~= nil then\r\n        warpdrive.activateWarp()\r\n    end\r\nend\r\n\r\nfunction
        ENGINE_SHIP.onANTIGRAVITY()\r\n    if antigrav ~= nil then\r\n        antigrav.toggle()\r\n
        \   end\r\nend\r\n\r\nfunction ENGINE_SHIP.flush(secs)\r\n    -- OVERRIDE
        by shipos\r\n    local pitchInput = PHYSICS.keyState('BACKWARD') - PHYSICS.keyState('FORWARD')\r\n
        \   local rollInput = PHYSICS.keyState('RIGHT') - PHYSICS.keyState('LEFT')\r\n
        \   local yawInput = PHYSICS.keyState('YAWLEFT') - PHYSICS.keyState('YAWRIGHT')\r\n\r\n
        \   SHIP.plan.throttleLateral = PHYSICS.keyState('STRAFERIGHT') - PHYSICS.keyState('STRAFELEFT')\r\n
        \   SHIP.plan.throttleVertical = PHYSICS.keyState('UP') - PHYSICS.keyState('DOWN')\r\n\r\n
        \   local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\r\n
        \   local finalRollInput = rollInput + system.getControlDeviceYawInput()\r\n
        \   local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\r\n
        \   local finalBrakeInput = PHYSICS.keyState('BRAKE')\r\n\r\n    SHIP.spin(finalPitchInput,
        finalRollInput, finalYawInput)\r\n\r\n    SHIP.brake(finalBrakeInput)\r\nend\r\n\r\nCommandSelect.add(ENGINE_SHIP,
        true)\r\n-- Autopilot Screen\n-- This is for managing autopilot information.\n--
        1. Bookmark current location, with 5-character name\n-- 2. List of bookmarks
        to go to.\n\nlocal AutoPilotScreen = {\n    name = \"Autopilot\",\n    CHOICES
        = {},\n    Choice = 1,\n    inNameEntry = false,\n}\n\nAutoPilotScreen.reset
        = function()\n    AutoPilotScreen.CHOICES = {\n        {namer=true, name=\"Bookmark
        Current Location\"},\n        {clearer=true, name=\"Clear set destination\"},\n
        \   }\n    AutoPilotScreen.Choice = 1\n    AutoPilotScreen.inNameEntry = false\n\n
        \   local bms = AutoPilotScreen.getBookmarks()\n    for _, bm in ipairs(bms)
        do\n        table.insert(AutoPilotScreen.CHOICES, bm)\n    end\nend\n\nAutoPilotScreen.getBookmarks
        = function()\n    if databank.hasKey(\"bookmarks\") then\n\tlocal ret = nil\n\tif
        pcall(function()\n\t    local s = databank.getStringValue(\"bookmarks\")\n\t
        \   ret = json.decode(s)\n\tend) then\n\t    if type(ret) == 'table' then\n\t
        \       return ret\n\t    end\n\tend\n    end\n    return {}\nend\n\nAutoPilotScreen.addBookmark
        = function(bm)\n    local bms = AutoPilotScreen.getBookmarks()\n    table.insert(bms,
        bm)\n    databank.setStringValue(\"bookmarks\", json.encode(bms))\n    AutoPilotScreen.reset()\nend\n\nlocal
        BMState = {\n    chars = {'A'},\n    pos = 1,\n}\n\nlocal BMMAP_DOWN = {\n
        \ ['A'] = 'B', ['B'] = 'C', ['C'] = 'D', ['D'] = 'E', ['E'] = 'F', ['F'] =
        'G', ['G'] = 'H',\n  ['H'] = 'I', ['I'] = 'J', ['J'] = 'K', ['K'] = 'L', ['L']
        = 'M', ['M'] = 'N', ['N'] = 'O',\n  ['O'] = 'P', ['P'] = 'Q', ['Q'] = 'R',
        ['R'] = 'S', ['S'] = 'T', ['T'] = 'U', ['U'] = 'V',\n  ['V'] = 'W', ['W']
        = 'X', ['X'] = 'Y', ['Y'] = 'Z', ['Z'] = '1', ['1'] = '2', ['2'] = '3',\n
        \ ['3'] = '4', ['4'] = '5', ['5'] = '6', ['6'] = '7', ['7'] = '8', ['8'] =
        '9', ['9'] = '0',\n  ['0'] = ' ', [' '] = 'A',\n}\n\nlocal BMMAP_UP = {\n
        \ ['A'] = ' ', ['B'] = 'A', ['C'] = 'B', ['D'] = 'C', ['E'] = 'D', ['F'] =
        'E', ['G'] = 'F',\n  ['H'] = 'G', ['I'] = 'H', ['J'] = 'I', ['K'] = 'J', ['L']
        = 'K', ['M'] = 'L', ['N'] = 'M',\n  ['O'] = 'N', ['P'] = 'O', ['Q'] = 'P',
        ['R'] = 'Q', ['S'] = 'R', ['T'] = 'S', ['U'] = 'T',\n  ['V'] = 'U', ['W']
        = 'V', ['X'] = 'W', ['Y'] = 'X', ['Z'] = 'Y', ['1'] = 'Z', ['2'] = '1',\n
        \ ['3'] = '2', ['4'] = '3', ['5'] = '4', ['6'] = '5', ['7'] = '6', ['8'] =
        '7', ['9'] = '8',\n  ['0'] = '9', [' '] = '0',\n}\n\nBMState.render = function()\n
        \   local chars = {}\n    for p, char in ipairs(BMState.chars) do\n        table.insert(chars,
        el(\"div\", {class=(p == BMState.pos and 'sel ch' or 'ch')}, char))\n    end\n\n
        \   return el(\"div\", {class=\"namer\"},\n        [[<p>Enter a name: A =
        prev char D = next char, S = abc, W = zyx.</p>]] ..\n        table.concat(chars,
        '') ..\n        [[<p>Press space to add bookmark</p>]]\n    )\nend\n\nBMState.up
        = function()\n    local cur = BMState.chars[BMState.pos]\n    cur = BMMAP_UP[cur]\n
        \   BMState.chars[BMState.pos] = cur\nend\n\nBMState.down = function()\n    local
        cur = BMState.chars[BMState.pos]\n    cur = BMMAP_DOWN[cur]\n    BMState.chars[BMState.pos]
        = cur\nend\n\nBMState.left = function()\n    BMState.pos = BMState.pos - 1\n
        \   if BMState.pos < 1 then\n        BMState.pos = 1\n    end\nend\n\nBMState.right
        = function()\n    BMState.pos = BMState.pos + 1\n    if BMState.pos > 20 then\n
        \       BMState.pos = 20\n    end\n    if BMState.pos > #BMState.chars then\n
        \       table.insert(BMState.chars, 'A')\n    end\nend\n\nAutoPilotScreen.Style
        = el('style', [[\n  .namer { position: fixed; width: 20vw; height: 20vh; padding:
        2em; display: block; left: 45vw; top: 45vh; font-size: 3vh; color: white;
        background-color: #666699ee; }\n  .ch { display: inline-block; width: 3vh;
        height: 3vh; text-align: center; }\n  .sel { background-color: #669966ee;
        }\n  .bookmarks { position: fixed; display: block; left: 40vw; top: 35vh;
        }\n  .estab { display: block; width: 15vw; height: 4vh; margin: 0; padding:
        5px; background-color: grey; font-size: 1.5vh; color: white; }\n  .essel {
        background-color: yellow; color: black; }\n]])\n\nAutoPilotScreen.onFORWARD
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.up()\n
        \       return\n    end\n    AutoPilotScreen.Choice = AutoPilotScreen.Choice
        - 1\n    if AutoPilotScreen.Choice < 1 then\n\tAutoPilotScreen.Choice = #AutoPilotScreen.CHOICES\n
        \   end\nend\n\nAutoPilotScreen.onBACKWARD = function()\n    if AutoPilotScreen.inNameEntry
        then\n        BMState.down()\n        return\n    end\n    AutoPilotScreen.Choice
        = AutoPilotScreen.Choice + 1\n    if AutoPilotScreen.Choice > #AutoPilotScreen.CHOICES
        then\n\tAutoPilotScreen.Choice = 1\n    end\nend\n\nAutoPilotScreen.onYAWLEFT
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.left()\n
        \       return\n    end\nend\n\nAutoPilotScreen.onYAWRIGHT = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        BMState.right()\n        return\n
        \   end\nend\n\nAutoPilotScreen.onLEFT = function()\n    if AutoPilotScreen.inNameEntry
        then\n        AutoPilotScreen.inNameEntry = false\n        return\n    end\nend\n\nAutoPilotScreen.bookmark
        = function(name)\n    local bm = {\n\tname = name,\n\tposition = core.getConstructWorldPos(),\n\taltitude
        = core.getAltitude(),\n\tinatmo = PHYSICS.isInAtmosphere(),\n    }\n    AutoPilotScreen.addBookmark(bm)\nend\n\nfunction
        clearDestination()\n    databank.setStringValue('destination', '{}')\n    MainScreen.destination
        = {}\nend\n\nAutoPilotScreen.onUP = function()\n    if AutoPilotScreen.inNameEntry
        then\n        AutoPilotScreen.bookmark(table.concat(BMState.chars, ''))\n
        \       return\n    end\n    local choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\n
        \   if choice.namer then\n        AutoPilotScreen.inNameEntry = true\n\tBMState.chars
        = {'A'}\n\tBMState.pos = 1\n        return\n    end\n    if choice.clearer
        then\n        clearDestination()\n    end\n    if not choice.position then\n\treturn\n
        \   end\n    databank.setStringValue('destination', json.encode(choice))\n
        \   MainScreen.destination = choice\nend\n\nAutoPilotScreen.render = function()\n
        \   local tabs = {}\n    local chosen = nil\n    for i, engine in ipairs(AutoPilotScreen.CHOICES)
        do\n\tlocal cls = 'estab'\n\tif i == AutoPilotScreen.Choice then\n\t    cls
        = 'estab essel'\n\t    chosen = engine\n\tend\n\ttable.insert(tabs, el('div',
        {class=cls}, engine.name))\n    end\n    local bmname = ''\n    if AutoPilotScreen.inNameEntry
        then\n        bmname = BMState.render()\n    end\n    return AutoPilotScreen.Style
        .. el('div', {class='bookmarks'}, tabs) .. bmname\nend\n-- HUD Configuration\n--
        This is loaded fairly early on, so HUD instances can\n-- register themselves
        with HUDConfig\n\nlocal HUDConfig = {\n    name = \"HUD Config\",\n    HUDS
        = {},\n    OPTIONS = {},\n    Choice = 1,\n    ENABLED = {},\n}\n\nlocal function
        getOpt(opt)\n    if not databank.hasKey(opt.key) then\n        return opt.val\n
        \   end\n    if opt.datatype == 'bool' then\n        return databank.getIntValue(opt.key)
        ~= 0\n    end\n    if opt.datatype == 'int' then\n        return databank.getIntValue(opt.key)\n
        \   end\n    if opt.datatype == 'float' then\n        return databank.getFloatValue(opt.key)\n
        \   end\nend\nlocal function setOpt(opt, val)\n    opt.hud.opts[opt.id] =
        val\n    if opt.datatype == 'bool' then\n        databank.setIntValue(opt.key,
        val and 1 or 0)\n    end\n    if opt.datatype == 'int' then\n        return
        databank.setIntValue(opt.key, val)\n    end\n    if opt.datatype == 'float'
        then\n        return databank.setFloatValue(opt.key, val)\n    end\nend\n\nlocal
        hudodd = false\n\nlocal HUDUI = {}\n\nHUDUI.BoolHandler = {\n    render =
        function(opt)\n        if getOpt(opt) then\n\t    return \"YES\"\n\telse\n\t
        \   return \"NO\"\n\tend\n    end,\n    onSpace = function(opt)\n        local
        val = not getOpt(opt)\n        setOpt(opt, val)\n\tif opt.onset then\n\t    opt.onset(opt,
        val)\n\tend\n    end,\n}\n\nHUDUI.IntHandler = {\n    render = function(opt)\n
        \       local v = getOpt(opt)\n\treturn string.format(\"%d\", v)\n    end,\n
        \   onLeft = function(opt)\n        local val = getOpt(opt) - opt.step\n\tif
        val < opt.min then\n\t    val = opt.min\n\tend\n        setOpt(opt, val)\n\tif
        opt.onset then\n\t    opt.onset(opt, val)\n\tend\n    end,\n    onRight =
        function(opt)\n        local val = getOpt(opt) + opt.step\n\tif val > opt.max
        then\n\t    val = opt.max\n\tend\n        setOpt(opt, val)\n\n\tif opt.onset
        then\n\t    opt.onset(opt, val)\n\tend\n    end,\n}\n\nfunction HUDConfig.setEnabled(opt,
        val)\n    local hud = opt.hud\n    hud.opts.enabled = val\n    if val then\n\tHUDConfig.ENABLED[hud.name]
        = hud\n\tif hud.start then\n\t    hud.start(hud)\n\tend\n    else\n\tHUDConfig.ENABLED[hud.name]
        = nil\n\tif hud.stop then\n\t    hud.stop(hud)\n\tend\n    end\nend\n\nfunction
        HUDConfig.addHUD(hud)\n    local cls = \"heven\"\n    if hudodd then\n        cls
        = \"hodd\"\n    end\n    hudodd = not hudodd\n    table.insert(HUDConfig.HUDS,
        hud)\n    if type(hud.opts.enabled) == type(true) then\n\ttable.insert(HUDConfig.OPTIONS,
        {\n\t    cls = cls, -- for HUDUI rendering and grouping\n\t    hud = hud,\n\t
        \   id = 'enabled',\n\t    datatype = 'bool',\n\t    val = hud.opts.enabled,\n\t
        \   onset = HUDConfig.setEnabled,\n\t    name = \"Enable \" .. hud.name,\n\t
        \   uihandler = HUDUI.BoolHandler,\n\t    key = hud.key .. '.' .. 'enabled',\n\t})\n
        \   end\n    if hud.config then\n        for k, v in pairs(hud.config) do\n\t
        \ if not v.cls then v.cls = cls end\n\t  if not v.hud then v.hud = hud end\n\t
        \ if not v.val then v.val = hud.opts[k] end\n\t  if not v.name then v.name
        = k end\n\t  if not v.key then v.key = hud.key .. '.' .. k end\n\t  if not
        v.id then v.id = k end\n\t  table.insert(HUDConfig.OPTIONS, v)\n\tend\n    end\nend\n\nHUDConfig.Style
        = el('style', [[\n  .hudlist { position: fixed; display: block; left: 20vw;
        top: 35vh; }\n  .heven { background-color: #333399; }\n  .hodd { background-color:
        #339933; }\n  .hi { display: block; width: 35vw; height: 4vh; margin: 0; padding:
        5px; font-size: 2vh; color: white; }\n  .hsel { background-color: yellow;
        color: black; }\n  .hv { display: block; float: right; margin-right: 1vw;
        }\n]])\n\nHUDConfig.onFORWARD = function()\n    HUDConfig.Choice = HUDConfig.Choice
        - 1\n    if HUDConfig.Choice < 1 then\n\tHUDConfig.Choice = #HUDConfig.OPTIONS\n
        \   end\nend\n\nHUDConfig.onBACKWARD = function()\n    HUDConfig.Choice =
        HUDConfig.Choice + 1\n    if HUDConfig.Choice > #HUDConfig.OPTIONS then\n\tHUDConfig.Choice
        = 1\n    end\nend\n\nHUDConfig.onYAWLEFT = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n
        \   if opt.uihandler.onLeft then\n\topt.uihandler.onLeft(opt)\n    end\nend\n\nHUDConfig.onYAWRIGHT
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onRight then\n\topt.uihandler.onRight(opt)\n    end\nend\n\nHUDConfig.onUP
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onSpace then\n\topt.uihandler.onSpace(opt)\n    end\nend\n\nHUDConfig.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, opt
        in ipairs(HUDConfig.OPTIONS) do\n\tlocal cls = opt.cls .. ' hi'\n\tif i ==
        HUDConfig.Choice then\n\t    cls = 'hi hsel'\n\t    chosen = opt\n\tend\n\ttable.insert(tabs,
        el('div', {class=cls}, {opt.name, el('div', {class='hv'}, opt.uihandler.render(opt))}))\n
        \   end\n    return HUDConfig.Style .. el('div', {class='hudlist'}, tabs)\nend\n\nHUDConfig.start
        = function()\n  -- In here we load all data from databank for each option.\n
        \ for i, opt in pairs(HUDConfig.OPTIONS) do\n      local val = getOpt(opt)\n
        \     if opt.onset then\n\t  opt.onset(opt, val)\n      end\n      opt.hud.opts[opt.id]
        = val\n  end\nend\n-- Widget HUDS from default ship configuration\n\nlocal
        function displayCategoryPanel(elements, title, widgettype)\n    if #elements
        > 0 then\n        local panel = system.createWidgetPanel(title)\n\tlocal widget
        = system.createWidget(panel, widgettype)\n\tfor i, el in pairs(elements) do\n\t
        \   system.addDataToWidget(elements[i].getDataId(), widget)\n\tend\n\treturn
        panel\n    end\nend\n\nlocal function addFuelWidget(name, varname)\n  local
        widget = {\n      name = \"Default \" .. name .. \" Widget\",\n      key =
        'defaultwidget' .. varname,\n      opts = {\n\t  enabled = false,\n      },\n
        \ }\n\n  function widget.start(self)\n      self.panel = displayCategoryPanel(_G.fueltanks[varname],
        name .. \" Fuel\", \"fuel_container\")\n  end\n\n  function widget.stop(self)\n
        \     system.destroyWidgetPanel(self.panel)\n  end\n\n  HUDConfig.addHUD(widget)\nend\n\naddFuelWidget(\"Atmo\",
        \"atmo\")\naddFuelWidget(\"Space\", \"space\")\naddFuelWidget(\"Rocket\",
        \"rocket\")\n\nlocal HUDWidgetCore = {\n    name = \"Hide Controller Default\",\n
        \   key = 'defaultwidgetcore',\n    opts = {\n\tenabled = false,\n    },\n}\n\nfunction
        HUDWidgetCore.start(self)\n    unit.hide()\nend\n\nfunction HUDWidgetCore.stop(self)\n
        \   unit.show()\nend\n\nHUDConfig.addHUD(HUDWidgetCore)\n-- Rezoix's DU-hud\r\n--
        https://github.com/Rezoix/DU-hud\r\n\r\nlocal HUDRezoix = {\r\n    name =
        \"Rezoix's DU HUD\",\r\n    key = 'hudrezoix',\r\n    opts = {\r\n        enabled
        = false,\r\n    },\r\n}\r\n\r\nfunction HUDRezoix.render()\r\n    local altitude
        = core.getAltitude()\r\n    local velocity = core.getVelocity()\r\n    local
        speed = vec3(velocity):len()\r\n    local worldV = vec3(core.getWorldVertical())\r\n
        \   local constrF = vec3(core.getConstructWorldOrientationForward())\r\n    local
        constrR = vec3(core.getConstructWorldOrientationRight())\r\n    local constrV
        = vec3(core.getConstructWorldOrientationUp())\r\n\r\n    local pitch = gyro.getPitch()--180
        - getRoll(worldV, constrR, constrF)\r\n    local roll = gyro.getRoll()--getRoll(worldV,
        constrF, constrR)\r\n    local bottomText = \"ROLL\"\r\n    local mode = 0\r\n\r\n
        \   if (altitude == 0) then\r\n        mode = 1\r\n    else\r\n        mode
        = 0\r\n    end\r\n\r\n    if (mode == 1) then\r\n        if (speed > 5) then\r\n
        \           pitch = math.deg(math.atan(velocity[2], velocity[3])) - 90\r\n
        \           roll = math.deg(math.atan(velocity[2], velocity[1])) - 90\r\n
        \       else\r\n            pitch = 0\r\n            roll = 0\r\n        end\r\n
        \       bottomText = \"YAW\"\r\n    end\r\n\r\n    content = [[\r\n        <style>\r\n
        \           body {margin: 0}\r\n            svg {display:block; position:absolute;
        top:0; left:0}\r\n            .majorLine {stroke:aqua;opacity:0.7;stroke-width:3;fill-opacity:0;}\r\n
        \           .minorLine {stroke:aqua;opacity:0.3;stroke-width:3;fill-opacity:0;}\r\n
        \           .text {fill:aqua;font-family:Montserrat;font-weight:bold}\r\n\r\n
        \           #space {}\r\n            #ecu {}\r\n            #atmos {}\r\n\r\n\r\n
        \       </style>\r\n        <svg height=\"100%\" width=\"100%\" viewBox=\"0
        0 1920 1080\">\r\n            <g class=\"majorLine\">\r\n                <line
        x1=\"939\" y1=\"537\" x2=\"957\" y2=\"519\"/>\r\n                <line x1=\"939\"
        y1=\"543\" x2=\"957\" y2=\"561\"/>\r\n                <line x1=\"981\" y1=\"537\"
        x2=\"963\" y2=\"519\"/>\r\n                <line x1=\"981\" y1=\"543\" x2=\"963\"
        y2=\"561\"/>\r\n\r\n                <line x1=\"932\" y1=\"540\" x2=\"945\"
        y2=\"540\"/>\r\n                <line x1=\"988\" y1=\"540\" x2=\"975\" y2=\"540\"/>\r\n
        \               <line x1=\"960\" y1=\"512\" x2=\"960\" y2=\"525\"/>\r\n                <line
        x1=\"960\" y1=\"568\" x2=\"960\" y2=\"555\"/>\r\n\r\n                <g style=\"opacity:0.2\">\r\n
        \                   <line x1=\"920\" y1=\"540\" x2=\"840\" y2=\"540\"/>\r\n
        \                   <line x1=\"1000\" y1=\"540\" x2=\"1080\" y2=\"540\"/>\r\n
        \                   <line x1=\"960\" y1=\"500\" x2=\"960\" y2=\"470\"/>\r\n
        \                   <line x1=\"960\" y1=\"580\" x2=\"960\" y2=\"610\"/>\r\n
        \               </g>\r\n\r\n                <path d=\"M 700 0 L 740 35 Q 960
        55 1180 35 L 1220 0\"/>\r\n                <path d=\"M 792 550 L 785 550 L
        785 650 L 792 650\"/>\r\n            </g>\r\n\r\n\r\n            <g>\r\n                <polygon
        points=\"782,540 800,535 800,545\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\r\n
        \               <polygon points=\"1138,540 1120,535 1120,545\" style=\"fill:rgb(42,
        234, 248);opacity:0.7\"/>\r\n                <polygon points=\"960,725 955,707
        965,707\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\r\n            </g>\r\n\r\n
        \           <g class=\"text\">\r\n                <g font-size=10>\r\n                    <text
        x=\"785\" y=\"530\" text-anchor=\"start\">PITCH</text>\r\n                    <text
        x=\"1135\" y=\"530\" text-anchor=\"end\">PITCH</text>\r\n                    <text
        x=\"960\" y=\"688\" text-anchor=\"middle\">ROLL</text>\r\n                    <text
        x=\"790\" y=\"660\" text-anchor=\"start\">THRL</text>\r\n                </g>\r\n
        \               <g font-size=15>\r\n                    <text x=\"1020\" y=\"33\"
        text-anchor=\"middle\" id=\"space\">SPACE</text>\r\n                    <text
        x=\"900\" y=\"33\" text-anchor=\"middle\" id=\"atmos\">ATMOS</text>\r\n                    <text
        x=\"960\" y=\"35\" text-anchor=\"middle\" id=\"ecu\">ECU</text>\r\n                </g>\r\n\r\n
        \           </g>]]\r\n\r\n\r\n    pitchC = math.floor(pitch)\r\n    for i
        = pitchC-25,pitchC+25 do\r\n        if (i%10==0) then\r\n            num =
        i\r\n            if (num > 180) then\r\n                num = -180 + 10*(i-18)\r\n
        \           elseif (num < -170) then\r\n                num = 180 + 10*(i+18)\r\n
        \           end\r\n\r\n            content = content..[[<g transform=\"translate(0
        ]]..(-i*5 + pitch*5)..[[)\">\r\n                <text x=\"745\" y=\"540\"
        style=\"fill:rgb(1, 165, 177);text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">]]..num..[[</text>\r\n
        \               <text x=\"1175\" y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">]]..num..[[</text></g>]]\r\n
        \       end\r\n\r\n        len = 5\r\n        if (i%10==0) then\r\n            len
        = 30\r\n        elseif (i%5==0) then\r\n            len = 15\r\n        end\r\n\r\n
        \       content = content..[[\r\n        <g transform=\"translate(0 ]]..(-i*5
        + pitch*5)..[[)\">\r\n            <line x1=\"]]..(780-len)..[[\" y1=\"540\"
        x2=\"780\" y2=\"540\"style=\"stroke:rgb(1, 165, 177);opacity:0.3;stroke-width:3\"/>\r\n
        \           <line x1=\"]]..(1140+len)..[[\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:3\"/></g>]]\r\n\r\n    end\r\n\r\n    rollC
        = math.floor(roll)\r\n    for i = rollC-35,rollC+35 do\r\n        if (i%10==0)
        then\r\n            num = math.abs(i)\r\n            if (num > 180) then\r\n
        \               num = 180 + (180-num)\r\n            end\r\n            content
        = content..[[<g transform=\"rotate(]]..(i - roll)..[[,960,460)\">\r\n            <text
        x=\"960\" y=\"760\" style=\"fill:rgb(1, 165, 177);text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">]]..num..[[</text></g>]]\r\n
        \       end\r\n\r\n        len = 5\r\n        if (i%10==0) then\r\n            len
        = 15\r\n        elseif (i%5==0) then\r\n            len = 10\r\n        end\r\n\r\n
        \       content = content..[[<g transform=\"rotate(]]..(i - roll)..[[,960,460)\">\r\n
        \       <line x1=\"960\" y1=\"730\" x2=\"960\" y2=\"]]..(730+len)..[[\" style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:2\"/></g>]]\r\n    end\r\n\r\n    -- -unit.getThrottle()*0.97\r\n
        \   content = content..[[<g transform=\"translate(0 ]]..(-50)..[[)\">\r\n
        \           <polygon points=\"788,650 800,647 800,653\" style=\"fill:rgb(1,
        165, 177);opacity:0.7\"/>\r\n        </g>]]\r\n\r\n\r\n    content = content..[[\r\n\r\n
        \       </svg>\r\n    ]]\r\n    return content\r\nend\r\n\r\nHUDConfig.addHUD(HUDRezoix)\r\n--
        Compact fuel gauges\r\n-- To replace the big ol' ugly widget.\r\n\r\nlocal
        HUDFuelGauges = {\r\n    name = \"Compact Fuel Gauges\",\r\n    key = 'compactfuel',\r\n
        \   opts = {\r\n        enabled = false,\r\n\tposX = 50,\r\n\tposY = 50,\r\n
        \   },\r\n    config = {\r\n        posX = {\r\n\t    min = 0,\r\n\t    default
        = 50,\r\n\t    max = SCREEN_X,\r\n\t    datatype = 'int',\r\n\t    uihandler
        = HUDUI.IntHandler,\r\n\t    name = \"Position X\",\r\n\t    step = 20,\r\n\t},\r\n
        \       posY = {\r\n\t    min = 0,\r\n\t    default = 50,\r\n\t    max = SCREEN_Y,\r\n\t
        \   datatype = 'int',\r\n\t    uihandler = HUDUI.IntHandler,\r\n\t    name
        = \"Position Y\",\r\n\t    step = 20,\r\n\t},\r\n    },\r\n}\r\n\r\nHUDFuelGauges.COLORS
        = {\r\n    atmo = '#ccccff',\r\n    space = 'yellow',\r\n    rocket = 'red',\r\n}\r\n\r\nfunction
        HUDFuelGauges.renderTank(ft, tank, i)\r\n    local color = HUDFuelGauges.COLORS[ft]\r\n
        \   local dat = json.decode(tank.getData())\r\n    return el(\"g\", {\r\n
        \       el(\"rect\", {y = i * 30, width = 100, height = 20, fill=\"#00000000\",
        stroke=color, rx=2}),\r\n\tel(\"rect\", {y = i * 30, width = (dat.percentage),
        height = 20, fill=color, rx=2})\r\n    })\r\nend\r\n\r\nfunction HUDFuelGauges.render()\r\n
        \   local tanklist = {}\r\n    for _, fueltype in pairs({'atmo', 'space',
        'rocket'}) do\r\n        local tanks = _G.fueltanks[fueltype]\r\n\tif tanks
        and #tanks > 0 then\r\n\t    for _, tank in ipairs(tanks) do\r\n\t\ttable.insert(tanklist,
        HUDFuelGauges.renderTank(fueltype, tank, #tanklist))\r\n\t    end\r\n\tend\r\n
        \   end\r\n    return el(\"svg\", {style=string.format(\"display: block; position:
        fixed; left: %d; top: %d;\", HUDFuelGauges.opts.posX, HUDFuelGauges.opts.posY)},
        tanklist)\r\nend\r\n\r\nHUDConfig.addHUD(HUDFuelGauges)\r\n-- Main screen,
        which tabs between different modes, and\n-- keeps state across children.\n--\n--
        We always have a ShipRunner running, even if ShipOff\n-- ShipRunner is background\n--
        Current Screen is foreground\n-- Main Tabs on top, always.\n\n-- MainScreen
        must be global for earlier files to access it.\nMainScreen = {\n    ShipRunner
        = {},\n    ShipCommand = nil,\n    Screen = ScreenStart,\n    Tab = 1,\n    ACTIVE
        = {},\n    destination = nil,\n}\n\nMainScreen.TABS = {\n  { name = 'Control',
        isControl = true, render = function() end, },\n  CommandSelect,\n  AutoPilotScreen,\n
        \ HUDConfig,\n}\n\n-- Control is active first.\nMainScreen.ACTIVE = MainScreen.TABS[1]\n\nMainScreen.onGEAR
        = function()\n    MainScreen.Tab = MainScreen.Tab + 1\n    if MainScreen.Tab
        > #MainScreen.TABS then\n\tMainScreen.Tab = 1\n    end\n    MainScreen.ACTIVE
        = MainScreen.TABS[MainScreen.Tab]\nend\n\nfunction MainScreen.setControl()\n
        \   MainScreen.Tab = 1\n    MainScreen.ACTIVE = MainScreen.TABS[1]\nend\n\nfunction
        onFlush(secs)\n    PHYSICS.update()\n    if MainScreen.ShipCommand and MainScreen.ShipCommand.flush
        then\n        MainScreen.ShipCommand.flush(secs)\n    elseif MainScreen.ShipRunner
        and MainScreen.ShipRunner.flush then\n\tMainScreen.ShipRunner.flush(secs)\n
        \   end\n    SHIP.flush()\nend\n\nfunction tabStyle()\n    return el('style',
        [[\n        .maintabs { position: fixed; display: block; left: 40vw; top:
        15vh; }\n        .tab { display: inline-block; width: 5vw; height: 4vh; margin:
        0; padding: 5px; background-color: grey; font-size: 2vh; color: white; }\n
        \       .sel { background-color: yellow; color: black; }\n\t.dest { display:
        block; position: fixed; left: 45vw; top: 26vh; font-size: 2vh; color: green;
        font-weight: bold; }\n\t.info { display: block; position: fixed; left: 40vw;
        top: 20vh; font-size: 3vh; color: red; font-weight: bold; background-color:
        #66666666; }\n    ]])\nend\n\nfunction renderTabs()\n    local tabs = {}\n
        \   for i, tab in ipairs(MainScreen.TABS) do\n        local cls = 'tab'\n
        \       if i == MainScreen.Tab then\n\t    cls = 'tab sel'\n\tend\n\ttable.insert(tabs,
        el('div', {class=cls}, tab.name))\n    end\n    return el('div', {class='maintabs'},
        tabs)\nend\n\nfunction generateContent()\n    local selected = MainScreen.TABS[MainScreen.Tab]\n
        \   local subscreen = \"\"\n    if selected.render then\n        subscreen
        = selected.render() or \"\"\n    else\n        subscreen = \"NO RENDERER?\"\n
        \   end\n    local shipcommand = \"\"\n    if MainScreen.ShipCommand then\n
        \       shipcommand = el(\"div\", {class=\"info\"}, \"Executing: \" .. MainScreen.ShipCommand.name
        .. \"(Q to cancel)\")\n    end\n    local dest = ''\n    if MainScreen.destination
        and MainScreen.destination.name then\n        dest = el('div', {class='dest'},
        \"Destination: \" .. (MainScreen.destination.name or 'None?'))\n    end\n
        \   return el('html', {el('head', {\n        tabStyle(),\n    }), el('body',
        {\n        renderTabs(),\n\trenderHUD(),\n\tsubscreen,\n\tshipcommand,\n\tdest,\n
        \   })})\nend\n\nfunction renderHUD()\n    local ret = {}\n    for _, hud
        in pairs(HUDConfig.ENABLED) do\n        if hud.render then\n\t    table.insert(ret,
        hud.render())\n\tend\n    end\n    return table.concat(ret, '')\nend\n\nfunction
        MainScreen.start()\n    system.showScreen(1)\n    if databank.hasKey('destination')
        then\n\tMainScreen.destination = json.decode(databank.getStringValue(\"destination\"))\n
        \   end\n    local ec = databank.getStringValue('ec')\n    if ec and ec ~=
        nil and ec ~= '' then\n        MainScreen.ShipCommand = CommandSelect.ENGINES_NAME[ec]\n\tif
        MainScreen.ShipCommand.resume then\n\t    MainScreen.ShipCommand.resume()\n\tend\n
        \   end\n    local eng = databank.getStringValue('eng')\n    if not eng or
        eng == nil or eng == '' then\n        eng = ENGINE_SHIP.name\n    end\n    MainScreen.ShipRunner
        = CommandSelect.ENGINES_NAME[eng]\n    if MainScreen.ShipRunner.start then\n\tMainScreen.ShipRunner.start()\n
        \   end\nend\n\nlocal NEXTRENDER = 0.0\nlocal FLYTIME = 0.0\n\nfunction onUpdate(secs)\n
        \   SHIP.update()\n    if FLYTIME == 0.0 then\n        initialize()\n    end\n
        \   FLYTIME = FLYTIME + secs\n    if MainScreen.ShipRunner and MainScreen.ShipRunner.update
        then\n        if not (MainScreen.ShipCommand and MainScreen.ShipCommand.override)
        then\n\t    MainScreen.ShipRunner.update(secs)\n\tend\n    end\n    if MainScreen.ShipCommand
        and MainScreen.ShipCommand.update then\n        MainScreen.ShipCommand.update(secs)\n
        \   end\n    if FLYTIME > NEXTRENDER then\n\tcollectgarbage()\n\tfor _, hud
        in pairs(HUDConfig.ENABLED) do\n\t    if hud.update then\n\t\thud.update(secs)\n\t
        \   end\n\tend\n\tsystem.setScreen(generateContent())\n\tNEXTRENDER = FLYTIME
        + 0.1 -- 10 times a second\n    end\nend\n\nfunction setEngineControl(engine)\n
        \   if engine.start then\n        engine.start()\n    end\n    MainScreen.ShipRunner
        = engine\n    databank.setStringValue('eng', engine.name)\nend\n\nfunction
        clearEngineCommand()\n    if MainScreen.ShipCommand and MainScreen.ShipCommand.stop
        then\n        MainScreen.ShipCommand.stop()\n    end\n    databank.setStringValue('ec',
        '')\n    MainScreen.ShipCommand = nil\nend\n\nfunction setEngineCommand(cmd)\n
        \   if cmd.start then\n        cmd.start()\n    end\n    databank.setStringValue('ec',
        cmd.name)\n    MainScreen.ShipCommand = cmd\nend\n\n-- Input from the player
        comes through here\nfunction press(s)\n    if s == 'GEAR' then\n        MainScreen.onGEAR()\n\treturn\n
        \   end\n    if s == \"LEFT\" and MainScreen.ShipCommand and MainScreen.Tab
        == 1 then\n        clearEngineCommand()\n\treturn\n    end\n    local listener
        = MainScreen.ACTIVE\n    if listener.isControl then\n        if MainScreen.ShipCommand
        then\n\t    listener = MainScreen.ShipCommand\n\tend\n\tif not listener.override_controls
        then\n\t    PHYSICS.PRESSED[s] = true\n\t    listener = MainScreen.ShipRunner\n\tend\n
        \   end\n    local kb = \"start\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   end\nend\nfunction release(s)\n    if s == 'GEAR' then return end\n    local
        listener = MainScreen.ACTIVE\n    if listener.isControl then\n        PHYSICS.PRESSED[s]
        = nil\n\tlistener = MainScreen.ShipRunner\n    end\n    local kb = \"stop\"
        .. s\n    local kb2 = \"on\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   elseif listener[kb2] then\n        listener[kb2]()\n    elseif listener.hit
        then\n        listener.hit(s)\n    end\nend\nfunction loopKey(s)\n    if s
        == 'GEAR' then return end\n    local listener = MainScreen.ACTIVE\n    if
        listener.isControl then\n\tlistener = MainScreen.ShipRunner\n    end\n    local
        kb = \"loop\" .. s\n    if listener[kb] then\n        listener[kb]()\n    end\nend\nfunction
        initialize()\n    system.print(\"Initializing ShipOS 0.01\")\n    PHYSICS.update()\n
        \   HUDConfig.start()\n    MainScreen.start()\n    AutoPilotScreen.reset()\nend\n"
  unit:
    start:
      lua: |-
        _G.fueltanks = {
        atmo = atmofueltank,
        space = spacefueltank,
        rocket = rocketfueltank,
        }
