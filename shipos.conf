---
name: Ship OS Conf
slots:
  databank:
    class: DatabankUnit
  atmofueltank:
    class: AtmoFuelContainer
    select: all
  spacefueltank:
    class: SpaceFuelContainer
    select: all
  rocketfueltank:
    class: RocketFuelContainer
    select: all
  gyro:
    class: GyroUnit
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  core:
    class: CoreUnit
handlers:
  system:
    actionStart:
      lua: press("ANTIGRAVITY")
      args: [antigravity]
    actionStop:
      lua: release("ANTIGRAVITY")
      args: [antigravity]
    actionStart:
      lua: press("BACKWARD")
      args: [backward]
    actionStop:
      lua: release("BACKWARD")
      args: [backward]
    actionStart:
      lua: press("BOOSTER")
      args: [booster]
    actionStop:
      lua: release("BOOSTER")
      args: [booster]
    actionLoop:
      lua: loopKey("BRAKE")
      args: [brake]
    actionStart:
      lua: press("BRAKE")
      args: [brake]
    actionStop:
      lua: release("BRAKE")
      args: [brake]
    actionStart:
      lua: press("DOWN")
      args: [down]
    actionStop:
      lua: release("DOWN")
      args: [down]
    flush:
      lua: onFlush(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("FORWARD")
      args: [forward]
    actionStop:
      lua: release("FORWARD")
      args: [forward]
    actionStart:
      lua: press("GEAR")
      args: [gear]
    actionStop:
      lua: release("GEAR")
      args: [gear]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStart:
      lua: press("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionStop:
      lua: release("GROUNDALTITUDEDOWN")
      args: [groundaltitudedown]
    actionLoop:
      lua: loopKey("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStop:
      lua: release("GROUNDALTITUDEUP")
      args: [groundaltitudeup]
    actionStart:
      lua: press("LALT")
      args: [lalt]
    actionStop:
      lua: release("LALT")
      args: [lalt]
    actionStart:
      lua: press("LEFT")
      args: [left]
    actionStop:
      lua: release("LEFT")
      args: [left]
    actionStart:
      lua: press("LIGHT")
      args: [light]
    actionStop:
      lua: release("LIGHT")
      args: [light]
    actionStart:
      lua: press("LSHIFT")
      args: [lshift]
    actionStop:
      lua: release("LSHIFT")
      args: [lshift]
    actionStart:
      lua: press("RIGHT")
      args: [right]
    actionStop:
      lua: release("RIGHT")
      args: [right]
    actionLoop:
      lua: loopKey("SPEEDDOWN")
      args: [speeddown]
    actionStart:
      lua: press("SPEEDDOWN")
      args: [speeddown]
    actionStop:
      lua: release("SPEEDDOWN")
      args: [speeddown]
    actionLoop:
      lua: loopKey("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("SPEEDUP")
      args: [speedup]
    actionStop:
      lua: release("SPEEDUP")
      args: [speedup]
    actionStart:
      lua: press("STOPENGINES")
      args: [stopengines]
    actionStop:
      lua: release("STOPENGINES")
      args: [stopengines]
    actionStart:
      lua: press("STRAFELEFT")
      args: [strafeleft]
    actionStop:
      lua: release("STRAFELEFT")
      args: [strafeleft]
    actionStart:
      lua: press("STRAFERIGHT")
      args: [straferight]
    actionStop:
      lua: release("STRAFERIGHT")
      args: [straferight]
    actionStart:
      lua: press("UP")
      args: [up]
    actionStop:
      lua: release("UP")
      args: [up]
    update:
      lua: onUpdate(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("WARP")
      args: [warp]
    actionStop:
      lua: release("WARP")
      args: [warp]
    actionStart:
      lua: press("YAWLEFT")
      args: [yawleft]
    actionStop:
      lua: release("YAWLEFT")
      args: [yawleft]
    actionStart:
      lua: press("YAWRIGHT")
      args: [yawright]
    actionStop:
      lua: release("YAWRIGHT")
      args: [yawright]
    start:
      lua: "local SCREEN_X = 1920\nlocal SCREEN_Y = 1080\n\nfunction ischild(tbl)\n
        \   if type(tbl) == \"string\" then\n        return true\n    end\n    --
        Or if it has array-style indexes.\n    for i, _ in ipairs(tbl) do\n        return
        true\n    end\n    return false\nend\n\nfunction el(name, params, children)\n
        \   local attrvals = \"\"\n    if ischild(params) then\n        children =
        params\n    elseif params then\n        for k, v in pairs(params) do\n            k
        =\n                k:gsub(\n                \"%u\",\n                function(c)\n
        \                   return \"-\" .. c:lower()\n                end\n            )\n
        \           attrvals = attrvals .. \" \" .. k .. '=\"' .. v .. '\"'\n        end\n
        \   end\n    if type(children) == \"string\" then\n        return string.format(\"<%s%s>%s</%s>\",
        name, attrvals, children, name)\n    elseif type(children) == \"table\" then\n
        \       return string.format(\"<%s%s>%s</%s>\", name, attrvals, table.concat(children,
        \"\\n\"), name)\n    else\n        return string.format(\"<%s%s />\", name,
        attrvals)\n    end\nend\n\nlastarg = \"\"\nfunction eldebug(arg)\n    if arg
        ~= lastarg then\n        system.print(string.gsub(string.gsub(arg, \"<\",
        \"(\"), \">\", \")\"))\n        lastarg = arg\n    end\n    return arg\nend\n--
        Physics stuff used by most of the scripted engines.\n-- Axis\nlocal PHYSICS
        = {\n    PRESSED = {},\n    nullvec = vec3(0.0, 0.0, 0.0)\n}\n\nfunction PHYSICS.keyState(key)\n
        \   return PHYSICS.PRESSED[key] and 1 or 0\nend\n\nfunction d2r(v)\n    return
        v * constants.deg2rad\nend\n\nfunction PHYSICS.update()\n    -- Information
        about the ship\n    local unit_data = json.decode(unit.getData())\n    PHYSICS.maxBrakeForce
        = unit_data[\"maxBrake\"] or 100000000\n    PHYSICS.currentSpeed = unit_data[\"speed\"]\n
        \   PHYSICS.currentBrake = unit_data[\"currentBrake\"]\n    PHYSICS.currentAccel
        = unit_data[\"acceleration\"]\n\n    -- Gravity and which way is 'up'\n    PHYSICS.worldGravity
        = vec3(core.getWorldGravity())\n    PHYSICS.worldVertical = vec3(core.getWorldVertical())\n
        \   PHYSICS.altitude = core.getAltitude()\n\n    -- Construct orientation\n
        \   PHYSICS.constructUp = vec3(core.getConstructWorldOrientationUp())\n    PHYSICS.constructForward
        = vec3(core.getConstructWorldOrientationForward())\n    PHYSICS.constructRight
        = vec3(core.getConstructWorldOrientationRight())\n\n    PHYSICS.constructLocalUp
        = vec3(core.getConstructOrientationUp())\n    PHYSICS.constructLocalForward
        = vec3(core.getConstructOrientationForward())\n    PHYSICS.constructLocalRight
        = vec3(core.getConstructOrientationRight())\n\n    -- Ship velocity relative
        to the world\n    PHYSICS.constructVelocity = vec3(core.getWorldVelocity())\n
        \   PHYSICS.constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\n
        \   PHYSICS.constructVelocitySpeed = vec3(core.getWorldVelocity()):len()\n\n
        \   -- Angular velocity\n    PHYSICS.constructAngularVelocity = vec3(core.getWorldAngularVelocity())\n
        \   PHYSICS.airAngularFriction = vec3(core.getWorldAirFrictionAngularAcceleration())\n\n
        \   -- Pitch and Roll relative to the planet\n    -- I want pitch of 0 to
        be ship = flat, but game thinks flat = -90\n    PHYSICS.currentPitchDeg =
        (getRoll(PHYSICS.worldVertical, PHYSICS.constructRight, PHYSICS.constructUp)
        + 90) % 360\n    PHYSICS.currentRollDeg = getRoll(PHYSICS.worldVertical, PHYSICS.constructForward,
        PHYSICS.constructRight)\n    PHYSICS.currentYawDeg = getRoll(PHYSICS.worldVertical,
        PHYSICS.constructUp, PHYSICS.constructForward)\n\n    PHYSICS.atmosphereDensity
        = unit.getAtmosphereDensity()\nend\n\nfunction PHYSICS.isInAtmosphere()\n
        \   return PHYSICS.worldVertical:len() > 0.01 and PHYSICS.atmosphereDensity
        > 0.0\nend\n\nfunction PHYSICS.getRotationDiff(targetRotation, currentRotation)\n
        \   -- if targetrotation = 0 and currentRotation = 270, then diff should be
        -90,\n    -- not 270.\n    -- target: 90. current: 120. Should return  -30\n
        \   -- target: 0. current: 270 . Should return 90\n    local targetDiff =
        (targetRotation - currentRotation) % 360\n    if targetDiff > 180.0 then\n
        \       targetDiff = -(360 - targetDiff)\n    elseif targetDiff < -180.0 then\n
        \       targetDiff = -(360 + targetDiff)\n    end\n    return targetDiff\nend\nfunction
        PHYSICS.getRotationCorrection(targetRotation, currentRotation)\n    local
        targetDiff = PHYSICS.getRotationDiff(targetRotation, currentRotation)\n    --
        targetDiff is >= -180 <= 180\n    -- If abs() < 10, then return 0.5, otherwise
        1.0\n    local mul = targetDiff > 0 and 1.0 or -1.0\n    if math.abs(targetDiff)
        < 0.1 then\n        return 0.0\n    elseif math.abs(targetDiff) < 10 then\n
        \       return mul * 0.1\n    elseif math.abs(targetDiff) < 45 then\n        return
        mul * 0.5\n    else\n        return mul\n    end\nend\n\n-- Rotation\nfunction
        PHYSICS.setRotationVelocity(angularVelocity, torqueFactor)\n    local angularAcceleration
        = torqueFactor * (angularVelocity - PHYSICS.constructAngularVelocity)\n    angularAcceleration
        = angularAcceleration - PHYSICS.airAngularFriction -- Try to compensate air
        friction\n\n    unit.setEngineCommand(\"torque\", {vec3(0.0, 0.0, 0.0):unpack()},
        {angularAcceleration:unpack()}, 1, 0, \"\", \"\", \"\", 0)\nend\n\nfunction
        PHYSICS.setShipRotation(pitch, roll, yaw)\n    local target = -pitch * PHYSICS.constructRight
        + roll * PHYSICS.constructForward + yaw * PHYSICS.constructUp\n\n    PHYSICS.setRotationVelocity(target,
        2.0)\nend\nlocal SHIP = {}\n\nSHIP.plan = {\n    throttle = 0.0,\n    throttleLateral
        = 0.0,\n    throttleVertical = 0.0,\n    pitch = 0.0,\n    roll = 0.0,\n    yaw
        = 0.0,\n    brake = 0.0,\n    booster = false,\n    hoverAt = 4.0\n}\n\nSHIP.LONGITUDINAL
        = 0\nSHIP.LATERAL = 1\nSHIP.VERTICAL = 2\n\nSHIP.TORQUE = 2.0\n\nSHIP.setVectorThrust
        = function(throttle, tags, kinematicdirection, thrustdirection)\n    local
        thrust = PHYSICS.nullvec\n    if math.abs(throttle) > 0.01 then\n        local
        maxThrust = core.getMaxKinematicsParametersAlongAxis(tags, {kinematicdirection:unpack()})\n
        \       local speedF, speedB, spaceF, spaceB = table.unpack(maxThrust)\n        if
        not PHYSICS.isInAtmosphere() then\n            speedF, speedB = spaceF, spaceB\n
        \       end\n        local speed = speedF\n        if throttle < 0 then\n
        \           speed = speedB\n        end\n        thrust = thrustdirection
        * speed * math.abs(throttle)\n    end\n    unit.setEngineCommand(tags, {thrust:unpack()},
        {PHYSICS.nullvec:unpack()}, true, false, \"\", \"\", \"\", 0)\nend\n\nSHIP.update
        = function()\n    unit.setAxisCommandValue(SHIP.LONGITUDINAL, SHIP.plan.throttle)\n
        \   unit.setAxisCommandValue(SHIP.LATERAL, SHIP.plan.throttleLateral)\n    unit.setAxisCommandValue(SHIP.VERTICAL,
        SHIP.plan.throttleVertical)\nend\n\nSHIP.flush = function()\n    SHIP.setVectorThrust(\n
        \       SHIP.plan.throttle,\n        \"thrust analog longitudinal\",\n        PHYSICS.constructLocalForward,\n
        \       PHYSICS.constructForward\n    )\n    SHIP.setVectorThrust(\n        SHIP.plan.throttleLateral,\n
        \       \"thrust analog lateral\",\n        PHYSICS.constructLocalRight,\n
        \       PHYSICS.constructRight\n    )\n    SHIP.setVectorThrust(\n        SHIP.plan.throttleVertical,\n
        \       \"thrust analog vertical\",\n        PHYSICS.constructLocalUp,\n        PHYSICS.constructUp\n
        \   )\n\n    local desiredAngularVelocity =\n        SHIP.plan.pitch * PHYSICS.constructRight
        + SHIP.plan.roll * PHYSICS.constructForward +\n        SHIP.plan.yaw * PHYSICS.constructUp\n\n
        \   PHYSICS.setRotationVelocity(desiredAngularVelocity, SHIP.TORQUE)\n\n    unit.setEngineThrust(\"brake\",
        SHIP.plan.brake * PHYSICS.maxBrakeForce)\n    if SHIP.plan.booster then\n
        \       -- Any non-zero value, really.\n        unit.setEngineThrust(\"booster\",
        100.0)\n    else\n        unit.setEngineThrust(\"booster\", 0.0)\n    end\n
        \   if SHIP.plan.hoverAt > 0.0 then\n        unit.activateGroundEngineAltitudeStabilization(SHIP.plan.hoverAt)\n
        \   else\n        unit.deactivateGroundEngineAltitudeStabilization()\n    end\nend\n\nSHIP.unhover
        = function()\n    SHIP.plan.hoverAt = -1.0\nend\n\nSHIP.hover = function(amt)\n
        \   amt = amt or 10.0\n    SHIP.plan.hoverAt = amt\nend\n\nSHIP.reset = function()\n
        \   unit.setupAxisCommandProperties(0, 0)\n    SHIP.plan = {\n        throttle
        = 0.0,\n        throttleLateral = 0.0,\n        throttleVertical = 0.0,\n
        \       pitch = 0.0,\n        roll = 0.0,\n        yaw = 0.0,\n        brake
        = 0.0,\n        booster = false,\n        hoverAt = 4.0\n    }\nend\n\nSHIP.killEngines
        = SHIP.reset\n\nSHIP.spin = function(pitch, roll, yaw)\n    SHIP.plan.pitch
        = pitch\n    SHIP.plan.roll = roll\n    SHIP.plan.yaw = yaw\nend\n\nSHIP.rotateTo
        = function(pitch, roll, yaw)\n    if pitch == nil then\n        pitch = PHYSICS.currentPitchDeg\n
        \   end\n    if roll == nil then\n        roll = PHYSICS.currentRollDeg\n
        \   end\n    if yaw == nil then\n        yaw = PHYSICS.currentYawDeg\n    end\n
        \   pitch = PHYSICS.getRotationCorrection(pitch, PHYSICS.currentPitchDeg)\n
        \   roll = PHYSICS.getRotationCorrection(roll, PHYSICS.currentRollDeg)\n    yaw
        = PHYSICS.getRotationCorrection(yaw, PHYSICS.currentYawDeg)\n    SHIP.spin(pitch,
        roll, yaw)\nend\n\nSHIP.throttleTo = function(amt)\n    SHIP.plan.throttle
        = utils.clamp(amt, -1.0, 1.0)\nend\n\nSHIP.extendLandingGears = function()\n
        \   unit.extendLandingGears()\nend\n\nSHIP.retractLandingGears = function()\n
        \   unit.retractLandingGears()\nend\n\nSHIP.turnToHeadingAtmo = function(pitch,
        heading)\n    local targetYaw = 0.0\n    local roll = 0\n    if math.abs(heading)
        > 90 then\n        targetYaw = 0.5\n        roll = 20\n    elseif math.abs(heading)
        > 15 then\n        targetYaw = 0.2\n        roll = 10\n    elseif math.abs(heading)
        > 5 then\n        targetYaw = math.abs(heading) / 100\n        roll = 5\n
        \   elseif math.abs(heading) > 0.01 then\n        targetYaw = math.abs(heading)
        / 100\n        roll = 0\n    end\n    if heading > 0 then\n        targetYaw
        = -targetYaw\n    else\n        roll = -roll\n    end\n    local pvel = PHYSICS.getRotationCorrection(pitch,
        PHYSICS.currentPitchDeg)\n    local rvel = PHYSICS.getRotationCorrection(roll,
        PHYSICS.currentRollDeg)\n    local yvel = targetYaw\n    SHIP.spin(pvel, rvel,
        yvel)\nend\n\nSHIP.stabilize = function()\n    SHIP.rotateTo(0.0, 0.0, nil)\nend\n\nSHIP.brake
        = function(amt)\n    SHIP.plan.brake = amt or 1.0\nend\n-- Flying Engine Selection
        screen. The first tab of main screen.\n-- This is loaded fairly early on,
        so ShipEngine instances can\n-- register themselves with CommandSelection.\n\nlocal
        CommandSelect = {\n    name = \"Engine\",\n    ENGINES = {},\n    ENGINES_NAME
        = {},\n    Choice = 1\n}\n\nCommandSelect.add = function(cmd, hide)\n    if
        not hide then\n        table.insert(CommandSelect.ENGINES, cmd)\n    end\n
        \   CommandSelect.ENGINES_NAME[cmd.name] = cmd\nend\n\nCommandSelect.Style
        =\n    el(\n    \"style\",\n    [[\n\t    .enginetabs { position: fixed; display:
        block; left: 20vw; top: 35vh; }\n\t    .estab { display: block; width: 15vw;
        height: 4vh; margin: 0; padding: 5px; background-color: grey; font-size: 1.5vh;
        color: white; }\n\t    .essel { background-color: yellow; color: black; }\n\t
        \   .esdesc { position: fixed; display: block; left: 35vw; top: 35vh; background-color:
        #666666cc; padding: 1em; width: 30vw; height: 30vh; font-size: 2vh; }\n    ]]\n)\n\nCommandSelect.onFORWARD
        = function()\n    CommandSelect.Choice = CommandSelect.Choice - 1\n    if
        CommandSelect.Choice < 1 then\n        CommandSelect.Choice = #CommandSelect.ENGINES\n
        \   end\nend\n\nCommandSelect.onBACKWARD = function()\n    CommandSelect.Choice
        = CommandSelect.Choice + 1\n    if CommandSelect.Choice > #CommandSelect.ENGINES
        then\n        CommandSelect.Choice = 1\n    end\nend\n\nCommandSelect.onUP
        = function()\n    local choice = CommandSelect.ENGINES[CommandSelect.Choice]\n
        \   system.print(\"selecting engine\")\n    if choice.isEngine then\n        setEngineControl(choice)\n
        \   else\n        setEngineCommand(choice)\n    end\n    MainScreen.setControl()\nend\n\nCommandSelect.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, engine
        in ipairs(CommandSelect.ENGINES) do\n        local cls = \"estab\"\n        if
        i == CommandSelect.Choice then\n            cls = \"estab essel\"\n            chosen
        = engine\n        end\n        table.insert(tabs, el(\"div\", {class = cls},
        engine.name))\n    end\n    return CommandSelect.Style .. el(\"div\", {class
        = \"enginetabs\"}, tabs) .. el(\"div\", {class = \"esdesc\"}, chosen.desc)\nend\nlocal
        EC_LAND = {\n    name = \"Land Ship\",\n    desc = [[\n1) Shut off all thrust
        engines. Turn on all brakes.<br>\n2) Stabilize pitch and Roll to 0.<br>\n3)
        Extend landing gears.<br>\n4) Lower Altitude Stabilization to zero.<br>\n5)
        Shut down altitude stabilizers.\n]],\n    override = false\n}\n\nEC_LAND.start
        = function()\n    -- BRAKE ALL THE THINGS, but only if speed is low. If we
        are going fast, we\n    -- may be coasting.\n\n    EC_LAND.stage = \"stabilize\"\n
        \   SHIP.killEngines()\nend\n\nEC_LAND.resume = function()\n    EC_LAND.stage
        = \"done\"\n    SHIP.unhover()\nend\n\nEC_LAND.stop = function()\nend\n\nEC_LAND.flush
        = function(secs)\n    if EC_LAND.stage ~= \"done\" then\n        SHIP.stabilize()\n
        \   else\n        SHIP.killEngines()\n        SHIP.unhover()\n    end\n    if
        math.abs(PHYSICS.constructVelocitySpeed) > 0.2 then\n        SHIP.brake()\n
        \   end\n    if EC_LAND.stage == \"stabilize\" then\n        if\n            math.abs(PHYSICS.getRotationDiff(PHYSICS.currentPitchDeg,
        0)) < 2.0 and\n                math.abs(PHYSICS.getRotationDiff(PHYSICS.currentRollDeg,
        0)) < 2.0\n         then\n            SHIP.extendLandingGears()\n            EC_LAND.stage
        = \"extend\"\n            EC_LAND.timer = 0.0\n        end\n    end\n    if
        EC_LAND.stage == \"extend\" then\n        EC_LAND.timer = EC_LAND.timer +
        secs\n        if EC_LAND.timer > 3.0 then\n            system.print(\"extended\")\n
        \           EC_LAND.stage = \"lower\"\n            EC_LAND.timer = 0\n            SHIP.hover(1.0)\n
        \       end\n    end\n    if EC_LAND.stage == \"lower\" then\n        if math.abs(PHYSICS.constructVelocitySpeed)
        < 0.4 then\n            system.print(\"lowered, finished\")\n            EC_LAND.stage
        = \"done\"\n            SHIP.killEngines()\n            SHIP.unhover()\n            clearEngineCommand()\n
        \       end\n    end\nend\n\nCommandSelect.add(EC_LAND)\nlocal EC_HOVER =
        {\n    name = \"Hover\",\n    desc = [[\n1) Engage all brakes\n2) Set hover
        to 30 meters\n3) Rotate to be as flat as possible\n]],\n    override = false,\n
        \   runtime = 0.0\n}\n\nEC_HOVER.start = function()\n    -- BRAKE ALL THE
        THINGS, but only if speed is low. If we are going fast, we\n    -- may be
        coasting.\n\n    SHIP.retractLandingGears()\n    EC_HOVER.runtime = 0.0\nend\n\nEC_HOVER.resume
        = EC_HOVER.start\n\nEC_HOVER.stop = function()\nend\n\nEC_HOVER.flush = function(secs)\n
        \   EC_HOVER.runtime = EC_HOVER.runtime + secs\n    SHIP.stabilize()\n    SHIP.brake()\n
        \   SHIP.hover(30)\n    if EC_HOVER.runtime > 3.0 and math.abs(PHYSICS.constructVelocitySpeed)
        < 0.2 then\n        clearEngineCommand()\n    end\nend\n\nCommandSelect.add(EC_HOVER)\nlocal
        AP_DESCENT_THROTTLE = 0.2 --export: Throttle % to use on descent / approach\nlocal
        AP_DESCENT_DISTANCE = 2200 --export: How far away from destination to start
        descending\nlocal AP_CRUISE_ALTITUDE = 800 --export: How high above target
        altitude to cruise?\nlocal AP_CLIMB_PITCH = 15 --export: In degrees, how high
        to aim the ship during initial, full power climb.\nlocal AP_CRUISE_PITCH =
        6.0 --export: Pitch to cruise at. If you're bouncing up and down, adjust this.\n\nlocal
        EC_AUTOPILOT = {\n    name = 'Autopilot',\n    desc = [[\nEngage autopilot.
        Destination: (Select destination from autopilot menu)\n]],\n    desctemplate
        = [[\nEngage autopilot. Destination: %s.\n]],\n    override = false,\n\n    callbacks
        = {},\n    announcements = {},\n    time = 0.0,\n    arrived = false,\n}\n\nEC_AUTOPILOT.start
        = function()\n    EC_AUTOPILOT.time = 0.0\n    EC_AUTOPILOT.arrived = false\n
        \   EC_AUTOPILOT.announcements = {}\n    EC_AUTOPILOT.recalculate()\nend\n\nEC_AUTOPILOT.announce
        = function(msg)\n    if EC_AUTOPILOT.announcements[msg] then return end\n
        \   EC_AUTOPILOT.announcements[msg] = true\n    system.print(\"ANNOUNCEMENT:
        \" .. msg)\nend\n\nEC_AUTOPILOT.resume = EC_AUTOPILOT.start\n\nEC_AUTOPILOT.stop
        = function()\nend\n\n-- This is called twice a second\nEC_AUTOPILOT.recalculate
        = function()\n    if not databank.hasKey('destination') then return end\n
        \   EC_AUTOPILOT.callbacks = {}\n    -- This is the meat of autopilot.\n    --
        To start: discover our position relative to destination, our status\n    --
        \   (in atmo safe, in space safe, in space approaching, in atmo approaching)\n
        \   -- Then, determine which do we want to do:\n    --     - Brake and stop
        if we are close enough\n    --     - Determine if we are in-atmosphere or
        not\n    --     - Near, in atmo: Cross-planetary plotting\n    --     - Destination
        extraplanetary, in atmo: Take off.\n    --     - Approaching planet from space?
        YIKES.\n    --         - Be very conservative when approaching a space destination.\n
        \   --     - In space: Determine: speed up or slow down, and in which angle\n
        \   local destination = MainScreen.destination\n    if not (destination and
        destination.name) then\n\tclearEngineCommand()\n\treturn\n    end\n    local
        dpos = vec3(destination.position)\n    local mypos = vec3(core.getConstructWorldPos())\n
        \   local vdiff = dpos - mypos\n    local dist = vdiff:len()\n    EC_AUTOPILOT.announce(\"Plotting
        route for \" .. math.floor(dist / 1000) .. \"km\")\n    local inatmo = PHYSICS.isInAtmosphere()\n\n
        \   local cbs = EC_AUTOPILOT.callbacks\n\n    -- vdiff also defines what vector
        we want to aim at.\n    -- If we're in atmo, though, we only want the yaw
        heading.\n    local yaw_heading = getRoll(vdiff, PHYSICS.constructUp, PHYSICS.constructRight)\n
        \   local altDiff = PHYSICS.altitude - destination.altitude\n\n    SHIP.retractLandingGears()\n\n
        \   -- I think there's no planets more than 1.5 SU wide, and there's no\n
        \   if inatmo and dist < 400000.0 and destination.inatmo then\n\n\tlocal flatdist
        = math.sqrt(dist*dist - altDiff*altDiff)\n\n\tlocal desiredAltitude = 0.0\n\n\t--
        Still experimenting between speed and throttle\n\tlocal desiredSpeed = 0.0\n\tlocal
        desiredThrottle = 0.0\n\n        if EC_AUTOPILOT.arrived and PHYSICS.currentSpeed
        < 1.0 then\n\t    table.insert(cbs, {clearEngineCommand})\n\t    table.insert(cbs,
        {clearDestination})\n\t    table.insert(cbs, {setEngineCommand, EC_LAND})\n
        \       elseif EC_AUTOPILOT.arrived or flatdist < 30.0 then\n\t    EC_AUTOPILOT.arrived
        = true\n\t    table.insert(cbs, {SHIP.stabilize})\n\t    table.insert(cbs,
        {SHIP.throttleTo, 0.0})\n\t    table.insert(cbs, {SHIP.killEngines})\n\t    table.insert(cbs,
        {SHIP.brake, 1.0})\n\t    table.insert(cbs, {SHIP.hover, 10})\n\t    return\n\telseif
        flatdist < AP_DESCENT_DISTANCE then\n\t    desiredThrottle = AP_DESCENT_THROTTLE\n\t
        \   desiredSpeed = 20.0\n\t    local fact = flatdist / AP_DESCENT_DISTANCE\n\t
        \   desiredAltitude = destination.altitude + AP_CRUISE_ALTITUDE * (fact *
        fact)\n\telse\n\t    desiredThrottle = 1.0\n\t    desiredAltitude = destination.altitude
        + AP_CRUISE_ALTITUDE\n\t    desiredSpeed = 1000.0\n\tend\n\n\tlocal vertdiff
        = desiredAltitude - PHYSICS.altitude\n\n\tlocal pitch = 0.0\n\tlocal brakeTo
        = 0.0\n\n\tif PHYSICS.currentSpeed - desiredSpeed > 60 then\n\t    brakeTo
        = 1.0\n\telseif PHYSICS.currentSpeed - desiredSpeed > 10 then\n\t    brakeTo
        = 0.2\n\telse\n\t    brakeTo = 0.0\n\tend\n\n\tif vertdiff > 50 then\n\t    pitch
        = AP_CLIMB_PITCH\n\telseif vertdiff > -20 then\n\t    pitch = AP_CRUISE_PITCH\n\telseif
        vertdiff > -60 then\n\t    pitch = -5.0\n\telse\n\t    pitch = -15.0\n\tend\n\n\tdesiredThrottle
        = utils.clamp(desiredThrottle, 0.0, 1.0)\n\n\t-- At a very high distance (on
        other side of planet), yaw heading gets confused easily.\n\tif dist > 30000
        and math.abs(yaw_heading) < 5 then\n\t    yaw_heading = 0\n\tend\n\n        --
        Cross-planetary travel\n\ttable.insert(cbs, {SHIP.turnToHeadingAtmo, pitch,
        yaw_heading})\n\ttable.insert(cbs, {SHIP.hover, 30})\n\ttable.insert(cbs,
        {SHIP.throttleTo, desiredThrottle})\n\ttable.insert(cbs, {SHIP.brake, brakeTo})\n
        \   else\n        EC_AUTOPILOT.announce(\"Interplanetary travel TBD\")\n    end\n\nend\n\nEC_AUTOPILOT.update
        = function(secs)\n    local now = EC_AUTOPILOT.time + (secs * 2)\n    if math.floor(EC_AUTOPILOT.time)
        ~= math.floor(now) then\n        EC_AUTOPILOT.recalculate()\n    end\n    EC_AUTOPILOT.time
        = now\nend\n\nEC_AUTOPILOT.flush = function(secs)\n    for i, cbs in ipairs(EC_AUTOPILOT.callbacks)
        do\n        local cb = cbs[1]\n        cb(table.unpack(cbs, 2, #cbs))\n    end\nend\n\nCommandSelect.add(EC_AUTOPILOT)\nlocal
        ENGINE_SHIP = {\n    name = \"Control engine using the SHIP shiplib\",\n    desc
        = [[Pretty much the same as default, but clearer in code for me.]],\n    isEngine
        = true\n}\n\nfunction ENGINE_SHIP.start()\n    system.print(\"Setting throttle
        info\")\n    SHIP.reset()\nend\n\nfunction ENGINE_SHIP.onSTOPENGINES()\n    SHIP.killEngines()\nend\n\nfunction
        ENGINE_SHIP.onBOOSTER()\n    SHIP.plan.booster = not SHIP.plan.booster\nend\n\nfunction
        ENGINE_SHIP.startSPEEDDOWN()\n    ENGINE_SHIP.alterSpeed(-0.1)\nend\n\nfunction
        ENGINE_SHIP.startSPEEDUP()\n    ENGINE_SHIP.alterSpeed(0.1)\nend\n\nfunction
        ENGINE_SHIP.alterSpeed(amt)\n    local cur = SHIP.plan.throttle + amt\n    if
        cur > 1.0 then\n        cur = 1.0\n    end\n    if cur < -1.0 then\n        cur
        = -1.0\n    end\n    SHIP.plan.throttle = cur\nend\n\nfunction ENGINE_SHIP.update(secs)\n
        \   local amt = system.getThrottleInputFromMouseWheel()\n    if math.abs(amt)
        > 0.01 then\n        ENGINE_SHIP.alterSpeed(0.1 * amt)\n    end\nend\n\nfunction
        ENGINE_SHIP.onLIGHT()\n    if unit.isAnyHeadlightSwitchedOn() == 1 then\n
        \       unit.switchOffHeadlights()\n    else\n        unit.switchOnHeadlights()\n
        \   end\nend\n\nfunction ENGINE_SHIP.startGROUNDALTITUDEUP()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\n    if SHIP.plan.hoverAt > 50.0 then\n        SHIP.plan.hoverAt
        = 50.0\n    end\nend\n\nfunction ENGINE_SHIP.loopGROUNDALTITUDEUP()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt + 1.0\n    if SHIP.plan.hoverAt > 50.0 then\n        SHIP.plan.hoverAt
        = 50.0\n    end\nend\n\nfunction ENGINE_SHIP.startGROUNDALTITUDEDOWN()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt - 1.0\n    if SHIP.plan.hoverAt < 1.0 then\n        SHIP.plan.hoverAt
        = 1.0\n    end\nend\n\nfunction ENGINE_SHIP.loopGROUNDALTITUDEDOWN()\n    SHIP.plan.hoverAt
        = SHIP.plan.hoverAt - 1.0\n    if SHIP.plan.hoverAt < 1.0 then\n        SHIP.plan.hoverAt
        = 1.0\n    end\nend\n\nfunction ENGINE_SHIP.onWARP()\n    if warpdrive ~=
        nil then\n        warpdrive.activateWarp()\n    end\nend\n\nfunction ENGINE_SHIP.onANTIGRAVITY()\n
        \   if antigrav ~= nil then\n        antigrav.toggle()\n    end\nend\n\nfunction
        ENGINE_SHIP.flush(secs)\n    -- OVERRIDE by shipos\n    local pitchInput =
        PHYSICS.keyState(\"BACKWARD\") - PHYSICS.keyState(\"FORWARD\")\n    local
        rollInput = PHYSICS.keyState(\"RIGHT\") - PHYSICS.keyState(\"LEFT\")\n    local
        yawInput = PHYSICS.keyState(\"YAWLEFT\") - PHYSICS.keyState(\"YAWRIGHT\")\n\n
        \   SHIP.plan.throttleLateral = PHYSICS.keyState(\"STRAFERIGHT\") - PHYSICS.keyState(\"STRAFELEFT\")\n
        \   SHIP.plan.throttleVertical = PHYSICS.keyState(\"UP\") - PHYSICS.keyState(\"DOWN\")\n\n
        \   local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n
        \   local finalRollInput = rollInput + system.getControlDeviceYawInput()\n
        \   local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n
        \   local finalBrakeInput = PHYSICS.keyState(\"BRAKE\")\n\n    SHIP.spin(finalPitchInput,
        finalRollInput, finalYawInput)\n\n    SHIP.brake(finalBrakeInput)\nend\n\nCommandSelect.add(ENGINE_SHIP,
        true)\n-- Autopilot Screen\n-- This is for managing autopilot information.\n--
        1. Bookmark current location, with 5-character name\n-- 2. List of bookmarks
        to go to.\n\nlocal AutoPilotScreen = {\n    name = \"Autopilot\",\n    CHOICES
        = {},\n    Choice = 1,\n    inNameEntry = false,\n    deleteat = 0\n}\n\nAutoPilotScreen.reset
        = function()\n    AutoPilotScreen.CHOICES = {\n        {namer = true, name
        = \"Bookmark Current Location\"},\n        {clearer = true, name = \"Clear
        set destination\"}\n    }\n    AutoPilotScreen.Choice = 1\n    AutoPilotScreen.inNameEntry
        = false\n\n    local bms = AutoPilotScreen.getBookmarks()\n    for _, bm in
        ipairs(bms) do\n        table.insert(AutoPilotScreen.CHOICES, bm)\n    end\nend\n\nAutoPilotScreen.getBookmarks
        = function()\n    if databank.hasKey(\"bookmarks\") then\n        local ret
        = nil\n        if\n            pcall(\n                function()\n                    local
        s = databank.getStringValue(\"bookmarks\")\n                    ret = json.decode(s)\n
        \               end\n            )\n         then\n            if type(ret)
        == \"table\" then\n                return ret\n            end\n        end\n
        \   end\n    return {}\nend\n\nAutoPilotScreen.addBookmark = function(bm)\n
        \   local bms = AutoPilotScreen.getBookmarks()\n    table.insert(bms, bm)\n
        \   databank.setStringValue(\"bookmarks\", json.encode(bms))\n    AutoPilotScreen.reset()\nend\n\nAutoPilotScreen.deleteBookmark
        = function(idx, todel)\n    local bms = AutoPilotScreen.getBookmarks()\n    local
        newbms = {}\n    local done = false\n    for _, bm in ipairs(bms) do\n        if
        not done and bm.position[1] == todel.position[1] and bm.name == todel.name
        and bm.altitude == todel.altitude then\n            done = true\n        else\n
        \           table.insert(newbms, bm)\n        end\n    end\n    databank.setStringValue(\"bookmarks\",
        json.encode(newbms))\n    AutoPilotScreen.reset()\nend\n\nlocal BMState =
        {\n    chars = {\"A\"},\n    pos = 1\n}\n\nlocal BMMAP_DOWN = {\n    [\"A\"]
        = \"B\", [\"B\"] = \"C\", [\"C\"] = \"D\", [\"D\"] = \"E\", [\"E\"] = \"F\",\n
        \   [\"F\"] = \"G\", [\"G\"] = \"H\", [\"H\"] = \"I\", [\"I\"] = \"J\", [\"J\"]
        = \"K\",\n    [\"K\"] = \"L\", [\"L\"] = \"M\", [\"M\"] = \"N\", [\"N\"] =
        \"O\", [\"O\"] = \"P\",\n    [\"P\"] = \"Q\", [\"Q\"] = \"R\", [\"R\"] = \"S\",
        [\"S\"] = \"T\", [\"T\"] = \"U\",\n    [\"U\"] = \"V\", [\"V\"] = \"W\", [\"W\"]
        = \"X\", [\"X\"] = \"Y\", [\"Y\"] = \"Z\",\n    [\"Z\"] = \"1\", [\"1\"] =
        \"2\", [\"2\"] = \"3\", [\"3\"] = \"4\", [\"4\"] = \"5\",\n    [\"5\"] = \"6\",
        [\"6\"] = \"7\", [\"7\"] = \"8\", [\"8\"] = \"9\", [\"9\"] = \"0\",\n    [\"0\"]
        = \" \", [\" \"] = \"A\"\n}\n\nlocal BMMAP_UP = {\n    [\"A\"] = \" \", [\"B\"]
        = \"A\", [\"C\"] = \"B\", [\"D\"] = \"C\", [\"E\"] = \"D\",\n    [\"F\"] =
        \"E\", [\"G\"] = \"F\", [\"H\"] = \"G\", [\"I\"] = \"H\", [\"J\"] = \"I\",\n
        \   [\"K\"] = \"J\", [\"L\"] = \"K\", [\"M\"] = \"L\", [\"N\"] = \"M\", [\"O\"]
        = \"N\",\n    [\"P\"] = \"O\", [\"Q\"] = \"P\", [\"R\"] = \"Q\", [\"S\"] =
        \"R\", [\"T\"] = \"S\",\n    [\"U\"] = \"T\", [\"V\"] = \"U\", [\"W\"] = \"V\",
        [\"X\"] = \"W\", [\"Y\"] = \"X\",\n    [\"Z\"] = \"Y\", [\"1\"] = \"Z\", [\"2\"]
        = \"1\", [\"3\"] = \"2\", [\"4\"] = \"3\",\n    [\"5\"] = \"4\", [\"6\"] =
        \"5\", [\"7\"] = \"6\", [\"8\"] = \"7\", [\"9\"] = \"8\",\n    [\"0\"] = \"9\",
        [\" \"] = \"0\"\n}\n\nBMState.render = function()\n    local chars = {}\n
        \   for p, char in ipairs(BMState.chars) do\n        table.insert(chars, el(\"div\",
        {class = (p == BMState.pos and \"sel ch\" or \"ch\")}, char))\n    end\n\n
        \   return el(\n        \"div\",\n        {class = \"namer\"},\n        [[<p>Enter
        a name: A = prev char D = next char, S = abc, W = zyx.</p>]] ..\n            table.concat(chars,
        \"\") .. [[<p>Press space to add bookmark</p>]]\n    )\nend\n\nBMState.up
        = function()\n    local cur = BMState.chars[BMState.pos]\n    cur = BMMAP_UP[cur]\n
        \   BMState.chars[BMState.pos] = cur\nend\n\nBMState.down = function()\n    local
        cur = BMState.chars[BMState.pos]\n    cur = BMMAP_DOWN[cur]\n    BMState.chars[BMState.pos]
        = cur\nend\n\nBMState.left = function()\n    BMState.pos = BMState.pos - 1\n
        \   if BMState.pos < 1 then\n        BMState.pos = 1\n    end\nend\n\nBMState.right
        = function()\n    BMState.pos = BMState.pos + 1\n    if BMState.pos > 20 then\n
        \       BMState.pos = 20\n    end\n    if BMState.pos > #BMState.chars then\n
        \       table.insert(BMState.chars, \"A\")\n    end\nend\n\nAutoPilotScreen.Style
        =\n    el(\n    \"style\",\n    [[\n\t    .namer { position: fixed; width:
        20vw; height: 20vh; padding: 2em; display: block; left: 45vw; top: 45vh; font-size:
        3vh; color: white; background-color: #666699ee; }\n\t    .ch { display: inline-block;
        width: 3vh; height: 3vh; text-align: center; }\n\t    .sel { background-color:
        #669966ee; }\n\t    .bookmarks { position: fixed; display: block; left: 40vw;
        top: 35vh; }\n\t    .estab { display: block; width: 15vw; height: 4vh; margin:
        0; padding: 5px; background-color: grey; font-size: 1.5vh; color: white; }\n\t
        \   .essel { background-color: yellow; color: black; }\n    ]]\n)\n\nAutoPilotScreen.onFORWARD
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.up()\n
        \       return\n    end\n    AutoPilotScreen.Choice = AutoPilotScreen.Choice
        - 1\n    if AutoPilotScreen.Choice < 1 then\n        AutoPilotScreen.Choice
        = #AutoPilotScreen.CHOICES\n    end\nend\n\nAutoPilotScreen.onBACKWARD = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        BMState.down()\n        return\n
        \   end\n    AutoPilotScreen.Choice = AutoPilotScreen.Choice + 1\n    if AutoPilotScreen.Choice
        > #AutoPilotScreen.CHOICES then\n        AutoPilotScreen.Choice = 1\n    end\nend\n\nAutoPilotScreen.onYAWLEFT
        = function()\n    if AutoPilotScreen.inNameEntry then\n        BMState.left()\n
        \       return\n    end\nend\n\nAutoPilotScreen.onYAWRIGHT = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        BMState.right()\n        return\n
        \   end\nend\n\nAutoPilotScreen.onLEFT = function()\n    if AutoPilotScreen.inNameEntry
        then\n        AutoPilotScreen.inNameEntry = false\n        return\n    end\n
        \   local choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\n    if
        not choice.position then\n        return\n    end\n    local now = system.getTime()\n
        \   if now - AutoPilotScreen.deleteat < 2.0 then\n        AutoPilotScreen.deleteBookmark(AutoPilotScreen.Choice,
        choice)\n    else\n        AutoPilotScreen.deleteat = now\n    end\nend\n\nAutoPilotScreen.bookmark
        = function(name)\n    local bm = {\n        name = name,\n        position
        = core.getConstructWorldPos(),\n        altitude = core.getAltitude(),\n        inatmo
        = PHYSICS.isInAtmosphere()\n    }\n    AutoPilotScreen.addBookmark(bm)\nend\n\nfunction
        clearDestination()\n    databank.setStringValue(\"destination\", \"{}\")\n
        \   MainScreen.destination = {}\nend\n\nAutoPilotScreen.onUP = function()\n
        \   if AutoPilotScreen.inNameEntry then\n        AutoPilotScreen.bookmark(table.concat(BMState.chars,
        \"\"))\n        return\n    end\n    local choice = AutoPilotScreen.CHOICES[AutoPilotScreen.Choice]\n
        \   if choice.namer then\n        AutoPilotScreen.inNameEntry = true\n        BMState.chars
        = {\"A\"}\n        BMState.pos = 1\n        return\n    end\n    if choice.clearer
        then\n        clearDestination()\n    end\n    if not choice.position then\n
        \       return\n    end\n    databank.setStringValue(\"destination\", json.encode(choice))\n
        \   MainScreen.destination = choice\nend\n\nAutoPilotScreen.render = function()\n
        \   local tabs = {}\n    local chosen = nil\n    for i, engine in ipairs(AutoPilotScreen.CHOICES)
        do\n        local cls = \"estab\"\n        if i == AutoPilotScreen.Choice
        then\n            cls = \"estab essel\"\n            chosen = engine\n        end\n
        \       table.insert(tabs, el(\"div\", {class = cls}, engine.name))\n    end\n
        \   local bmname = \"\"\n    if AutoPilotScreen.inNameEntry then\n        bmname
        = BMState.render()\n    end\n    return AutoPilotScreen.Style .. el(\"div\",
        {class = \"bookmarks\"}, tabs) .. bmname\nend\n-- HUD Configuration\n-- This
        is loaded fairly early on, so HUD instances can\n-- register themselves with
        HUDConfig\n\nlocal HUDConfig = {\n    name = \"HUD Config\",\n    HUDS = {},\n
        \   OPTIONS = {},\n    Choice = 1,\n    ENABLED = {}\n}\n\nlocal function
        getOpt(opt)\n    if not databank.hasKey(opt.key) then\n        return opt.val\n
        \   end\n    if opt.datatype == \"bool\" then\n        return databank.getIntValue(opt.key)
        ~= 0\n    end\n    if opt.datatype == \"int\" then\n        return databank.getIntValue(opt.key)\n
        \   end\n    if opt.datatype == \"float\" then\n        return databank.getFloatValue(opt.key)\n
        \   end\nend\nlocal function setOpt(opt, val)\n    opt.hud.opts[opt.id] =
        val\n    if opt.datatype == \"bool\" then\n        databank.setIntValue(opt.key,
        val and 1 or 0)\n    end\n    if opt.datatype == \"int\" then\n        return
        databank.setIntValue(opt.key, val)\n    end\n    if opt.datatype == \"float\"
        then\n        return databank.setFloatValue(opt.key, val)\n    end\nend\n\nlocal
        hudodd = false\n\nlocal HUDUI = {}\n\nHUDUI.BoolHandler = {\n    render =
        function(opt)\n        if getOpt(opt) then\n            return \"YES\"\n        else\n
        \           return \"NO\"\n        end\n    end,\n    onSpace = function(opt)\n
        \       local val = not getOpt(opt)\n        setOpt(opt, val)\n        if
        opt.onset then\n            opt.onset(opt, val)\n        end\n    end\n}\n\nHUDUI.IntHandler
        = {\n    render = function(opt)\n        local v = getOpt(opt)\n        return
        string.format(\"%d\", v)\n    end,\n    onLeft = function(opt)\n        local
        val = getOpt(opt) - opt.step\n        if val < opt.min then\n            val
        = opt.min\n        end\n        setOpt(opt, val)\n        if opt.onset then\n
        \           opt.onset(opt, val)\n        end\n    end,\n    onRight = function(opt)\n
        \       local val = getOpt(opt) + opt.step\n        if val > opt.max then\n
        \           val = opt.max\n        end\n        setOpt(opt, val)\n\n        if
        opt.onset then\n            opt.onset(opt, val)\n        end\n    end\n}\n\nfunction
        HUDConfig.setEnabled(opt, val)\n    local hud = opt.hud\n    hud.opts.enabled
        = val\n    if val then\n        HUDConfig.ENABLED[hud.name] = hud\n        if
        hud.start then\n            hud.start(hud)\n        end\n    else\n        HUDConfig.ENABLED[hud.name]
        = nil\n        if hud.stop then\n            hud.stop(hud)\n        end\n
        \   end\nend\n\nfunction HUDConfig.addHUD(hud)\n    local cls = \"heven\"\n
        \   if hudodd then\n        cls = \"hodd\"\n    end\n    hudodd = not hudodd\n
        \   table.insert(HUDConfig.HUDS, hud)\n    if type(hud.opts.enabled) == type(true)
        then\n        table.insert(\n            HUDConfig.OPTIONS,\n            {\n
        \               cls = cls, -- for HUDUI rendering and grouping\n                hud
        = hud,\n                id = \"enabled\",\n                datatype = \"bool\",\n
        \               val = hud.opts.enabled,\n                onset = HUDConfig.setEnabled,\n
        \               name = \"Enable \" .. hud.name,\n                uihandler
        = HUDUI.BoolHandler,\n                key = hud.key .. \".\" .. \"enabled\"\n
        \           }\n        )\n    end\n    if hud.config then\n        for k,
        v in pairs(hud.config) do\n            if not v.cls then\n                v.cls
        = cls\n            end\n            if not v.hud then\n                v.hud
        = hud\n            end\n            if not v.val then\n                v.val
        = hud.opts[k]\n            end\n            if not v.name then\n                v.name
        = k\n            end\n            if not v.key then\n                v.key
        = hud.key .. \".\" .. k\n            end\n            if not v.id then\n                v.id
        = k\n            end\n            table.insert(HUDConfig.OPTIONS, v)\n        end\n
        \   end\nend\n\nHUDConfig.Style =\n    el(\n    \"style\",\n    [[\n  .hudlist
        { position: fixed; display: block; left: 20vw; top: 35vh; }\n  .heven { background-color:
        #333399; }\n  .hodd { background-color: #339933; }\n  .hi { display: block;
        width: 35vw; height: 4vh; margin: 0; padding: 5px; font-size: 2vh; color:
        white; }\n  .hsel { background-color: yellow; color: black; }\n  .hv { display:
        block; float: right; margin-right: 1vw; }\n]]\n)\n\nHUDConfig.onFORWARD =
        function()\n    HUDConfig.Choice = HUDConfig.Choice - 1\n    if HUDConfig.Choice
        < 1 then\n        HUDConfig.Choice = #HUDConfig.OPTIONS\n    end\nend\n\nHUDConfig.onBACKWARD
        = function()\n    HUDConfig.Choice = HUDConfig.Choice + 1\n    if HUDConfig.Choice
        > #HUDConfig.OPTIONS then\n        HUDConfig.Choice = 1\n    end\nend\n\nHUDConfig.onYAWLEFT
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onLeft then\n        opt.uihandler.onLeft(opt)\n    end\nend\n\nHUDConfig.onYAWRIGHT
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onRight then\n        opt.uihandler.onRight(opt)\n    end\nend\n\nHUDConfig.onUP
        = function()\n    local opt = HUDConfig.OPTIONS[HUDConfig.Choice]\n    if
        opt.uihandler.onSpace then\n        opt.uihandler.onSpace(opt)\n    end\nend\n\nHUDConfig.render
        = function()\n    local tabs = {}\n    local chosen = nil\n    for i, opt
        in ipairs(HUDConfig.OPTIONS) do\n        local cls = opt.cls .. \" hi\"\n
        \       if i == HUDConfig.Choice then\n            cls = \"hi hsel\"\n            chosen
        = opt\n        end\n        table.insert(tabs, el(\"div\", {class = cls},
        {opt.name, el(\"div\", {class = \"hv\"}, opt.uihandler.render(opt))}))\n    end\n
        \   return HUDConfig.Style .. el(\"div\", {class = \"hudlist\"}, tabs)\nend\n\nHUDConfig.start
        = function()\n    -- In here we load all data from databank for each option.\n
        \   for i, opt in pairs(HUDConfig.OPTIONS) do\n        local val = getOpt(opt)\n
        \       if opt.onset then\n            opt.onset(opt, val)\n        end\n
        \       opt.hud.opts[opt.id] = val\n    end\nend\n-- Widget HUDS from default
        ship configuration\n\nlocal function displayCategoryPanel(elements, title,
        widgettype)\n    if #elements > 0 then\n        local panel = system.createWidgetPanel(title)\n
        \       local widget = system.createWidget(panel, widgettype)\n        for
        i, el in pairs(elements) do\n            system.addDataToWidget(elements[i].getDataId(),
        widget)\n        end\n        return panel\n    end\nend\n\nlocal function
        addFuelWidget(name, varname)\n    local widget = {\n        name = \"Default
        \" .. name .. \" Widget\",\n        key = \"defaultwidget\" .. varname,\n
        \       opts = {\n            enabled = false\n        }\n    }\n\n    function
        widget.start(self)\n        self.panel = displayCategoryPanel(_G.fueltanks[varname],
        name .. \" Fuel\", \"fuel_container\")\n    end\n\n    function widget.stop(self)\n
        \       system.destroyWidgetPanel(self.panel)\n    end\n\n    HUDConfig.addHUD(widget)\nend\n\naddFuelWidget(\"Atmo\",
        \"atmo\")\naddFuelWidget(\"Space\", \"space\")\naddFuelWidget(\"Rocket\",
        \"rocket\")\n\nlocal HUDWidgetCore = {\n    name = \"Hide Controller Default\",\n
        \   key = \"defaultwidgetcore\",\n    opts = {\n        enabled = false\n
        \   }\n}\n\nfunction HUDWidgetCore.start(self)\n    unit.hide()\nend\n\nfunction
        HUDWidgetCore.stop(self)\n    unit.show()\nend\n\nHUDConfig.addHUD(HUDWidgetCore)\n--
        Rezoix's DU-hud\n-- https://github.com/Rezoix/DU-hud\n\nlocal HUDRezoix =
        {\n    name = \"Rezoix's DU HUD\",\n    key = \"hudrezoix\",\n    opts = {\n
        \       enabled = false\n    }\n}\n\nfunction HUDRezoix.render()\n    local
        altitude = core.getAltitude()\n    local velocity = core.getVelocity()\n    local
        speed = vec3(velocity):len()\n    local worldV = vec3(core.getWorldVertical())\n
        \   local constrF = vec3(core.getConstructWorldOrientationForward())\n    local
        constrR = vec3(core.getConstructWorldOrientationRight())\n    local constrV
        = vec3(core.getConstructWorldOrientationUp())\n\n    local pitch = gyro.getPitch()\n
        \    --180 - getRoll(worldV, constrR, constrF)\n    local roll = gyro.getRoll()\n
        \    --getRoll(worldV, constrF, constrR)\n    local bottomText = \"ROLL\"\n
        \   local mode = 0\n\n    if (altitude == 0) then\n        mode = 1\n    else\n
        \       mode = 0\n    end\n\n    if (mode == 1) then\n        if (speed >
        5) then\n            pitch = math.deg(math.atan(velocity[2], velocity[3]))
        - 90\n            roll = math.deg(math.atan(velocity[2], velocity[1])) - 90\n
        \       else\n            pitch = 0\n            roll = 0\n        end\n        bottomText
        = \"YAW\"\n    end\n\n    content =\n        [[\n        <style>\n            body
        {margin: 0}\n            svg {display:block; position:absolute; top:0; left:0}\n
        \           .majorLine {stroke:aqua;opacity:0.7;stroke-width:3;fill-opacity:0;}\n
        \           .minorLine {stroke:aqua;opacity:0.3;stroke-width:3;fill-opacity:0;}\n
        \           .text {fill:aqua;font-family:Montserrat;font-weight:bold}\n\n
        \           #space {}\n            #ecu {}\n            #atmos {}\n\n\n        </style>\n
        \       <svg height=\"100%\" width=\"100%\" viewBox=\"0 0 1920 1080\">\n            <g
        class=\"majorLine\">\n                <line x1=\"939\" y1=\"537\" x2=\"957\"
        y2=\"519\"/>\n                <line x1=\"939\" y1=\"543\" x2=\"957\" y2=\"561\"/>\n
        \               <line x1=\"981\" y1=\"537\" x2=\"963\" y2=\"519\"/>\n                <line
        x1=\"981\" y1=\"543\" x2=\"963\" y2=\"561\"/>\n\n                <line x1=\"932\"
        y1=\"540\" x2=\"945\" y2=\"540\"/>\n                <line x1=\"988\" y1=\"540\"
        x2=\"975\" y2=\"540\"/>\n                <line x1=\"960\" y1=\"512\" x2=\"960\"
        y2=\"525\"/>\n                <line x1=\"960\" y1=\"568\" x2=\"960\" y2=\"555\"/>\n\n
        \               <g style=\"opacity:0.2\">\n                    <line x1=\"920\"
        y1=\"540\" x2=\"840\" y2=\"540\"/>\n                    <line x1=\"1000\"
        y1=\"540\" x2=\"1080\" y2=\"540\"/>\n                    <line x1=\"960\"
        y1=\"500\" x2=\"960\" y2=\"470\"/>\n                    <line x1=\"960\" y1=\"580\"
        x2=\"960\" y2=\"610\"/>\n                </g>\n\n                <path d=\"M
        700 0 L 740 35 Q 960 55 1180 35 L 1220 0\"/>\n                <path d=\"M
        792 550 L 785 550 L 785 650 L 792 650\"/>\n            </g>\n\n\n            <g>\n
        \               <polygon points=\"782,540 800,535 800,545\" style=\"fill:rgb(42,
        234, 248);opacity:0.7\"/>\n                <polygon points=\"1138,540 1120,535
        1120,545\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n                <polygon
        points=\"960,725 955,707 965,707\" style=\"fill:rgb(42, 234, 248);opacity:0.7\"/>\n
        \           </g>\n\n            <g class=\"text\">\n                <g font-size=10>\n
        \                   <text x=\"785\" y=\"530\" text-anchor=\"start\">PITCH</text>\n
        \                   <text x=\"1135\" y=\"530\" text-anchor=\"end\">PITCH</text>\n
        \                   <text x=\"960\" y=\"688\" text-anchor=\"middle\">ROLL</text>\n
        \                   <text x=\"790\" y=\"660\" text-anchor=\"start\">THRL</text>\n
        \               </g>\n                <g font-size=15>\n                    <text
        x=\"1020\" y=\"33\" text-anchor=\"middle\" id=\"space\">SPACE</text>\n                    <text
        x=\"900\" y=\"33\" text-anchor=\"middle\" id=\"atmos\">ATMOS</text>\n                    <text
        x=\"960\" y=\"35\" text-anchor=\"middle\" id=\"ecu\">ECU</text>\n                </g>\n\n
        \           </g>]]\n\n    pitchC = math.floor(pitch)\n    for i = pitchC -
        25, pitchC + 25 do\n        if (i % 10 == 0) then\n            num = i\n            if
        (num > 180) then\n                num = -180 + 10 * (i - 18)\n            elseif
        (num < -170) then\n                num = 180 + 10 * (i + 18)\n            end\n\n
        \           content =\n                content ..\n                [[<g transform=\"translate(0
        ]] ..\n                    (-i * 5 + pitch * 5) ..\n                        [[)\">\n
        \               <text x=\"745\" y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                            num ..\n                                [[</text>\n
        \               <text x=\"1175\" y=\"540\" style=\"fill:rgb(1, 165, 177);text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                                    num .. [[</text></g>]]\n        end\n\n
        \       len = 5\n        if (i % 10 == 0) then\n            len = 30\n        elseif
        (i % 5 == 0) then\n            len = 15\n        end\n\n        content =\n
        \           content ..\n            [[\n        <g transform=\"translate(0
        ]] ..\n                (-i * 5 + pitch * 5) ..\n                    [[)\">\n
        \           <line x1=\"]] ..\n                        (780 - len) ..\n                            [[\"
        y1=\"540\" x2=\"780\" y2=\"540\"style=\"stroke:rgb(1, 165, 177);opacity:0.3;stroke-width:3\"/>\n
        \           <line x1=\"]] ..\n                                (1140 + len)
        ..\n                                    [[\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:3\"/></g>]]\n    end\n\n    rollC = math.floor(roll)\n
        \   for i = rollC - 35, rollC + 35 do\n        if (i % 10 == 0) then\n            num
        = math.abs(i)\n            if (num > 180) then\n                num = 180
        + (180 - num)\n            end\n            content =\n                content
        ..\n                [[<g transform=\"rotate(]] ..\n                    (i
        - roll) ..\n                        [[,960,460)\">\n            <text x=\"960\"
        y=\"760\" style=\"fill:rgb(1, 165, 177);text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">]]
        ..\n                            num .. [[</text></g>]]\n        end\n\n        len
        = 5\n        if (i % 10 == 0) then\n            len = 15\n        elseif (i
        % 5 == 0) then\n            len = 10\n        end\n\n        content =\n            content
        ..\n            [[<g transform=\"rotate(]] ..\n                (i - roll)
        ..\n                    [[,960,460)\">\n        <line x1=\"960\" y1=\"730\"
        x2=\"960\" y2=\"]] ..\n                        (730 + len) .. [[\" style=\"stroke:rgb(1,
        165, 177);opacity:0.3;stroke-width:2\"/></g>]]\n    end\n\n    -- -unit.getThrottle()*0.97\n
        \   content =\n        content ..\n        [[<g transform=\"translate(0 ]]
        ..\n            (-50) ..\n                [[)\">\n            <polygon points=\"788,650
        800,647 800,653\" style=\"fill:rgb(1, 165, 177);opacity:0.7\"/>\n        </g>]]\n\n
        \   content = content .. [[\n\n        </svg>\n    ]]\n    return content\nend\n\nHUDConfig.addHUD(HUDRezoix)\n--
        Compact fuel gauges\n-- To replace the big ol' ugly widget.\n\nlocal HUDFuelGauges
        = {\n    name = \"Compact Fuel Gauges\",\n    key = \"compactfuel\",\n    opts
        = {\n        enabled = false,\n        posX = 50,\n        posY = 50\n    },\n
        \   config = {\n        posX = {\n            min = 0,\n            default
        = 50,\n            max = SCREEN_X,\n            datatype = \"int\",\n            uihandler
        = HUDUI.IntHandler,\n            name = \"Position X\",\n            step
        = 20\n        },\n        posY = {\n            min = 0,\n            default
        = 50,\n            max = SCREEN_Y,\n            datatype = \"int\",\n            uihandler
        = HUDUI.IntHandler,\n            name = \"Position Y\",\n            step
        = 20\n        }\n    }\n}\n\nHUDFuelGauges.COLORS = {\n    atmo = \"#ccccff\",\n
        \   space = \"yellow\",\n    rocket = \"red\"\n}\n\nfunction HUDFuelGauges.renderTank(ft,
        tank, i)\n    local color = HUDFuelGauges.COLORS[ft]\n    local dat = json.decode(tank.getData())\n
        \   return el(\n        \"g\",\n        {\n            el(\"rect\", {y = i
        * 30, width = 100, height = 20, fill = \"#00000000\", stroke = color, rx =
        2}),\n            el(\"rect\", {y = i * 30, width = (dat.percentage), height
        = 20, fill = color, rx = 2})\n        }\n    )\nend\n\nfunction HUDFuelGauges.render()\n
        \   local tanklist = {}\n    for _, fueltype in pairs({\"atmo\", \"space\",
        \"rocket\"}) do\n        local tanks = _G.fueltanks[fueltype]\n        if
        tanks and #tanks > 0 then\n            for _, tank in ipairs(tanks) do\n                table.insert(tanklist,
        HUDFuelGauges.renderTank(fueltype, tank, #tanklist))\n            end\n        end\n
        \   end\n    return el(\n        \"svg\",\n        {\n            style =
        string.format(\n                \"display: block; position: fixed; left: %d;
        top: %d;\",\n                HUDFuelGauges.opts.posX,\n                HUDFuelGauges.opts.posY\n
        \           )\n        },\n        tanklist\n    )\nend\n\nHUDConfig.addHUD(HUDFuelGauges)\n--
        Main screen, which tabs between different modes, and\n-- keeps state across
        children.\n--\n-- We always have a ShipRunner running, even if ShipOff\n--
        ShipRunner is background\n-- Current Screen is foreground\n-- Main Tabs on
        top, always.\n\n-- MainScreen must be global for earlier files to access it.\nMainScreen
        = {\n    ShipRunner = {},\n    ShipCommand = nil,\n    Screen = ScreenStart,\n
        \   Tab = 1,\n    ACTIVE = {},\n    destination = nil\n}\n\nMainScreen.TABS
        = {\n    {name = \"Control\", isControl = true, render = function()\n        end}\n}\n\nif
        unit.isRemoteControlled() == 1 then\n    table.insert(\n        MainScreen.TABS,\n
        \       {name = \"Walk\", isWalk = true, freeze = false, render = function()\n
        \           end}\n    )\nend\n\ntable.insert(MainScreen.TABS, CommandSelect)\ntable.insert(MainScreen.TABS,
        AutoPilotScreen)\ntable.insert(MainScreen.TABS, HUDConfig)\n\n-- Control is
        active first.\nMainScreen.ACTIVE = MainScreen.TABS[1]\n\nMainScreen.onGEAR
        = function()\n    MainScreen.Tab = MainScreen.Tab + 1\n    if MainScreen.Tab
        > #MainScreen.TABS then\n        MainScreen.Tab = 1\n    end\n    MainScreen.ACTIVE
        = MainScreen.TABS[MainScreen.Tab]\n    if MainScreen.ACTIVE.isWalk then\n
        \       system.freeze(0)\n    else\n        system.freeze(1)\n    end\nend\n\nfunction
        MainScreen.setControl()\n    MainScreen.Tab = 1\n    MainScreen.ACTIVE = MainScreen.TABS[1]\nend\n\nfunction
        onFlush(secs)\n    PHYSICS.update()\n    if MainScreen.ShipCommand and MainScreen.ShipCommand.flush
        then\n        MainScreen.ShipCommand.flush(secs)\n    elseif MainScreen.ShipRunner
        and MainScreen.ShipRunner.flush then\n        MainScreen.ShipRunner.flush(secs)\n
        \   end\n    SHIP.flush()\nend\n\nfunction tabStyle()\n    return el(\n        \"style\",\n
        \       [[\n        .maintabs { position: fixed; display: block; left: 40vw;
        top: 15vh; }\n        .tab { display: inline-block; width: 5vw; height: 4vh;
        margin: 0; padding: 5px; background-color: grey; font-size: 2vh; color: white;
        }\n        .sel { background-color: yellow; color: black; }\n\t.dest { display:
        block; position: fixed; left: 45vw; top: 26vh; font-size: 2vh; color: green;
        font-weight: bold; }\n\t.info { display: block; position: fixed; left: 40vw;
        top: 20vh; font-size: 3vh; color: red; font-weight: bold; background-color:
        #66666666; }\n    ]]\n    )\nend\n\nfunction renderTabs()\n    local tabs
        = {}\n    for i, tab in ipairs(MainScreen.TABS) do\n        local cls = \"tab\"\n
        \       if i == MainScreen.Tab then\n            cls = \"tab sel\"\n        end\n
        \       table.insert(tabs, el(\"div\", {class = cls}, tab.name))\n    end\n
        \   return el(\"div\", {class = \"maintabs\"}, tabs)\nend\n\nfunction generateContent()\n
        \   local selected = MainScreen.TABS[MainScreen.Tab]\n    local subscreen
        = \"\"\n    if selected.render then\n        subscreen = selected.render()
        or \"\"\n    else\n        subscreen = \"NO RENDERER?\"\n    end\n    local
        shipcommand = \"\"\n    if MainScreen.ShipCommand then\n        shipcommand
        = el(\"div\", {class = \"info\"}, \"Executing: \" .. MainScreen.ShipCommand.name
        .. \"(Q to cancel)\")\n    end\n    local dest = \"\"\n    if MainScreen.destination
        and MainScreen.destination.name then\n        dest = el(\"div\", {class =
        \"dest\"}, \"Destination: \" .. (MainScreen.destination.name or \"None?\"))\n
        \   end\n    return el(\n        \"html\",\n        {\n            el(\n                \"head\",\n
        \               {\n                    tabStyle()\n                }\n            ),\n
        \           el(\n                \"body\",\n                {\n                    renderTabs(),\n
        \                   renderHUD(),\n                    subscreen,\n                    shipcommand,\n
        \                   dest\n                }\n            )\n        }\n    )\nend\n\nfunction
        renderHUD()\n    local ret = {}\n    for _, hud in pairs(HUDConfig.ENABLED)
        do\n        if hud.render then\n            table.insert(ret, hud.render())\n
        \       end\n    end\n    return table.concat(ret, \"\")\nend\n\nfunction
        MainScreen.start()\n    system.freeze(1)\n    system.showScreen(1)\n    if
        databank.hasKey(\"destination\") then\n        MainScreen.destination = json.decode(databank.getStringValue(\"destination\"))\n
        \   end\n    local ec = databank.getStringValue(\"ec\")\n    if ec and ec
        ~= nil and ec ~= \"\" then\n        MainScreen.ShipCommand = CommandSelect.ENGINES_NAME[ec]\n
        \       if MainScreen.ShipCommand.resume then\n            MainScreen.ShipCommand.resume()\n
        \       end\n    end\n    local eng = databank.getStringValue(\"eng\")\n    if
        not eng or eng == nil or eng == \"\" then\n        eng = ENGINE_SHIP.name\n
        \   end\n    MainScreen.ShipRunner = CommandSelect.ENGINES_NAME[eng]\n    if
        MainScreen.ShipRunner.start then\n        MainScreen.ShipRunner.start()\n
        \   end\nend\n\nlocal NEXTRENDER = 0.0\nlocal FLYTIME = 0.0\n\nfunction onUpdate(secs)\n
        \   SHIP.update()\n    if FLYTIME == 0.0 then\n        initialize()\n    end\n
        \   FLYTIME = FLYTIME + secs\n    if MainScreen.ShipRunner and MainScreen.ShipRunner.update
        then\n        if not (MainScreen.ShipCommand and MainScreen.ShipCommand.override)
        then\n            MainScreen.ShipRunner.update(secs)\n        end\n    end\n
        \   if MainScreen.ShipCommand and MainScreen.ShipCommand.update then\n        MainScreen.ShipCommand.update(secs)\n
        \   end\n    if FLYTIME > NEXTRENDER then\n        collectgarbage()\n        for
        _, hud in pairs(HUDConfig.ENABLED) do\n            if hud.update then\n                hud.update(secs)\n
        \           end\n        end\n        system.setScreen(generateContent())\n
        \       NEXTRENDER = FLYTIME + 0.1 -- 10 times a second\n    end\nend\n\nfunction
        setEngineControl(engine)\n    if engine.start then\n        engine.start()\n
        \   end\n    MainScreen.ShipRunner = engine\n    databank.setStringValue(\"eng\",
        engine.name)\nend\n\nfunction clearEngineCommand()\n    if MainScreen.ShipCommand
        and MainScreen.ShipCommand.stop then\n        MainScreen.ShipCommand.stop()\n
        \   end\n    databank.setStringValue(\"ec\", \"\")\n    MainScreen.ShipCommand
        = nil\nend\n\nfunction setEngineCommand(cmd)\n    if cmd.start then\n        cmd.start()\n
        \   end\n    databank.setStringValue(\"ec\", cmd.name)\n    MainScreen.ShipCommand
        = cmd\nend\n\n-- Input from the player comes through here\nfunction press(s)\n
        \   if s == \"GEAR\" then\n        MainScreen.onGEAR()\n        return\n    end\n
        \   local listener = MainScreen.ACTIVE\n    if s == \"LEFT\" and MainScreen.ShipCommand
        and listener.isControl then\n        clearEngineCommand()\n        return\n
        \   end\n    if listener.isWalk then\n        return\n    end\n    if listener.isControl
        then\n        if MainScreen.ShipCommand then\n            listener = MainScreen.ShipCommand\n
        \       end\n        if not listener.override_controls then\n            PHYSICS.PRESSED[s]
        = true\n            listener = MainScreen.ShipRunner\n        end\n    end\n
        \   local kb = \"start\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   end\nend\nfunction release(s)\n    if s == \"GEAR\" then\n        return\n
        \   end\n    local listener = MainScreen.ACTIVE\n    if listener.isWalk then\n
        \       return\n    end\n    if listener.isControl then\n        PHYSICS.PRESSED[s]
        = nil\n        listener = MainScreen.ShipRunner\n    end\n    local kb = \"stop\"
        .. s\n    local kb2 = \"on\" .. s\n    if listener[kb] then\n        listener[kb]()\n
        \   elseif listener[kb2] then\n        listener[kb2]()\n    elseif listener.hit
        then\n        listener.hit(s)\n    end\nend\nfunction loopKey(s)\n    if s
        == \"GEAR\" then\n        return\n    end\n    local listener = MainScreen.ACTIVE\n
        \   if listener.isWalk then\n        return\n    end\n    if listener.isControl
        then\n        listener = MainScreen.ShipRunner\n    end\n    local kb = \"loop\"
        .. s\n    if listener[kb] then\n        listener[kb]()\n    end\nend\nfunction
        initialize()\n    system.print(\"Initializing ShipOS 0.01\")\n    PHYSICS.update()\n
        \   HUDConfig.start()\n    MainScreen.start()\n    AutoPilotScreen.reset()\nend\n"
  unit:
    start:
      lua: |-
        _G.fueltanks = {
        atmo = atmofueltank,
        space = spacefueltank,
        rocket = rocketfueltank,
        }
