---
name: Arcade Conf
slots:
  alldata:
    class: DatabankUnit
  screen:
    class: ScreenUnit
handlers:
  system:
    actionStart:
      lua: press("DOWN")
      args: [backward]
    actionStop:
      lua: release("DOWN")
      args: [backward]
    actionStart:
      lua: press("BUTTON2")
      args: [down]
    actionStop:
      lua: release("BUTTON2")
      args: [down]
    actionStart:
      lua: press("UP")
      args: [forward]
    actionStop:
      lua: release("UP")
      args: [forward]
    actionStart:
      lua: press("Q")
      args: [left]
    actionStop:
      lua: release("Q")
      args: [left]
    actionStart:
      lua: press("E")
      args: [right]
    actionStop:
      lua: release("E")
      args: [right]
    stop:
      lua: setScene(SCENE_MENU)
    actionStart:
      lua: press("BUTTON")
      args: [up]
    actionStop:
      lua: release("BUTTON")
      args: [up]
    update:
      lua: onUpdate(system.getActionUpdateDeltaTime())
    actionStart:
      lua: press("LEFT")
      args: [yawleft]
    actionStop:
      lua: release("LEFT")
      args: [yawleft]
    actionStart:
      lua: press("RIGHT")
      args: [yawright]
    actionStop:
      lua: release("RIGHT")
      args: [yawright]
    start:
      lua: "local SCREEN_X = 1920\nlocal SCREEN_Y = 1080\n\nfunction svg(name, params,
        children)\n    local attrvals = \"\"\n    if params then\n        for k, v
        in pairs(params) do\n            k = k:gsub(\"%u\", function(c) return '-'
        .. c:lower() end)\n            attrvals = attrvals .. \" \" .. k .. '=\"'
        .. v .. '\"'\n        end\n    end\n    if children then\n        return string.format(\"<%s%s>%s</%s>\",
        name, attrvals, table.concat(children,\"\\n\"), name)\n    else\n        return
        string.format(\"<%s%s />\", name, attrvals)\n    end\nend\n\nscreen.activate()\nsystem.lockView(1)\n\nRenderer
        = {}\nRenderer.DRAWS = {}\nfunction addDraw(s)\n    Renderer.DRAWS[#Renderer.DRAWS+1]
        = s\nend\nfunction Renderer.draw(scene, secs)\n    Renderer.DRAWS = {}\n    if
        scene.update then\n        scene.update(secs)\n    end\n    if scene.render
        then\n        scene.render()\n    end\n    screen.setSVG(svg(\"g\", nil, Renderer.DRAWS))\nend\nfunction
        Renderer.debug()\n    local x = table.concat(Renderer.DRAWS, '')\n    system.print(string.gsub(string.gsub(x,
        \"<\", \"(\"), \">\", \")\"))\nend\n-- Start\n\nlocal ACTIVE_SCENE = {}\nlocal
        PRESSED = {}\nlocal DO_UPDATE = false\n\nfunction setScene(scene)\n    if
        ACTIVE_SCENE.saveState then\n        local state = ACTIVE_SCENE.saveState()\n
        \       if state then\n            alldata.setStringValue('save' .. ACTIVE_SCENE.dataid,
        json.encode(state))\n        end\n    end\n    ACTIVE_SCENE = scene\n    local
        newstate = nil\n    if scene.start and scene.dataid then\n        if alldata.hasKey('save'
        .. scene.dataid) then\n            local val = alldata.getStringValue('save'
        .. scene.dataid)\n            alldata.setStringValue('save' .. scene.dataid,
        \"\")\n\t    if val and val ~= \"\" then\n\t        newstate = json.decode(val)\n\t
        \   end\n        end\n    end\n    if scene.start then\n\tscene.start(newstate)\n
        \   end\n    Renderer.draw(ACTIVE_SCENE, 0.0)\n    DO_UPDATE = true\nend\n\nfunction
        onUpdate(secs)\n    if ACTIVE_SCENE.update or DO_UPDATE then\n        Renderer.draw(ACTIVE_SCENE,
        secs)\n\tDO_UPDATE = false\n    end\nend\n\n-- What defines a scene? A scene
        has:\n-- - A Render function.\n-- - Key handlers\n-- - Optional: SaveState()
        returns a JSON-able object, and LoadState(object)\n\n-- Input from the player
        comes through here\nfunction press(s)\n    RESET_SCORE = 0\n    PRESSED[s]
        = true\n    kb = \"onKey\" .. s\n    if ACTIVE_SCENE[kb] then\n        ACTIVE_SCENE[kb](s)
        -- Some games prefer click to holding down\n        Renderer.draw(ACTIVE_SCENE,
        0.0)\n    end\nend\nfunction release(s)\n    PRESSED[s] = nil\nend\nfunction
        keyState(s)\n    if PRESSED[s] then\n        return 1\n    else\n        return
        0\n    end\nend\nfunction makeHighScoreScene(startscene, gamename)\n    local
        scene = {}\n    scene.render = function()\n\tHIGHSCORES.render(gamename)\n
        \   end\n    scene.onKeyBUTTON = function()\n\tsetScene(startscene)\n    end\n
        \   scene.onKeyBUTTON2 = scene.onKeyBUTTON\n    scene.onKeyQ = scene.onKeyBUTTON\n
        \   return scene\nend\n\nHIGHSCORES = {}\n\nfunction HIGHSCORES.getHighScores(gamename)\n
        \   local scores = {}\n    for i = 1,5,1 do\n        if alldata.hasKey(gamename
        .. \"n\" .. i) then\n          scores[#scores+1] = {\n              alldata.getIntValue(gamename
        .. \"s\" .. i),\n              alldata.getStringValue(gamename .. \"n\" ..
        i),\n          }\n        end\n    end\n    return scores\nend\n\nfunction
        HIGHSCORES.addHighScore(gamename, name, total)\n    -- We have 15 values in
        our databank.\n    -- 10 for high score: 1 string + 1 number\n    -- 5 for
        recent: strings only\n\n    local scores = HIGHSCORES.getHighScores(gamename)\n
        \   local newscores = {}\n    local done = false\n    for i = 1,5,1 do\n        if
        not done and total > 0 and total > scores[i][1] then\n            newscores[#newscores+1]
        = {total, name}\n            done = true\n        end\n        newscores[#newscores+1]
        = scores[i]\n    end\n    if #newscores < 5 then\n        newscores[#newscores+1]
        = {total, name}\n    end\n    if done then\n      for i = 1,5,1 do\n          if
        #newscores >= i then\n              alldata.setIntValue(gamename .. \"s\"
        .. i, newscores[i][1])\n              alldata.setStringValue(gamename .. \"n\"
        .. i, newscores[i][2])\n          end\n      end\n    end\n\n    -- Rotate
        recent scores\n    for i = 4,1,-1 do\n        if alldata.hasKey(gamename ..
        \"r\" .. i) then\n            alldata.setStringValue(gamename .. \"r\" ..
        (i + 1), alldata.getStringValue(gamename .. \"r\" .. i))\n        end\n    end\n
        \   system.print(\"Setting \" .. gamename .. \"r1\" .. string.format(\"%.10d
        %s\", total, name))\n    alldata.setStringValue(gamename .. \"r1\", string.format(\"%.10d
        %s\", total, name))\nend\n\nHIGHSCORES.render = function(gamename)\n    local
        highs = HIGHSCORES.getHighScores(gamename)\n    addDraw(svg(\"style\", nil,
        {[[\n        .title { font: bold italic 120px fixed; fill: white; }\n        .score
        { font: bold 60px fixed; fill: yellow; }\n    ]]}))\n    addDraw(svg(\"text\",
        {x=320, y=160, class=\"title\"}, {\"High Scores - \" .. gamename}))\n    for
        i = 1,5,1 do\n        if highs[i] then\n            addDraw(svg(\"text\",
        {x=320, y=180 + 50*i, class=\"score\"}, {string.format(\"%.10d %s\", highs[i][1],
        highs[i][2])}))\n        end\n    end\n\n    addDraw(svg(\"text\", {x=320,
        y=600, class=\"title\"}, {\"Recent Scores:\"}))\n    for i = 1,5,1 do\n        if
        alldata.hasKey(gamename .. \"r\" .. i) then\n            addDraw(svg(\"text\",
        {x=320, y=640 + 50*i, class=\"score\"}, {alldata.getStringValue(gamename ..
        \"r\" .. i)}))\n        end\n    end\nend\n-- makeStartScene creates a scene
        that has a few bindings\n-- and updates. 'gamescene' object passed must have:\n--
        scene.name, scene.author, scene.helptext, scene.dataid (a normalized string
        like 'ast')\nfunction makeStartScene(gamescene)\n    local scene = {}\n\n
        \   local highscore_scene = makeHighScoreScene(scene, gamescene.dataid)\n
        \   gamescene.highscore_scene = highscore_scene\n\n    scene.render = function()\n
        \       -- Draw intro GUI screen.\n        -- Text styles used:\n        addDraw(svg(\"style\",
        nil, {[[\n            .title { font: bold italic 200px sans-serif; fill: white;
        }\n            .byline { font: bold italic 80px sans-serif; fill: yellow;
        }\n            .instr { font: bold 80px sans-serif; fill: blue; }\n        ]]}))\n
        \       addDraw(svg(\"text\", {x=220, y=280, class=\"title\"}, {gamescene.name}))\n
        \       addDraw(svg(\"text\", {x=320, y=500, class=\"byline\"}, {\"By \" ..
        gamescene.author}))\n        addDraw(svg(\"text\", {x=320, y=800, class=\"instr\"},
        {gamescene.helptext}))\n        addDraw(svg(\"text\", {x=320, y=900, class=\"instr\"},
        {\"Press SPACE start!\"}))\n        addDraw(svg(\"text\", {x=320, y=960, class=\"instr\"},
        {\"Press C to view High Scores\"}))\n        addDraw(svg(\"text\", {x=320,
        y=1020, class=\"instr\"}, {\"Press Q to return to Main Menu\"}))\n    end\n
        \   scene.onKeyBUTTON = function()\n\tsetScene(gamescene)\n    end\n    scene.onKeyBUTTON2
        = function()\n\tsetScene(highscore_scene)\n    end\n    scene.onKeyQ = function()\n\tsetScene(SCENE_MENU)\n
        \   end\n    return scene\nend\n\nfunction makeAndRegisterGame(gamescene)\n
        \   local startscene = makeStartScene(gamescene)\n    registerGame(gamescene.name,
        startscene)\nend\nSCENE_MENU = {\n    optionIdx = 1,\n    options = {},\n
        \   GAMES = {},\n    DEFAULT = {},\n}\n\nfunction rebuildMenu()\n    SCENE_MENU.options
        = {}\n    for k, v in pairs(SCENE_MENU.GAMES) do\n        table.insert(SCENE_MENU.options,
        v)\n    end\n    for k, v in pairs(SCENE_MENU.DEFAULT) do\n        table.insert(SCENE_MENU.options,
        v)\n    end\nend\n\nfunction registerGame(name, scene)\n    table.insert(SCENE_MENU.GAMES,
        {name=name, scene=scene})\n    rebuildMenu()\nend\n\nfunction registerDefaultScene(name,
        scene)\n    table.insert(SCENE_MENU.DEFAULT, {name=name, scene=scene})\n    rebuildMenu()\nend\n\nSCENE_MENU.render
        = function(secs)\n    -- Draw intro GUI screen.\n    -- Text styles used:\n
        \   addDraw(svg(\"style\", nil, {[[\n        .title { font: bold italic 160px
        sans-serif; fill: white; }\n        .item { font: bold 80px sans-serif; fill:
        gray; }\n        .choice { font: bold 80px sans-serif; fill: yellow; }\n    ]]}))\n
        \   addDraw(svg(\"text\", {x=120, y=280, class=\"title\"}, {\"Ready, Player
        One!\"}))\n\n    if SCENE_MENU.optionIdx > 2 then\n\tlocal opt1 = SCENE_MENU.options[SCENE_MENU.optionIdx
        - 2]\n        addDraw(svg(\"text\", {x=220, y=600, class=\"item\"}, {opt1.name}))\n
        \   end\n    if SCENE_MENU.optionIdx > 1 then\n\tlocal opt2 = SCENE_MENU.options[SCENE_MENU.optionIdx
        - 1]\n        addDraw(svg(\"text\", {x=220, y=700, class=\"item\"}, {opt2.name}))\n
        \   end\n    local choice = SCENE_MENU.options[SCENE_MENU.optionIdx]\n    addDraw(svg(\"text\",
        {x=220, y=800, class=\"choice\"}, {choice.name}))\n    if #SCENE_MENU.options
        > (SCENE_MENU.optionIdx) then\n\tlocal opt3 = SCENE_MENU.options[SCENE_MENU.optionIdx
        + 1]\n        addDraw(svg(\"text\", {x=220, y=900, class=\"item\"}, {opt3.name}))\n
        \   end\n    if #SCENE_MENU.options > (SCENE_MENU.optionIdx + 1) then\n\tlocal
        opt4 = SCENE_MENU.options[SCENE_MENU.optionIdx + 2]\n        addDraw(svg(\"text\",
        {x=220, y=1000, class=\"item\"}, {opt4.name}))\n    end\nend\n\nfunction SCENE_MENU.onKeyUP()\n
        \   SCENE_MENU.optionIdx = SCENE_MENU.optionIdx - 1\n    if SCENE_MENU.optionIdx
        < 1 then\n        SCENE_MENU.optionIdx = 1\n    end\nend\n\nfunction SCENE_MENU.onKeyDOWN()\n
        \   SCENE_MENU.optionIdx = SCENE_MENU.optionIdx + 1\n    if SCENE_MENU.optionIdx
        > #SCENE_MENU.options then\n        SCENE_MENU.optionIdx = #SCENE_MENU.options\n
        \   end\nend\n\nfunction SCENE_MENU.onKeyBUTTON()\n    choice = SCENE_MENU.options[SCENE_MENU.optionIdx]\n
        \   if choice.scene then\n\tsetScene(choice.scene)\n    end\nend\nlocal SCENE_CREDITS
        = {}\n\nSCENE_CREDITS.render = function(secs)\n    -- Draw intro GUI screen.\n
        \   -- Text styles used:\n    addDraw(svg(\"style\", nil, {[[\n        .title
        { font: bold italic 200px sans-serif; fill: white; }\n        .byline { font:
        bold italic 80px sans-serif; fill: yellow; }\n        .instr { font: bold
        80px sans-serif; fill: blue; }\n    ]]}))\n    addDraw(svg(\"text\", {x=220,
        y=280, class=\"title\"}, {\"RPO Arcade.\"}))\n    addDraw(svg(\"text\", {x=320,
        y=500, class=\"byline\"}, {\"By Sixtysixone\"}))\n    addDraw(svg(\"text\",
        {x=320, y=900, class=\"instr\"}, {\"Press space to exit!\"}))\nend\n\nSCENE_CREDITS.onKeyBUTTON
        = function()\n    setScene(SCENE_MENU)\nend\n\nregisterDefaultScene(\"Credits\",
        SCENE_CREDITS)\nlocal function makeAsteroidsScene()\n    local scene = {\n
        \       name = \"Blasteroids\",\n        author = \"Sixtysixone\",\n        helptext
        = \"WDA to move, SPACE to fire\",\n        dataid = \"ast\",\n    }\n\n    local
        SHIP_MAX_SPEED = 240\n    local SHIP_ACCEL = 100\n    local SHIP_ROTATION_PER_SECOND
        = 120.0\n    local MAX_BULLET_COUNT = 3\n    local BULLET_SPEED = 400\n    local
        ASTEROID_BIG = 60\n    local ASTEROID_MEDIUM = 40\n    local ASTEROID_SMALL
        = 25\n    local MAX_ASTEROIDS = 12\n    local MIN_ASTEROID_SPEED = 40\n    local
        ASTEROID_SPEED_VARIATION = 80\n\n    -- Game state variables:\n    local SHIP
        = {}\n    local SCORE = {}\n    local GAME_TIME = 0.0\n    local LAST_SPAWN
        = 0.0\n    local ASTEROID_COUNT = 0\n    local BULLETS = {}\n    local ASTEROIDS
        = {}\n\n    -- ASTEROID_DEFS is not kept between saves, but is regenerated
        every time a game\n    -- is loaded or started.\n    local ASTEROID_DEFS =
        \"\"\n\n    scene.saveState = function()\n        if SCORE.total < 1 then\n
        \           return nil\n        else\n            return {\n                SHIP
        = SHIP,\n                SCORE = SCORE,\n                GAME_TIME = GAME_TIME,\n
        \               LAST_SPAWN = LAST_SPAWN,\n                ASTEROID_COUNT =
        ASTEROID_COUNT,\n                BULLETS = BULLETS,\n                ASTEROIDS
        = ASTEROIDS,\n            }\n        end\n    end\n\n    local function getAsteroidDef(sz,
        elid)\n        -- An asteroid is drawn as 16 vertices, almost all the same
        but slightly randomized.\n        local vertices = {}\n        for i = 1,16,1
        do\n            local angle = (((22.5 * i + math.random(-5,5)) % 360) / 180)
        * math.pi\n            local vsz = sz - math.random(0,8)\n            vertices[#vertices+1]
        = string.format(\"%d,%d\", math.floor(math.cos(angle) * vsz), math.floor(math.sin(angle)
        * vsz))\n        end\n\tvertices[#vertices+1] = vertices[1]\n        return
        svg(\"polyline\", {id=elid, points=table.concat(vertices, \" \"), strokeWidth=4,
        stroke=\"yellow\"})\n    end\n\n    local function getAsteroidSvgs(sz)\n        local
        ret = svg(\"defs\", nil, {\n            getAsteroidDef(ASTEROID_BIG, \"a\"
        .. ASTEROID_BIG),\n            getAsteroidDef(ASTEROID_MEDIUM, \"a\" .. ASTEROID_MEDIUM),\n
        \           getAsteroidDef(ASTEROID_SMALL, \"a\" .. ASTEROID_SMALL),\n        })\n
        \       return ret\n    end\n\n    local function getAsteroidPos()\n        --
        Pick a random place about 30 pixels OUTSIDE the screen.\n        local pos
        = math.random()\n        local fromdir = math.random(4)\n        local dir
        = math.random(140) + 20\n\n        if fromdir == 1 then\n            -- On
        top\n            return {\n                posX = math.floor((pos * SCREEN_X)
        + 60)- 30,\n                posY = -30,\n                dir = (dir + 0) %
        360\n            }\n        elseif fromdir == 2 then\n            -- On the
        right side\n            return {\n                posX = SCREEN_X + 30,\n
        \               posY = math.floor((pos * SCREEN_Y) + 60)- 30,\n                dir
        = (dir + 90) % 360\n            }\n        elseif fromdir == 3 then\n            --
        On bottom\n            return {\n                posX = math.floor((pos *
        SCREEN_X) + 180)- 30,\n                posY = SCREEN_Y - 30,\n                dir
        = (dir + 180) % 360\n            }\n        else\n            -- On the left\n
        \           return {\n                posX = -30,\n                posY =
        math.floor((pos * SCREEN_Y) + 60)- 30,\n                dir = (dir + 270)
        % 360,\n            }\n        end\n    end\n\n\n    local function spawnAsteroid(from)\n
        \       if #ASTEROIDS >= MAX_ASTEROIDS then\n            return\n        end\n
        \       LAST_SPAWN = GAME_TIME\n        ASTEROID_COUNT = ASTEROID_COUNT +
        1\n        local ast = getAsteroidPos()\n        ast.spd = MIN_ASTEROID_SPEED
        + math.random(ASTEROID_SPEED_VARIATION) + ASTEROID_COUNT\n        ast.velX
        = math.cos((ast.dir / 180) * math.pi) * ast.spd\n        ast.velY = math.sin((ast.dir
        / 180) * math.pi) * ast.spd\n        ast.size = 60\n        ast.alive = true\n
        \       ASTEROIDS[#ASTEROIDS+1] = ast\n    end\n\n    local function resetGame()\n
        \     GAME_TIME = 0.0\n      LAST_SPAWN = 0.0\n      SCORE = {\n        total
        = 0,\n        bonus = 0,\n      }\n      SHIP = {\n        dir = 0,\n        posX
        = SCREEN_X/2,\n        posY = SCREEN_Y/2,\n        speed = 0.0,\n        velX
        = 0.0,\n        velY = 0.0,\n        size = 15,\n      }\n      BULLETS =
        {}\n      ASTEROIDS = {}\n      ASTEROID_COUNT = 0\n      ASTEROID_DEFS =
        getAsteroidSvgs()\n\n      for i = 1,10,1 do\n          spawnAsteroid()\n
        \     end\n    end\n\n    scene.start = function(state)\n        if state
        and state.SHIP and state.GAME_TIME then\n            SHIP = state.SHIP\n            SCORE
        = state.SCORE\n            GAME_TIME = state.GAME_TIME\n            LAST_SPAWN
        = state.LAST_SPAWN\n            ASTEROID_COUNT = state.ASTEROID_COUNT\n            BULLETS
        = state.BULLETS\n            ASTEROIDS = state.ASTEROIDS\n            ASTEROID_DEFS
        = getAsteroidSvgs()\n        else\n            resetGame()\n        end\n
        \   end\n\n    local function moveShip(secs)\n      -- Move the ship\n      SHIP.posX
        = SHIP.posX + SHIP.velX * secs\n      SHIP.posY = SHIP.posY + SHIP.velY *
        secs\n\n      -- Turn the ship\n      local dirPressed = keyState(\"RIGHT\")
        - keyState(\"LEFT\")\n      SHIP.dir = SHIP.dir + (dirPressed * SHIP_ROTATION_PER_SECOND
        * secs)\n      if SHIP.dir < 0.0 then\n          SHIP.dir = SHIP.dir + 360.0\n
        \     elseif SHIP.dir >= 360.0 then\n          SHIP.dir = SHIP.dir - 360.0\n
        \     end\n\n      if SHIP.posX < 0 then\n        SHIP.posX = SHIP.posX +
        SCREEN_X\n      elseif SHIP.posX > SCREEN_X then\n        SHIP.posX = SHIP.posX
        - SCREEN_X\n      end\n\n      if SHIP.posY < 0 then\n        SHIP.posY =
        SHIP.posY + SCREEN_Y\n      elseif SHIP.posY > SCREEN_Y then\n        SHIP.posY
        = SHIP.posY - SCREEN_Y\n      end\n\n      -- Accelerate the ship\n      local
        oldX = SHIP.velX\n      local oldY = SHIP.velY\n      local speedPressed =
        keyState(\"UP\")\n      SHIP.velX = SHIP.velX + math.cos((SHIP.dir / 180)
        * math.pi) * speedPressed * SHIP_ACCEL * secs\n      SHIP.velY = SHIP.velY
        + math.sin((SHIP.dir / 180) * math.pi) * speedPressed * SHIP_ACCEL * secs\n
        \     if math.sqrt(SHIP.velX * SHIP.velX + SHIP.velY * SHIP.velY) > SHIP_MAX_SPEED
        then\n        SHIP.velX = oldX\n        SHIP.velY = oldY\n      end\n    end\n\n
        \   local function drawShip()\n        addDraw(svg(\"g\",\n            {\n
        \               transform=string.format('translate(%d %d)', math.floor(SHIP.posX),
        math.floor(SHIP.posY))\n            },\n            {svg(\"g\", {transform=string.format(\"rotate(%d
        0 0)\", math.floor(SHIP.dir))},\n            {\n                svg(\"line\",
        {x1=\"-20\", y1=\"-20\", x2=\"30\", y2=\"0\", stroke=\"green\", strokeWidth='6'}),\n
        \               svg(\"line\", {x1=\"-20\", y1=\"20\", x2=\"30\", y2=\"0\",
        stroke=\"green\", strokeWidth='6'}),\n                svg(\"line\", {x1=\"-20\",
        y1=\"20\", x2=\"-20\", y2=\"-20\", stroke=\"green\", strokeWidth='6'}),\n
        \           })}\n        ))\n    end\n\n    scene.onKeyBUTTON = function()\n
        \       if #BULLETS < MAX_BULLET_COUNT then\n            local velX = BULLET_SPEED
        * math.cos((SHIP.dir / 180) * math.pi) + SHIP.velX\n            local velY
        = BULLET_SPEED * math.sin((SHIP.dir / 180) * math.pi) + SHIP.velY\n            BULLETS[#BULLETS+1]
        = {\n                posX = SHIP.posX,\n                posY = SHIP.posY,\n
        \               velX = velX,\n                velY = velY,\n                size
        = 5,\n                alive = true,\n            }\n        end\n    end\n\n
        \   local function moveBullets(secs)\n        local old = BULLETS\n        BULLETS
        = {}\n        for k, v in ipairs(old) do\n            if v.alive then\n              v.posX
        = v.posX + v.velX * secs\n              v.posY = v.posY + v.velY * secs\n
        \             if v.posX > 0 and v.posX < SCREEN_X and v.posY > 0 and v.posY
        < SCREEN_Y then\n                  addDraw(svg(\"circle\", {cx=v.posX, cy=v.posY,
        r=5, fill=\"yellow\"}))\n                  BULLETS[#BULLETS+1] = v\n              else\n
        \                 SCORE.bonus = 0\n              end\n            end\n        end\n
        \   end\n    local function getAsteroidSvg(ast)\n        local attrs = {\n
        \           x = ast.posX,\n            y = ast.posY,\n        }\n        attrs[\"xlink:href\"]
        = \"#a\" .. ast.size\n        return svg(\"use\", attrs)\n    end\n\n    local
        function breakAsteroid(old)\n        old.alive = false\n        if old.size
        <= ASTEROID_SMALL then\n            return\n        end\n        for i = 1,3,1
        do\n          local ast = {\n              posX = old.posX + math.random(-20,20),\n
        \             posY = old.posY + math.random(-20,20),\n              dir =
        old.dir + math.random(-30, 30),\n          }\n          ast.spd = old.spd
        + math.random(20, 40)\n          ast.velX = math.cos((ast.dir / 180) * math.pi)
        * ast.spd\n          ast.velY = math.sin((ast.dir / 180) * math.pi) * ast.spd\n
        \         if old.size == ASTEROID_BIG then\n            ast.size = ASTEROID_MEDIUM\n
        \         elseif old.size == ASTEROID_MEDIUM then\n            ast.size =
        ASTEROID_SMALL\n          else\n            -- wtf\n            ast.size =
        ASTEROID_SMALL\n          end\n          ast.alive = true\n          ASTEROIDS[#ASTEROIDS+1]
        = ast\n        end\n    end\n\n    local function moveAsteroids(secs)\n        local
        old = ASTEROIDS\n        ASTEROIDS = {}\n        for k, v in ipairs(old) do\n
        \           if v.alive then\n              v.posX = v.posX + v.velX * secs\n
        \             v.posY = v.posY + v.velY * secs\n              if v.posX > -30
        and v.posX < SCREEN_X + 30 and v.posY > -30 and v.posY < SCREEN_Y + 30 then\n
        \                 addDraw(getAsteroidSvg(v))\n                  ASTEROIDS[#ASTEROIDS+1]
        = v\n              end\n            end\n        end\n    end\n\n    local
        function checkCollide(a, b)\n      local dx = a.posX - b.posX\n      local
        dy = a.posY - b.posY\n      local dm = a.size + b.size\n      if (dx * dx)
        + (dy * dy) < (dm * dm) then\n        return true\n      end\n      return
        false\n    end\n\n    local function endGame()\n        HIGHSCORES.addHighScore(scene.dataid,
        system.getPlayerName(unit.getMasterPlayerId()), SCORE.total)\n\tSCORE.total
        = 0\n\tsetScene(scene.highscore_scene)\n    end\n\n    local function checkCollisions()\n
        \       for k, asteroid in pairs(ASTEROIDS) do\n            if checkCollide(SHIP,
        asteroid) then\n                endGame()\n            end\n            for
        b, bullet in pairs(BULLETS) do\n              if checkCollide(bullet, asteroid)
        then\n                bullet.alive = false\n                if asteroid.size
        == ASTEROID_BIG then\n                  SCORE.total = SCORE.total + SCORE.bonus
        + 5\n                elseif asteroid.size == ASTEROID_MEDIUM then\n                  SCORE.total
        = SCORE.total + SCORE.bonus + 10\n                else\n                  SCORE.total
        = SCORE.total + (SCORE.bonus * 2) + 20\n                end\n                SCORE.bonus
        = SCORE.bonus + 2\n                breakAsteroid(asteroid)\n                break\n
        \             end\n            end\n        end\n    end\n\n    local function
        drawGUI()\n        addDraw(svg(\"style\", nil, {[[\n          .score { font:
        bold 60px sans-serif; fill: white; stroke-width: 3; stroke-color: black; }\n
        \       ]]}))\n        addDraw(svg(\"text\", {x=SCREEN_X/2 - 60, y=SCREEN_Y-90,
        class=\"score\"}, {string.format(\"SCORE: %d\", SCORE.total)}))\n    end\n\n
        \   scene.update = function(secs)\n        -- Add asteroid definitions\n        addDraw(ASTEROID_DEFS)\n
        \       GAME_TIME = GAME_TIME + secs\n\n        if (GAME_TIME - LAST_SPAWN)
        > 0.5 then\n            spawnAsteroid()\n        end\n        moveShip(secs)\n
        \       moveBullets(secs)\n        moveAsteroids(secs)\n        drawShip()\n
        \       drawGUI()\n        checkCollisions()\n    end\n    return scene\nend\n\nmakeAndRegisterGame(makeAsteroidsScene())\nlocal
        function makeHurdleScene()\n    local scene = {\n        name = \"Hovercraft
        Hurdle\",\n        author = \"Sixtysixone\",\n        helptext = \"SPACE to
        accelerate up\",\n        dataid = \"hch\",\n    }\n\n    local SPEED_X =
        150\n    local ACCEL_Y = 150\n    local MAX_SPEED_Y = 300\n    local SHIP_X
        = 100\n    local SHIP_WIDTH = 40\n    local SHIP_HEIGHT = 30\n    local WALL_WIDTH
        = 20\n    local SCORE_PER_UNIT = 1\n\n    -- Game state variables:\n    local
        SHIP = {}\n    local SCORE = 0.0\n    local MAYBE_SCORE = 0.0\n    local GAME_TIME
        = 0.0\n    local NEXT_SPAWN = 0.0\n    local WALLS = {}\n\n    scene.saveState
        = function()\n        if GAME_TIME > 3.0 then\n            return {\n                SHIP
        = SHIP,\n                GAME_TIME = GAME_TIME,\n                NEXT_SPAWN
        = NEXT_SPAWN,\n                MAYBE_SCORE = MAYBE_SCORE,\n                WALLS
        = WALLS,\n            }\n        end\n    end\n\n    local function spawnWall(pos)\n
        \       local hole = math.random(250, 800)\n        local wall = {\n            posX
        = pos,\n            middle = hole,\n            bottom = hole + 100,\n            top
        = hole - 100,\n        }\n        table.insert(WALLS, wall)\n    end\n\n    local
        function resetGame()\n      GAME_TIME = 0.0\n      NEXT_SPAWN = 3.0\n      SCORE
        = 0.0\n      MAYBE_SCORE = 0.0\n      SHIP = {\n        posX = SHIP_X,\n        posY
        = SCREEN_Y/2,\n        velY = 0.0,\n      }\n      WALLS = {}\n      spawnWall(1100)\n
        \     spawnWall(1400)\n      spawnWall(1700)\n      spawnWall(2000)\n    end\n\n
        \   scene.start = function(state)\n        if false and state and state.SHIP
        and state.GAME_TIME then\n            system.print(\"we have data to load\")\n
        \           SHIP = state.SHIP\n            GAME_TIME = state.GAME_TIME\n            NEXT_SPAWN
        = state.NEXT_SPAWN\n            MAYBE_SCORE = state.MAYBE_SCORE\n            WALLS
        = state.WALLS\n        else\n            resetGame()\n        end\n    end\n\n
        \   local function moveShip(secs)\n      -- Move the ship\n      SHIP.posY
        = SHIP.posY + SHIP.velY * secs\n\n      local accel = ACCEL_Y * secs\n      if
        keyState(\"BUTTON\") > 0 then\n          accel = -ACCEL_Y * secs\n      end\n\n
        \     SHIP.velY = SHIP.velY + accel\n      if SHIP.velY > MAX_SPEED_Y then\n
        \         SHIP.velY = MAX_SPEED_Y\n      elseif SHIP.velY < -MAX_SPEED_Y then\n
        \         SHIP.velY = -MAX_SPEED_Y\n      end\n\n      if SHIP.posY < 25 then\n
        \         SHIP.posY = 25\n          SHIP.velY = 0\n      elseif SHIP.posY
        > (SCREEN_Y - 25) then\n          SHIP.posY = SCREEN_Y - 25\n          SHIP.velY
        = 0\n      end\n    end\n\n    local function drawShip()\n        addDraw(svg(\"polyline\",
        {\n            transform=string.format('translate(%d %d)', math.floor(SHIP.posX),
        math.floor(SHIP.posY)),\n            points = \"-20,-20 -15,-20 -10,-15 20,-15
        20,10 15,20 -15,20 -20,15 -20,-20\",\n            stroke = \"green\",\n            strokeWidth
        = \"6\",\n        }))\n    end\n\n    local function drawWalls()\n        for
        w, wall in pairs(WALLS) do\n            addDraw(svg(\"rect\", {\n                x
        = math.floor(wall.posX - WALL_WIDTH/2),\n                y = 0,\n                height
        = math.floor(wall.top),\n                fill = \"white\",\n                width
        = WALL_WIDTH,\n            }))\n            addDraw(svg(\"rect\", {\n                x
        = math.floor(wall.posX - WALL_WIDTH/2),\n                y = wall.bottom,\n
        \               height = math.floor(SCREEN_Y - wall.bottom),\n                fill
        = \"white\",\n                width = WALL_WIDTH,\n            }))\n        end\n
        \   end\n\n    local function moveWalls(secs)\n        local old = WALLS\n
        \       WALLS = {}\n        for w, wall in pairs(old) do\n            wall.posX
        = wall.posX - (secs * SPEED_X)\n            if wall.posX > -20 then\n                table.insert(WALLS,
        wall)\n            end\n        end\n    end\n\n    local function endGame()\n
        \       HIGHSCORES.addHighScore(scene.dataid, system.getPlayerName(unit.getMasterPlayerId()),
        math.floor(SCORE))\n        GAME_TIME = 0.0\n        setScene(scene.highscore_scene)\n
        \   end\n\n    local function checkCollisions()\n        -- We can only ever
        hit the 1st wall\n        local wall = WALLS[1]\n        if wall.posX < (SHIP_X
        + (WALL_WIDTH/2 + SHIP_WIDTH/2)) and wall.posX > (SHIP_X - (WALL_WIDTH/2 +
        SHIP_WIDTH/2)) then\n            if wall.top > (SHIP.posY - SHIP_HEIGHT/2)
        then\n                endGame()\n                return true\n            elseif
        wall.bottom < (SHIP.posY + SHIP_HEIGHT/2) then\n                endGame()\n
        \               return true\n            else\n                local dist
        = (math.abs(SHIP.posY - wall.middle)/5)\n                local dscore = math.floor(dist*dist*SCORE_PER_UNIT)\n
        \               if dscore > MAYBE_SCORE then\n                    MAYBE_SCORE
        = dscore\n                end\n            end\n        elseif MAYBE_SCORE
        > 0.0 then\n            SCORE = SCORE + MAYBE_SCORE\n            MAYBE_SCORE
        = 0.0\n        end\n        return false\n    end\n\n    local function drawGUI()\n
        \       addDraw(svg(\"style\", nil, {[[\n          .score { font: bold 60px
        sans-serif; fill: white; stroke-width: 3; stroke-color: black; }\n        ]]}))\n
        \       addDraw(svg(\"text\", {x=SCREEN_X/2 - 60, y=SCREEN_Y-90, class=\"score\"},
        {string.format(\"SCORE: %d\", math.floor(SCORE))}))\n    end\n\n    scene.update
        = function(secs)\n        -- Add asteroid definitions\n        GAME_TIME =
        GAME_TIME + secs\n\n        if GAME_TIME > NEXT_SPAWN then\n            spawnWall(2000)\n
        \           NEXT_SPAWN = GAME_TIME + 2.0 + (math.random() * 2.0)\n        end\n
        \       moveShip(secs)\n        moveWalls(secs)\n        if not checkCollisions()
        then\n          drawShip()\n          drawWalls()\n          drawGUI()\n        end\n
        \   end\n    return scene\nend\n\nmakeAndRegisterGame(makeHurdleScene())\nlocal
        function makeRhythmScene()\n    local scene = {\n        name = \"Key Rhythm\",\n
        \       author = \"Sixtysixone\",\n        helptext = \"W, A, S and D, and
        space when they turn white\",\n        dataid = \"rhythm\",\n    }\n\n    local
        GAME_TIME = 0.0\n    local X_PER_SECOND = 500\n    local ZERO_OFFSET = 300\n
        \   local RHYTHM_OFFSET = 1.0\n    local MAX_RANK = 30\n    local RANK_MISSED
        = -3\n    local RANK_WRONG = -2\n    local RANK_GOOD = 1\n    local ENDED
        = false\n    local END_TIMER = 0.0\n\n    local RHYTHM_END = 0.0\n    local
        KEYS = {}\n    local SCORE = {}\n\n    local SCORE_GOOD = 50\n    local SCORE_OKAY
        = 20\n\n    scene.saveState = function()\n    end\n\n    local KEYPOS = {\n
        \     W = 200,\n      A = 300,\n      S = 400,\n      D = 500,\n      _ =
        700,\n    }\n\n    local function resetGame()\n        GAME_TIME = 0.0\n        KEYS
        = {}\n        RHYTHM_END = 2.0\n        ENDED = false\n        END_TIMER =
        0.0\n        SCORE = {\n            total = 0,\n            bonus = 0,\n            rank
        = 20,\n        }\n    end\n\n    scene.start = function(state)\n        if
        false and state and state.SHIP and state.GAME_TIME then\n        else\n            resetGame()\n
        \       end\n    end\n\n    local function drawKeys()\n        for k, key
        in pairs(KEYS) do\n            local tdiff = key.time - GAME_TIME\n            local
        xpos = tdiff * X_PER_SECOND + ZERO_OFFSET\n            local cls = key.class\n
        \           if cls == \"upcoming\" and math.abs(key.time - GAME_TIME) < 0.2
        then\n                cls = \"now\"\n            end\n            addDraw(svg(\n
        \               \"text\", {\n                    x=xpos,\n                    y=KEYPOS[key.key],\n
        \                   class=cls,\n                },\n                {key.key}\n
        \           ))\n        end\n        addDraw(svg(\"line\", {\n            x1=ZERO_OFFSET,\n
        \           y1=0,\n            x2=ZERO_OFFSET,\n            y2=SCREEN_Y,\n
        \           stroke = \"green\",\n            strokeWidth = \"3\",\n        }))\n
        \   end\n\n    local function endGame()\n        HIGHSCORES.addHighScore(scene.dataid,
        system.getPlayerName(unit.getMasterPlayerId()), math.floor(SCORE.total))\n
        \       GAME_TIME = 0.0\n        END_TIMER = 3.0\n        ENDED = true\n    end\n\n
        \   local function shuffle(x)\n        shuffled = {}\n        for i, v in
        ipairs(x) do\n          \tlocal pos = math.random(1, #shuffled+1)\n          \ttable.insert(shuffled,
        pos, v)\n        end\n        return shuffled\n    end\n\n    local function
        makeRhythm()\n        local complexity = math.floor(70 - (GAME_TIME/2))\n
        \       local beat_time = 0.5\n        while complexity < 0 do\n            beat_time
        = beat_time * 0.9\n            complexity = complexity + 20\n        end\n
        \       local ktime = RHYTHM_END\n        local beat_len = math.random(3,5)\n
        \       local repeat_len = math.random(2,4)\n        RHYTHM_END = ktime +
        ((beat_len * beat_time) * repeat_len) + RHYTHM_OFFSET\n\n        local beat
        = {}\n        for i=1,beat_len,1 do\n            local rand = math.random(100)
        - complexity\n            local keys = shuffle({\"W\", \"A\", \"S\", \"D\",
        \"_\"})\n            local n = 1\n            while rand > 0 and n < 4 do\n
        \               rand = rand - 40\n                table.insert(beat, {\n                    key=
        keys[n],\n                    time= i * beat_time,\n                })\n                n
        = n + 1\n            end\n        end\n        for j=1,repeat_len,1 do\n            local
        offt = ktime + (j-1) * (beat_len * beat_time)\n            for i=1,#beat,1
        do\n                local k = beat[i]\n                table.insert(KEYS,
        {\n                    key= k.key,\n                    time= offt + k.time,\n
        \                   class = \"upcoming\",\n                })\n            end\n
        \       end\n    end\n\n    local function updateKeys()\n        -- Filter
        out passed keys\n        local old = KEYS\n        KEYS = {}\n        for
        k, key in ipairs(old) do\n            if key.time > (GAME_TIME - 3.0) then\n
        \               table.insert(KEYS, key)\n            end\n            if key.time
        < (GAME_TIME - 0.3) and key.class == \"upcoming\" then\n                key.class
        = \"missed\"\n                SCORE.bonus = 0\n                SCORE.rank
        = SCORE.rank + RANK_MISSED\n            end\n        end\n        while RHYTHM_END
        < (GAME_TIME + 30.0) do\n            makeRhythm()\n        end\n    end\n\n
        \   local function hitkey(hit)\n        local good = false\n        for k,
        key in ipairs(KEYS) do\n            if key.time > (GAME_TIME + 0.3) then\n
        \             break\n            end\n            if key.class == \"upcoming\"
        and key.time > (GAME_TIME - 0.3) then\n              if key.key == hit then\n
        \                 if math.abs(key.time - GAME_TIME) < 0.1 then\n                      SCORE.total
        = SCORE.total + SCORE.bonus + SCORE_GOOD\n                      SCORE.bonus
        = SCORE.bonus + 2\n                      key.class = \"good\"\n                  else\n
        \                     SCORE.total = SCORE.total + SCORE_OKAY\n                      key.class
        = \"okay\"\n                  end\n                  good = true\n                  break\n
        \             end\n            end\n        end\n        if good then\n            SCORE.rank
        = SCORE.rank + RANK_GOOD\n            if SCORE.rank > MAX_RANK then\n                SCORE.rank
        = MAX_RANK\n            end\n        else\n            SCORE.bonus = 0\n            SCORE.rank
        = SCORE.rank + RANK_WRONG\n        end\n    end\n\n    local function checkRank()\n
        \       if SCORE.rank < 0 then\n            endGame()\n        end\n    end\n\n
        \   local function getRankSym()\n        if SCORE.rank == 30 then\n            return
        \"S\"\n        elseif SCORE.rank > 25 then\n            return \"A\"\n        elseif
        SCORE.rank > 15 then\n            return \"B\"\n        elseif SCORE.rank
        > 5 then\n            return \"C\"\n        else\n            return \"D\"\n
        \       end\n    end\n\n    scene.onKeyUP = function() hitkey(\"W\") end\n
        \   scene.onKeyDOWN = function() hitkey(\"S\") end\n    scene.onKeyLEFT =
        function() hitkey(\"A\") end\n    scene.onKeyRIGHT = function() hitkey(\"D\")
        end\n    scene.onKeyBUTTON = function() hitkey(\"_\") end\n\n    local function
        drawGUI()\n        addDraw(svg(\"text\", {x=SCREEN_X/2 - 60, y=SCREEN_Y-90,
        class=\"score\"}, {string.format(\"RANK: %s SCORE: %d\", getRankSym(), math.floor(SCORE.total))}))\n
        \   end\n\n    scene.update = function(secs)\n        addDraw(svg(\"style\",
        nil, {[[\n          .upcoming { font: bold 120px sans-serif; fill: #bbbbbb;
        }\n          .now { font: bold 120px sans-serif; fill: #ffffff; }\n          .good
        { font: bold 120px sans-serif; fill: #00ff00; }\n          .okay { font: bold
        120px sans-serif; fill: #009900; }\n          .missed { font: bold 120px sans-serif;
        fill: #ff0000; }\n          .score { font: bold 60px sans-serif; fill: white;
        }\n          .ended { font: bold 60px sans-serif; fill: white; }\n        ]]}))\n\n
        \       drawKeys()\n        drawGUI()\n\n        if ENDED and END_TIMER >
        0.0 then\n          END_TIMER = END_TIMER - secs\n          addDraw(svg(\"text\",
        {x=SCREEN_X/2 - 80, y=SCREEN_Y/2 - 50, class=\"ended\"}, {\"GAME OVER\"}))\n
        \         if END_TIMER <= 0.0 then\n              setScene(scene.highscore_scene)\n
        \         end\n        else\n          GAME_TIME = GAME_TIME + secs\n          updateKeys()\n
        \         checkRank()\n        end\n    end\n    return scene\nend\n\nmakeAndRegisterGame(makeRhythmScene())\n\nsetScene(SCENE_MENU)\n"
